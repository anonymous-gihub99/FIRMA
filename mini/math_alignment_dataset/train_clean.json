[
  {
    "informal_statement": "For all odd $n$ show that $8 \\\\mid n^{2}-1$.",
    "formal_statement": "theorem exercise_1_27 {n : \\u2115} (hn : odd n) : 8 \\u2223 (n^2 - 1)"
  },
  {
    "informal_statement": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\\\bar{V}$ is compact and $\\\\bar{V} \\\\subset U$.",
    "formal_statement": "theorem exercise_29_10 {X : Type*}\\n [topological_space X] [t2_space X] (x : X)\\n (hx : \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 (\\u2203 K : set X, U \\u2282 K \\u2227 is_compact K))\\n (U : set X) (hU : is_open U) (hxU : x \\u2208 U) :\\n \\u2203 (V : set X), is_open V \\u2227 x \\u2208 V \\u2227 is_compact (closure V) \\u2227 closure V \\u2286 U"
  },
  {
    "informal_statement": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\\\{z \\\\in \\\\mathbb{C}:|z| \\\\leq 1\\\\}$.",
    "formal_statement": "theorem exercise_2018_b2 (n : \\u2115) (hn : n > 0) (f : \\u2115 \\u2192 \\u2102 \\u2192 \\u2102) \\n (hf : \\u2200 n : \\u2115, f n = \\u03bb z, (\\u2211 (i : fin n), (n-i)* z^(i : \\u2115))) : \\n \\u00ac (\\u2203 z : \\u2102, \\u2016z\\u2016 \\u2264 1 \\u2227 f n z = 0)"
  },
  {
    "informal_statement": "Show that a group of order 5 must be abelian.",
    "formal_statement": "theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\\n (hG : card G = 5) :\\n comm_group G"
  },
  {
    "informal_statement": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "formal_statement": "theorem exercise_25_4 {X : Type*} [topological_space X]\\n [loc_path_connected_space X] (U : set X) (hU : is_open U)\\n (hcU : is_connected U) : is_path_connected U"
  },
  {
    "informal_statement": "If $z$ is a complex number, prove that there exists an $r\\\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "formal_statement": "theorem exercise_1_11a (z : \\u2102) : \\n \\u2203 (r : \\u211d) (w : \\u2102), abs w = 1 \\u2227 z = r * w"
  },
  {
    "informal_statement": "Suppose $V$ is a complex inner-product space and $T \\\\in \\\\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "formal_statement": "theorem exercise_7_10 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\\n is_self_adjoint T \\u2227 T^2 = T"
  },
  {
    "informal_statement": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\\\equiv 1(p q)$.",
    "formal_statement": "theorem exercise_3_14 {p q n : \\u2115} (hp0 : p.prime \\u2227 p > 2) \\n (hq0 : q.prime \\u2227 q > 2) (hpq0 : p \\u2260 q) (hpq1 : p - 1 \\u2223 q - 1)\\n (hn : n.gcd (p*q) = 1) : \\n n^(q-1) \\u2261 1 [MOD p*q]"
  },
  {
    "informal_statement": "Prove that $(x, y)$ is not a principal ideal in $\\\\mathbb{Q}[x, y]$.",
    "formal_statement": "theorem exercise_9_3_2 {f g : polynomial \\u211a} (i j : \\u2115)\\n (hfg : \\u2200 n : \\u2115, \\u2203 a : \\u2124, (f*g).coeff = a) :\\n \\u2203 a : \\u2124, f.coeff i * g.coeff j = a"
  },
  {
    "informal_statement": "Let $\\\\left\\\\{A_{n}\\\\right\\\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\\\cap A_{n+1} \\\\neq \\\\varnothing$ for all $n$. Show that $\\\\bigcup A_{n}$ is connected.",
    "formal_statement": "theorem exercise_23_2 {X : Type*}\\n [topological_space X] {A : \\u2115 \\u2192 set X} (hA : \\u2200 n, is_connected (A n))\\n (hAn : \\u2200 n, A n \\u2229 A (n + 1) \\u2260 \\u2205) :\\n is_connected (\\u22c3 n, A n)"
  },
  {
    "informal_statement": "If $G$ is a nonabelian group of order 6, prove that $G \\\\simeq S_3$.",
    "formal_statement": "theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\\n (hG : card G = 6) (hG' : is_empty (comm_group G)) :\\n G \\u2243* equiv.perm (fin 3)"
  },
  {
    "informal_statement": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "formal_statement": "theorem exercise_2_27a (k : \\u2115) (E P : set (euclidean_space \\u211d (fin k)))\\n (hE : E.nonempty \\u2227 \\u00ac set.countable E)\\n (hP : P = {x | \\u2200 U \\u2208 \\ud835\\udcdd x, \\u00ac set.countable (P \\u2229 E)}) :\\n is_closed P \\u2227 P = {x | cluster_pt x (\\ud835\\udcdf P)}"
  },
  {
    "informal_statement": "Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "formal_statement": "theorem exercise_2_27a (k : \\u2115) (E P : set (euclidean_space \\u211d (fin k)))\\n (hE : E.nonempty \\u2227 \\u00ac set.countable E)\\n (hP : P = {x | \\u2200 U \\u2208 \\ud835\\udcdd x, \\u00ac set.countable (P \\u2229 E)}) :\\n is_closed P \\u2227 P = {x | cluster_pt x (\\ud835\\udcdf P)}"
  },
  {
    "informal_statement": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "formal_statement": "theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\\n [module K V] {S : set V} (hS : set.countable S)\\n (hS1 : span K S = \\u22a4) {\\u03b9 : Type*} (R : \\u03b9 \\u2192 V)\\n (hR : linear_independent K R) : countable \\u03b9"
  },
  {
    "informal_statement": "Show that the rationals $\\\\mathbb{Q}$ are not locally compact.",
    "formal_statement": "theorem exercise_29_10 {X : Type*}\\n [topological_space X] [t2_space X] (x : X)\\n (hx : \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 (\\u2203 K : set X, U \\u2282 K \\u2227 is_compact K))\\n (U : set X) (hU : is_open U) (hxU : x \\u2208 U) :\\n \\u2203 (V : set X), is_open V \\u2227 x \\u2208 V \\u2227 is_compact (closure V) \\u2227 closure V \\u2286 U"
  },
  {
    "informal_statement": "Prove that if $G$ is an abelian simple group then $G \\\\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "formal_statement": "theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\\n is_cyclic G \\u2227 \\u2203 G_fin : fintype G, nat.prime (@card G G_fin)"
  },
  {
    "informal_statement": "Prove that the power series $\\\\sum zn/n^2$ converges at every point of the unit circle.",
    "formal_statement": "theorem exercise_1_19b (z : \\u2102) (hz : abs z = 1) (s : \\u2115 \\u2192 \\u2102)\\n (h : s = (\\u03bb n, \\u2211 i in (finset.range n), i * z / i ^ 2)) :\\n \\u2203 y, tendsto s at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "formal_statement": "theorem exercise_18_4 {n : \\u2115} (hn : \\u2203 x y z w : \\u2124, \\n x^3 + y^3 = n \\u2227 z^3 + w^3 = n \\u2227 x \\u2260 z \\u2227 x \\u2260 w \\u2227 y \\u2260 z \\u2227 y \\u2260 w) : \\n n \\u2265 1729"
  },
  {
    "informal_statement": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\\n (hG : card G = 1365) : \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "Define $f_{n}:[0,1] \\\\rightarrow \\\\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\\\left(f_{n}(x)\\\\right)$ converges for each $x \\\\in[0,1]$.",
    "formal_statement": "theorem exercise_21_6a\\n (f : \\u2115 \\u2192 I \\u2192 \\u211d )\\n (h : \\u2200 x n, f n x = x ^ n) :\\n \\u2200 x, \\u2203 y, tendsto (\\u03bb n, f n x) at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "formal_statement": "theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \\n (hG : card G = 200) : \\n \\u2203 N : sylow 5 G, N.normal"
  },
  {
    "informal_statement": "Prove that if $|G|=132$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\\n (hG : card G = 132) : \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "Let $R$ be the ring of $2 \\\\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "formal_statement": "theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \\u211d)) : \\n I = \\u22a5 \\u2228 I = \\u22a4"
  },
  {
    "informal_statement": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "formal_statement": "theorem exercise_30_13 {X : Type*} [topological_space X]\\n (h : \\u2203 (s : set X), countable s \\u2227 dense s) (U : set (set X))\\n (hU : \\u2200 (x y : set X), x \\u2208 U \\u2192 y \\u2208 U \\u2192 x \\u2260 y \\u2192 x \\u2229 y = \\u2205) :\\n countable U"
  },
  {
    "informal_statement": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-\\u010cech compactification of $X$ is connected.",
    "formal_statement": "theorem exercise_38_6 {X : Type*}\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0}) :\\n is_connected (univ : set X) \\u2194 is_connected (univ : set (stone_cech X))"
  },
  {
    "informal_statement": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "formal_statement": "theorem exercise_4_5 {p t : \\u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\\n (a : zmod p) :\\n is_primitive_root a p \\u2194 ((-a) ^ ((p-1)/2) = 1 \\u2227 \\u2200 (k : \\u2115), k < (p-1)/2 \\u2192 (-a)^k \\u2260 1)"
  },
  {
    "informal_statement": "Suppose that $|G| = pm$, where $p \\\\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "formal_statement": "theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\\n {p m : \\u2115} (hp : nat.prime p) (hp1 : \\u00ac p \\u2223 m) (hG : card G = p*m) \\n {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\\n characteristic H"
  },
  {
    "informal_statement": "Suppose that $|G| = pm$, where $p \\\\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "formal_statement": "theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\\n (hG : card G = 6) (hG' : is_empty (comm_group G)) :\\n G \\u2243* equiv.perm (fin 3)"
  },
  {
    "informal_statement": "Prove that $\\\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2d {p : \\u2115} (hp : p.prime \\u2227 p > 2) \\n {f : polynomial \\u2124} (hf : f = (X + 2)^p): \\n irreducible (\\u2211 n in (f.support \\\\ {0}), (f.coeff n) * X ^ (n-1) : \\n polynomial \\u2124)"
  },
  {
    "informal_statement": "Suppose $a, b \\\\in R^k$. Find $c \\\\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "formal_statement": "theorem exercise_1_19\\n (n : \\u2115)\\n (a b c x : euclidean_space \\u211d (fin n))\\n (r : \\u211d)\\n (h\\u2081 : r > 0)\\n (h\\u2082 : 3 \\u2022 c = 4 \\u2022 b - a)\\n (h\\u2083 : 3 * r = 2 * \\u2016x - b\\u2016)\\n : \\u2016x - a\\u2016 = 2 * \\u2016x - b\\u2016 \\u2194 \\u2016x - c\\u2016 = r"
  },
  {
    "informal_statement": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "formal_statement": "theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \\n (hG : card G > 2) (H : subgroup G) [fintype H] : \\n card H \\u2260 card G - 1"
  },
  {
    "informal_statement": "Prove that $-(-v) = v$ for every $v \\\\in V$.",
    "formal_statement": "theorem exercise_1_3 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {v : V} : -(-v) = v"
  },
  {
    "informal_statement": "Show that a closed subspace of a normal space is normal.",
    "formal_statement": "theorem exercise_32_2b\\n {\\u03b9 : Type*} {X : \\u03b9 \\u2192 Type*} [\\u2200 i, topological_space (X i)]\\n (h : \\u2200 i, nonempty (X i)) (h2 : regular_space (\\u03a0 i, X i)) :\\n \\u2200 i, regular_space (X i)"
  },
  {
    "informal_statement": "If $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "formal_statement": "theorem exercise_1_1a\\n (x : \\u211d) (y : \\u211a) :\\n ( irrational x ) -> irrational ( x + y )"
  },
  {
    "informal_statement": "Show that a closed subspace of a normal space is normal.",
    "formal_statement": "theorem exercise_32_1 {X : Type*} [topological_space X]\\n (hX : normal_space X) (A : set X) (hA : is_closed A) :\\n normal_space {x // x \\u2208 A}"
  },
  {
    "informal_statement": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "formal_statement": "theorem exercise_10_7_10 {R : Type*} [ring R]\\n (M : ideal R) (hM : \\u2200 (x : R), x \\u2209 M \\u2192 is_unit x) :\\n is_maximal M \\u2227 \\u2200 (N : ideal R), is_maximal N \\u2192 N = M"
  },
  {
    "informal_statement": "Let $\\\\mathbf{x}_1, \\\\mathbf{x}_2, \\\\ldots$ be a sequence of the points of the product space $\\\\prod X_\\\\alpha$. Show that this sequence converges to the point $\\\\mathbf{x}$ if and only if the sequence $\\\\pi_\\\\alpha(\\\\mathbf{x}_i)$ converges to $\\\\pi_\\\\alpha(\\\\mathbf{x})$ for each $\\\\alpha$.",
    "formal_statement": "theorem exercise_21_6a\\n (f : \\u2115 \\u2192 I \\u2192 \\u211d )\\n (h : \\u2200 x n, f n x = x ^ n) :\\n \\u2200 x, \\u2203 y, tendsto (\\u03bb n, f n x) at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13c {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, abs (f z) = c) :\\n f a = f b"
  },
  {
    "informal_statement": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "formal_statement": "theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \\u2115} \\n (hm : \\u2203 (g : G), order_of g = m) \\n (hn : \\u2203 (g : G), order_of g = n) \\n (hmn : m.coprime n) :\\n \\u2203 (g : G), order_of g = m * n"
  },
  {
    "informal_statement": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\\n (hG : card G = 132) : \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "If $C_{0}+\\\\frac{C_{1}}{2}+\\\\cdots+\\\\frac{C_{n-1}}{n}+\\\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\\\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "formal_statement": "theorem exercise_5_4 {n : \\u2115}\\n (C : \\u2115 \\u2192 \\u211d)\\n (hC : \\u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\\n \\u2203 x, x \\u2208 (set.Icc (0 : \\u211d) 1) \\u2227 \\u2211 i in finset.range (n + 1), (C i) * (x^i) = 0"
  },
  {
    "informal_statement": "Show that a connected metric space having more than one point is uncountable.",
    "formal_statement": "theorem exercise_27_4\\n {X : Type*} [metric_space X] [connected_space X] (hX : \\u2203 x y : X, x \\u2260 y) :\\n \\u00ac countable (univ : set X)"
  },
  {
    "informal_statement": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "formal_statement": "theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \\n (hG : \\u00ac (card G).prime) (hG1 : \\u2200 k \\u2223 card G, \\n \\u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \\n \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "formal_statement": "theorem exercise_31_2 {X : Type*}\\n [topological_space X] [normal_space X] {A B : set X}\\n (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\\n \\u2203 (U V : set X), is_open U \\u2227 is_open V \\u2227 A \\u2286 U \\u2227 B \\u2286 V \\u2227 closure U \\u2229 closure V = \\u2205"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $\\\\text{Re}(f)$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13a {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, (f z).re = c) :\\n f a = f b"
  },
  {
    "informal_statement": "Show that the lower limit topology $\\\\mathbb{R}_l$ and $K$-topology $\\\\mathbb{R}_K$ are not comparable.",
    "formal_statement": "theorem exercise_13_6 :\\n \\u00ac (\\u2200 U, Rl.is_open U \\u2192 K_topology.is_open U) \\u2227 \\u00ac (\\u2200 U, K_topology.is_open U \\u2192 Rl.is_open U)"
  },
  {
    "informal_statement": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\\\times Y)-(A \\\\times B)$ is connected.",
    "formal_statement": "theorem exercise_24_2 {f : (metric.sphere 0 1 : set \\u211d) \\u2192 \\u211d}\\n (hf : continuous f) : \\u2203 x, f x = f (-x)"
  },
  {
    "informal_statement": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "formal_statement": "theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\\n (h : a * b = b * a) :\\n \\u2200 x y : closure {x | x = a \\u2228 x = b}, x*y = y*x"
  },
  {
    "informal_statement": "Show that every locally compact Hausdorff space is regular.",
    "formal_statement": "theorem exercise_32_3 {X : Type*} [topological_space X]\\n (hX : locally_compact_space X) (hX' : t2_space X) :\\n regular_space X"
  },
  {
    "informal_statement": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\\\operatorname{dim} V=1$ and $T \\\\in \\\\mathcal{L}(V, V)$, then there exists $a \\\\in \\\\mathbf{F}$ such that $T v=a v$ for all $v \\\\in V$.",
    "formal_statement": "theorem exercise_3_1 {F V : Type*} \\n [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\\n (T : V \\u2192\\u2097[F] V) (hT : finrank F V = 1) :\\n \\u2203 c : F, \\u2200 v : V, T v = c \\u2022 v"
  },
  {
    "informal_statement": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\\\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "formal_statement": "theorem exercise_1_6_17 {G : Type*} [group G] (f : G \\u2192 G) \\n (hf : f = \\u03bb g, g\\u207b\\u00b9) :\\n \\u2200 x y : G, f x * f y = f (x*y) \\u2194 \\u2200 x y : G, x*y = y*x"
  },
  {
    "informal_statement": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "formal_statement": "theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {\\u03b9 : Type*} (u : \\u03b9 \\u2192 submodule F V) :\\n \\u2203 U : submodule F V, (\\u22c2 (i : \\u03b9), (u i).carrier) = \\u2191U"
  },
  {
    "informal_statement": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "formal_statement": "theorem exercise_1_13a {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, (f z).re = c) :\\n f a = f b"
  },
  {
    "informal_statement": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "formal_statement": "theorem exercise_17_4 {X : Type*} [topological_space X]\\n (U A : set X) (hU : is_open U) (hA : is_closed A) :\\n is_open (U \\\\ A) \\u2227 is_closed (A \\\\ U)"
  },
  {
    "informal_statement": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "formal_statement": "theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\\n (A : set X) (hA : is_closed A) :\\n \\u2203 P\\u2081 P\\u2082 : set X, A = P\\u2081 \\u222a P\\u2082 \\u2227\\n is_closed P\\u2081 \\u2227 P\\u2081 = {x | cluster_pt x (\\ud835\\udcdf P\\u2081)} \\u2227\\n set.countable P\\u2082"
  },
  {
    "informal_statement": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "formal_statement": "theorem exercise_4_19\\n {f : \\u211d \\u2192 \\u211d} (hf : \\u2200 a b c, a < b \\u2192 f a < c \\u2192 c < f b \\u2192 \\u2203 x, a < x \\u2227 x < b \\u2227 f x = c)\\n (hg : \\u2200 r : \\u211a, is_closed {x | f x = r}) : continuous f"
  },
  {
    "informal_statement": "Let $p$ be an odd prime and let $1 + \\\\frac{1}{2} + ... + \\\\frac{1}{p - 1} = \\\\frac{a}{b}$, where $a, b$ are integers. Show that $p \\\\mid a$.",
    "formal_statement": "theorem exercise_4_2_9 {p : \\u2115} (hp : nat.prime p) (hp1 : odd p) :\\n \\u2203 (a b : \\u2124), (a / b : \\u211a) = \\u2211 i in finset.range p, 1 / (i + 1) \\u2192 \\u2191p \\u2223 a"
  },
  {
    "informal_statement": "For $j \\\\in\\\\{1,2,3,4\\\\}$, let $z_{j}$ be a complex number with $\\\\left|z_{j}\\\\right|=1$ and $z_{j} \\\\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\\\neq 0 .$",
    "formal_statement": "theorem exercise_2020_b5 (z : fin 4 \\u2192 \\u2102) (hz0 : \\u2200 n, \\u2016z n\\u2016 < 1) \\n (hz1 : \\u2200 n : fin 4, z n \\u2260 1) : \\n 3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \\u2260 0"
  },
  {
    "informal_statement": "Prove that a group of even order contains an element of order $2 .$",
    "formal_statement": "theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\\n [module K V] {S : set V} (hS : set.countable S)\\n (hS1 : span K S = \\u22a4) {\\u03b9 : Type*} (R : \\u03b9 \\u2192 V)\\n (hR : linear_independent K R) : countable \\u03b9"
  },
  {
    "informal_statement": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\\\in G$. Show that $G$ is abelian.",
    "formal_statement": "theorem exercise_2_2_5 {G : Type*} [group G] \\n (h : \\u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \\u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\\n comm_group G"
  },
  {
    "informal_statement": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\\\mathbb{Q}[x]$.",
    "formal_statement": "theorem exercise_13_4_10 \\n {p : \\u2115} {hp : nat.prime p} (h : \\u2203 r : \\u2115, p = 2 ^ r + 1) :\\n \\u2203 (k : \\u2115), p = 2 ^ (2 ^ k) + 1"
  },
  {
    "informal_statement": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "formal_statement": "theorem exercise_13_4_10 \\n {p : \\u2115} {hp : nat.prime p} (h : \\u2203 r : \\u2115, p = 2 ^ r + 1) :\\n \\u2203 (k : \\u2115), p = 2 ^ (2 ^ k) + 1"
  },
  {
    "informal_statement": "Give an example of a nonempty subset $U$ of $\\\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\\\in U$ whenever $u \\\\in U$), but $U$ is not a subspace of $\\\\mathbf{R}^2$.",
    "formal_statement": "theorem exercise_1_6 : \\u2203 U : set (\\u211d \\u00d7 \\u211d),\\n (U \\u2260 \\u2205) \\u2227\\n (\\u2200 (u v : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2227 v \\u2208 U \\u2192 u + v \\u2208 U) \\u2227\\n (\\u2200 (u : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2192 -u \\u2208 U) \\u2227\\n (\\u2200 U' : submodule \\u211d (\\u211d \\u00d7 \\u211d), U \\u2260 \\u2191U')"
  },
  {
    "informal_statement": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "formal_statement": "theorem exercise_5_2_20 {F V \\u03b9: Type*} [infinite F] [field F] \\n [add_comm_group V] [module F V] {u : \\u03b9 \\u2192 submodule F V} \\n (hu : \\u2200 i : \\u03b9, u i \\u2260 \\u22a4) : \\n (\\u22c3 i : \\u03b9, (u i : set V)) \\u2260 \\u22a4"
  },
  {
    "informal_statement": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "formal_statement": "theorem exercise_2_24 {X : Type*} [metric_space X]\\n (hX : \\u2200 (A : set X), infinite A \\u2192 \\u2203 (x : X), x \\u2208 closure A) :\\n separable_space X"
  },
  {
    "informal_statement": "Prove that $\\\\sqrt{n+1}-\\\\sqrt{n} \\\\rightarrow 0$ as $n \\\\rightarrow \\\\infty$.",
    "formal_statement": "theorem exercise_3_4 (n : \\u2115) :\\n tendsto (\\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\\ud835\\udcdd 0)"
  },
  {
    "informal_statement": "Let $\\\\|\\\\cdot\\\\|$ be any norm on $\\\\mathbb{R}^{m}$ and let $B=\\\\left\\\\{x \\\\in \\\\mathbb{R}^{m}:\\\\|x\\\\| \\\\leq 1\\\\right\\\\}$. Prove that $B$ is compact.",
    "formal_statement": "theorem exercise_2_41 (m : \\u2115) {X : Type*} [normed_space \\u211d ((fin m) \\u2192 \\u211d)] :\\n is_compact (metric.closed_ball 0 1)"
  },
  {
    "informal_statement": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "formal_statement": "theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \\u2115}\\n (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\\n is_simple_group G \\u2192 false"
  },
  {
    "informal_statement": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\\\left(\\\\frac{x+y}{2}\\\\right) \\\\leq \\\\frac{f(x)+f(y)}{2}$ for all $x, y \\\\in(a, b)$. Prove that $f$ is convex.",
    "formal_statement": "theorem exercise_4_24 {f : \\u211d \\u2192 \\u211d}\\n (hf : continuous f) (a b : \\u211d) (hab : a < b)\\n (h : \\u2200 x y : \\u211d, a < x \\u2192 x < b \\u2192 a < y \\u2192 y < b \\u2192 f ((x + y) / 2) \\u2264 (f x + f y) / 2) :\\n convex_on \\u211d (set.Ioo a b) f"
  },
  {
    "informal_statement": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "formal_statement": "theorem exercise_31_2 {X : Type*}\\n [topological_space X] [normal_space X] {A B : set X}\\n (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\\n \\u2203 (U V : set X), is_open U \\u2227 is_open V \\u2227 A \\u2286 U \\u2227 B \\u2286 V \\u2227 closure U \\u2229 closure V = \\u2205"
  },
  {
    "informal_statement": "Prove that in the ring $\\\\mathbb{Z}[x],(2) \\\\cap(x)=(2 x)$.",
    "formal_statement": "theorem exercise_10_2_4 :\\n span ({2} : set $ polynomial \\u2124) \\u2293 (span {X}) =\\n span ({2 * X} : set $ polynomial \\u2124)"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $\\\\text{Re}(f)$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13c {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, abs (f z) = c) :\\n f a = f b"
  },
  {
    "informal_statement": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\\\sigma \\\\in G$ such that $\\\\sigma(a) \\\\neq a$ for all $a \\\\in A$.",
    "formal_statement": "theorem exercise_4_3_26 {\\u03b1 : Type*} [fintype \\u03b1] (ha : fintype.card \\u03b1 > 1)\\n (h_tran : \\u2200 a b: \\u03b1, \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u03c3 a = b) : \\n \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u2200 a : \\u03b1, \\u03c3 a \\u2260 a"
  },
  {
    "informal_statement": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "formal_statement": "theorem exercise_1_1_16 {G : Type*} [group G] \\n (x : G) (hx : x ^ 2 = 1) :\\n order_of x = 1 \\u2228 order_of x = 2"
  },
  {
    "informal_statement": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "formal_statement": "theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\\n (H : I \\u2192 subgroup G) (hH : \\u2200 i : I, subgroup.normal (H i)) : \\n subgroup.normal (\\u2a05 (i : I), H i)"
  },
  {
    "informal_statement": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\\\cap J$ in $R / I J$ is nilpotent.",
    "formal_statement": "theorem exercise_10_4_6 {R : Type*} [comm_ring R] \\n [no_zero_divisors R] {I J : ideal R} (x : I \\u2293 J) : \\n is_nilpotent ((ideal.quotient.mk (I*J)) x)"
  },
  {
    "informal_statement": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\\\geq 1$. Prove that the ideal $p \\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$ is a nilpotent ideal in the ring $\\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$.",
    "formal_statement": "theorem exercise_8_1_12 {N : \\u2115} (hN : N > 0) {M M': \\u2124} {d : \\u2115}\\n (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \\n (hM' : M' \\u2261 M^d [ZMOD N]) : \\n \\u2203 d' : \\u2115, d' * d \\u2261 1 [ZMOD N.totient] \\u2227 \\n M \\u2261 M'^d' [ZMOD N]"
  },
  {
    "informal_statement": "If $a > 1$ is an integer, show that $n \\\\mid \\\\varphi(a^n - 1)$, where $\\\\phi$ is the Euler $\\\\varphi$-function.",
    "formal_statement": "theorem exercise_2_4_36 {a n : \\u2115} (h : a > 1) :\\n n \\u2223 (a ^ n - 1).totient"
  },
  {
    "informal_statement": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "formal_statement": "theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \\n [group G] [group H] (hG : card G = 21) (hH : card H = 21) \\n (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\\n G \\u2243* H"
  },
  {
    "informal_statement": "Prove that $\\\\sum 1/k(\\\\log(k))^p$ diverges when $p \\\\leq 1$.",
    "formal_statement": "theorem exercise_3_63b (p : \\u211d) (f : \\u2115 \\u2192 \\u211d) (hp : p \\u2264 1)\\n (h : f = \\u03bb k, (1 : \\u211d) / (k * (log k) ^ p)) :\\n \\u00ac \\u2203 l, tendsto f at_top (\\ud835\\udcdd l)"
  },
  {
    "informal_statement": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\\\in R$. Prove that every Boolean ring is commutative.",
    "formal_statement": "theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \\u2200 a : R, a^2 = a) :\\n comm_ring R"
  },
  {
    "informal_statement": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\\\perp}=\\\\{0\\\\}$ if and only if $U=V$",
    "formal_statement": "theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\\n {U : submodule K V} : \\n U.orthogonal = \\u22a5 \\u2194 U = \\u22a4"
  },
  {
    "informal_statement": "Let $(p_n)$ be a sequence and $f:\\\\mathbb{N}\\\\to\\\\mathbb{N}$. The sequence $(q_k)_{k\\\\in\\\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.",
    "formal_statement": "theorem exercise_2_12a (f : \\u2115 \\u2192 \\u2115) (p : \\u2115 \\u2192 \\u211d) (a : \\u211d)\\n (hf : injective f) (hp : tendsto p at_top (\\ud835\\udcdd a)) :\\n tendsto (\\u03bb n, p (f n)) at_top (\\ud835\\udcdd a)"
  },
  {
    "informal_statement": "Let $p$ be an odd prime and let $1 + \\\\frac{1}{2} + ... + \\\\frac{1}{p - 1} = \\\\frac{a}{b}$, where $a, b$ are integers. Show that $p \\\\mid a$.",
    "formal_statement": "theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \\u211d)) : \\n I = \\u22a5 \\u2228 I = \\u22a4"
  },
  {
    "informal_statement": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_5_2_20 {F V \\u03b9: Type*} [infinite F] [field F] \\n [add_comm_group V] [module F V] {u : \\u03b9 \\u2192 submodule F V} \\n (hu : \\u2200 i : \\u03b9, u i \\u2260 \\u22a4) : \\n (\\u22c3 i : \\u03b9, (u i : set V)) \\u2260 \\u22a4"
  },
  {
    "informal_statement": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "formal_statement": "theorem exercise_3_1a\\n (f : \\u2115 \\u2192 \\u211d)\\n (h : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), f n) at_top (\\ud835\\udcdd a))\\n : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), |f n|) at_top (\\ud835\\udcdd a)"
  },
  {
    "informal_statement": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\\\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "formal_statement": "theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \\n [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\\n is_cyclic (G \\u00d7 H) \\u2194 (card G).coprime (card H)"
  },
  {
    "informal_statement": "Show that if $a$ is negative then $p \\\\equiv q(4 a) together with p\\\\not | a$ imply $(a / p)=(a / q)$.",
    "formal_statement": "theorem exercise_5_37 {p q : \\u2115} [fact(p.prime)] [fact(q.prime)] {a : \\u2124}\\n (ha : a < 0) (h0 : p \\u2261 q [ZMOD 4*a]) (h1 : \\u00ac ((p : \\u2124) \\u2223 a)) :\\n legendre_sym p a = legendre_sym q a"
  },
  {
    "informal_statement": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "formal_statement": "theorem exercise_4_8 {p a : \\u2115} (hp : odd p) : \\n is_primitive_root a p \\u2194 (\\u2200 q \\u2223 (p-1), q.prime \\u2192 \\u00ac a^(p-1) \\u2261 1 [MOD p])"
  },
  {
    "informal_statement": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\\\colon X \\\\rightarrow [0, 1]$ such that $f(A) = \\\\{0\\\\}$ and $f(B) = \\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_38_6 {X : Type*}\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0}) :\\n is_connected (univ : set X) \\u2194 is_connected (univ : set (stone_cech X))"
  },
  {
    "informal_statement": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "formal_statement": "theorem exercise_2_12a (f : \\u2115 \\u2192 \\u2115) (p : \\u2115 \\u2192 \\u211d) (a : \\u211d)\\n (hf : injective f) (hp : tendsto p at_top (\\ud835\\udcdd a)) :\\n tendsto (\\u03bb n, p (f n)) at_top (\\ud835\\udcdd a)"
  },
  {
    "informal_statement": "Show that $ \\\\int_{-\\\\infty}^{\\\\infty} \\\\frac{\\\\cos x}{x^2 + a^2} dx = \\\\pi \\\\frac{e^{-a}}{a}$ for $a > 0$.",
    "formal_statement": "theorem exercise_3_3 (a : \\u211d) (ha : 0 < a) :\\n tendsto (\\u03bb y, \\u222b x in -y..y, real.cos x / (x ^ 2 + a ^ 2))\\n at_top (\\ud835\\udcdd (real.pi * (real.exp (-a) / a)))"
  },
  {
    "informal_statement": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "formal_statement": "theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \\n [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\\n is_cyclic (G \\u00d7 H) \\u2194 (card G).coprime (card H)"
  },
  {
    "informal_statement": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "formal_statement": "theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \\u2115}\\n (hp : nat.prime p) (hG : card G = p^2) :\\n \\u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \\u2227 N.normal"
  },
  {
    "informal_statement": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "formal_statement": "theorem exercise_23_9 {X Y : Type*}\\n [topological_space X] [topological_space Y]\\n (A\\u2081 A\\u2082 : set X)\\n (B\\u2081 B\\u2082 : set Y)\\n (hA : A\\u2081 \\u2282 A\\u2082)\\n (hB : B\\u2081 \\u2282 B\\u2082)\\n (hA : is_connected A\\u2082)\\n (hB : is_connected B\\u2082) :\\n is_connected ({x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2082 \\u2227 b \\u2208 B\\u2082} \\\\\\n {x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2081 \\u2227 b \\u2208 B\\u2081})"
  },
  {
    "informal_statement": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "formal_statement": "theorem exercise_2_4_16b {n : \\u2115} {hn : n \\u2260 0} \\n {R : subgroup (dihedral_group n)} \\n (hR : R = subgroup.closure {dihedral_group.r 1}) : \\n R \\u2260 \\u22a4 \\u2227 \\n \\u2200 K : subgroup (dihedral_group n), R \\u2264 K \\u2192 K = R \\u2228 K = \\u22a4"
  },
  {
    "informal_statement": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "formal_statement": "theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\\n (hG : card G = 1365) : \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_19b (z : \\u2102) (hz : abs z = 1) (s : \\u2115 \\u2192 \\u2102)\\n (h : s = (\\u03bb n, \\u2211 i in (finset.range n), i * z / i ^ 2)) :\\n \\u2203 y, tendsto s at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Suppose $V$ is a complex inner-product space and $T \\\\in \\\\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "formal_statement": "theorem exercise_7_14 {\\ud835\\udd5c V : Type*} [is_R_or_C \\ud835\\udd5c]\\n [inner_product_space \\ud835\\udd5c V] [finite_dimensional \\ud835\\udd5c V]\\n {T : End \\ud835\\udd5c V} (hT : is_self_adjoint T)\\n {l : \\ud835\\udd5c} {\\u03b5 : \\u211d} (he : \\u03b5 > 0) : \\u2203 v : V, \\u2016v\\u2016= 1 \\u2227 (\\u2016T v - l \\u2022 v\\u2016 < \\u03b5 \\u2192\\n (\\u2203 l' : T.eigenvalues, \\u2016l - l'\\u2016 < \\u03b5))"
  },
  {
    "informal_statement": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "formal_statement": "theorem exercise_4_5_16 {p q r : \\u2115} {G : Type*} [group G] \\n [fintype G] (hpqr : p < q \\u2227 q < r) \\n (hpqr1 : p.prime \\u2227 q.prime \\u2227 r.prime)(hG : card G = p*q*r) : \\n nonempty (sylow p G) \\u2228 nonempty(sylow q G) \\u2228 nonempty(sylow r G)"
  },
  {
    "informal_statement": "If $a > 1$ is an integer, show that $n \\\\mid \\\\varphi(a^n - 1)$, where $\\\\phi$ is the Euler $\\\\varphi$-function.",
    "formal_statement": "theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\\n {p m : \\u2115} (hp : nat.prime p) (hp1 : \\u00ac p \\u2223 m) (hG : card G = p*m) \\n {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\\n characteristic H"
  },
  {
    "informal_statement": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\\\rightarrow Y$ be continuous. Let $h: X \\\\rightarrow Y$ be the function $h(x)=\\\\min \\\\{f(x), g(x)\\\\}.$ Show that $h$ is continuous.",
    "formal_statement": "theorem exercise_19_6a\\n {n : \\u2115}\\n {f : fin n \\u2192 Type*} {x : \\u2115 \\u2192 \\u03a0a, f a}\\n (y : \\u03a0i, f i)\\n [\\u03a0a, topological_space (f a)] :\\n tendsto x at_top (\\ud835\\udcdd y) \\u2194 \\u2200 i, tendsto (\\u03bb j, (x j) i) at_top (\\ud835\\udcdd (y i))"
  },
  {
    "informal_statement": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "formal_statement": "theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \\n (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \\n comm_group G"
  },
  {
    "informal_statement": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "formal_statement": "theorem exercise_9_3_2 {f g : polynomial \\u211a} (i j : \\u2115)\\n (hfg : \\u2200 n : \\u2115, \\u2203 a : \\u2124, (f*g).coeff = a) :\\n \\u2203 a : \\u2124, f.coeff i * g.coeff j = a"
  },
  {
    "informal_statement": "Suppose $f^{\\\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\\\prime}(f(x))=\\\\frac{1}{f^{\\\\prime}(x)} \\\\quad(a<x<b)$.",
    "formal_statement": "theorem exercise_5_2 {a b : \\u211d}\\n {f g : \\u211d \\u2192 \\u211d} (hf : \\u2200 x \\u2208 set.Ioo a b, deriv f x > 0)\\n (hg : g = f\\u207b\\u00b9)\\n (hg_diff : differentiable_on \\u211d g (set.Ioo a b)) :\\n differentiable_on \\u211d g (set.Ioo a b) \\u2227\\n \\u2200 x \\u2208 set.Ioo a b, deriv g x = 1 / deriv f x"
  },
  {
    "informal_statement": "Suppose $X$ is a nonempty complete metric space, and $\\\\left\\\\{G_{n}\\\\right\\\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\\\bigcap_{1}^{\\\\infty} G_{n}$ is not empty.",
    "formal_statement": "theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\\n (G : \\u2115 \\u2192 set X) (hG : \\u2200 n, is_open (G n) \\u2227 dense (G n)) :\\n \\u2203 x, \\u2200 n, x \\u2208 G n"
  },
  {
    "informal_statement": "Suppose $f^{\\\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\\\prime}(f(x))=\\\\frac{1}{f^{\\\\prime}(x)} \\\\quad(a<x<b)$.",
    "formal_statement": "theorem exercise_5_4 {n : \\u2115}\\n (C : \\u2115 \\u2192 \\u211d)\\n (hC : \\u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\\n \\u2203 x, x \\u2208 (set.Icc (0 : \\u211d) 1) \\u2227 \\u2211 i in finset.range (n + 1), (C i) * (x^i) = 0"
  },
  {
    "informal_statement": "Prove that convergence of $\\\\left\\\\{s_{n}\\\\right\\\\}$ implies convergence of $\\\\left\\\\{\\\\left|s_{n}\\\\right|\\\\right\\\\}$.",
    "formal_statement": "theorem exercise_3_1a\\n (f : \\u2115 \\u2192 \\u211d)\\n (h : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), f n) at_top (\\ud835\\udcdd a))\\n : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), |f n|) at_top (\\ud835\\udcdd a)"
  },
  {
    "informal_statement": "Prove that $\\\\sqrt{n+1}-\\\\sqrt{n} \\\\rightarrow 0$ as $n \\\\rightarrow \\\\infty$.",
    "formal_statement": "theorem exercise_3_63b (p : \\u211d) (f : \\u2115 \\u2192 \\u211d) (hp : p \\u2264 1)\\n (h : f = \\u03bb k, (1 : \\u211d) / (k * (log k) ^ p)) :\\n \\u00ac \\u2203 l, tendsto f at_top (\\ud835\\udcdd l)"
  },
  {
    "informal_statement": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\\\sigma \\\\in G$ such that $\\\\sigma(a) \\\\neq a$ for all $a \\\\in A$.",
    "formal_statement": "theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \\n (hG : \\u00ac (card G).prime) (hG1 : \\u2200 k \\u2223 card G, \\n \\u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \\n \\u00ac is_simple_group G"
  },
  {
    "informal_statement": "Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "formal_statement": "theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\\n (A : set X) (hA : is_closed A) :\\n \\u2203 P\\u2081 P\\u2082 : set X, A = P\\u2081 \\u222a P\\u2082 \\u2227\\n is_closed P\\u2081 \\u2227 P\\u2081 = {x | cluster_pt x (\\ud835\\udcdf P\\u2081)} \\u2227\\n set.countable P\\u2082"
  },
  {
    "informal_statement": "If $z$ is a complex number, prove that there exists an $r\\\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "formal_statement": "theorem exercise_1_13 (x y : \\u2102) : \\n |(abs x) - (abs y)| \\u2264 abs (x - y)"
  },
  {
    "informal_statement": "Show that if $\\\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\\\mathcal{A}$.",
    "formal_statement": "theorem exercise_13_6 :\\n \\u00ac (\\u2200 U, Rl.is_open U \\u2192 K_topology.is_open U) \\u2227 \\u00ac (\\u2200 U, K_topology.is_open U \\u2192 Rl.is_open U)"
  },
  {
    "informal_statement": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "formal_statement": "theorem exercise_5_37 {p q : \\u2115} [fact(p.prime)] [fact(q.prime)] {a : \\u2124}\\n (ha : a < 0) (h0 : p \\u2261 q [ZMOD 4*a]) (h1 : \\u00ac ((p : \\u2124) \\u2223 a)) :\\n legendre_sym p a = legendre_sym q a"
  },
  {
    "informal_statement": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "formal_statement": "theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\\n (hx : order_of x = 2) (hx1 : \\u2200 y, order_of y = 2 \\u2192 y = x) :\\n x \\u2208 center G"
  },
  {
    "informal_statement": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\\\in A$ there is an open set $U$ containing $x$ such that $U \\\\subset A$. Show that $A$ is open in $X$.",
    "formal_statement": "theorem exercise_13_1 (X : Type*) [topological_space X] (A : set X)\\n (h1 : \\u2200 x \\u2208 A, \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 U \\u2286 A) :\\n is_open A"
  },
  {
    "informal_statement": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "formal_statement": "theorem exercise_6_1_14 (G : Type*) [group G]\\n (hG : is_cyclic $ G \\u29f8 (center G)) :\\n center G = \\u22a4"
  },
  {
    "informal_statement": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "formal_statement": "theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \\u2115} \\n (hm : \\u2203 (g : G), order_of g = m) \\n (hn : \\u2203 (g : G), order_of g = n) \\n (hmn : m.coprime n) :\\n \\u2203 (g : G), order_of g = m * n"
  },
  {
    "informal_statement": "If $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "formal_statement": "theorem exercise_1_2 : \\u00ac \\u2203 (x : \\u211a), ( x ^ 2 = 12 )"
  },
  {
    "informal_statement": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\\\in A$ there is an open set $U$ containing $x$ such that $U \\\\subset A$. Show that $A$ is open in $X$.",
    "formal_statement": "theorem exercise_13_4a1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n is_topology X (\\u22c2 i : I, T i)"
  },
  {
    "informal_statement": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "formal_statement": "theorem exercise_10_2_4 :\\n span ({2} : set $ polynomial \\u2124) \\u2293 (span {X}) =\\n span ({2 * X} : set $ polynomial \\u2124)"
  },
  {
    "informal_statement": "Show that if $\\\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\\\mathcal{A}$.",
    "formal_statement": "theorem exercise_13_5a {X : Type*}\\n [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\\n generate_from A = generate_from (sInter {T | is_topology X T \\u2227 A \\u2286 T})"
  },
  {
    "informal_statement": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\\\mathbb{Q}[x]$.",
    "formal_statement": "theorem exercise_11_4_8 {p : \\u2115} (hp : prime p) (n : \\u2115) :\\n irreducible (X ^ n - p : polynomial \\u211a)"
  },
  {
    "informal_statement": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\\\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_5_25 {p : \\u2115} (hp : nat.prime p) :\\n irreducible (\\u2211 i : finset.range p, X ^ p : polynomial \\u211a)"
  },
  {
    "informal_statement": "For $j \\\\in\\\\{1,2,3,4\\\\}$, let $z_{j}$ be a complex number with $\\\\left|z_{j}\\\\right|=1$ and $z_{j} \\\\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\\\neq 0 .$",
    "formal_statement": "theorem exercise_2018_b2 (n : \\u2115) (hn : n > 0) (f : \\u2115 \\u2192 \\u2102 \\u2192 \\u2102) \\n (hf : \\u2200 n : \\u2115, f n = \\u03bb z, (\\u2211 (i : fin n), (n-i)* z^(i : \\u2115))) : \\n \\u00ac (\\u2203 z : \\u2102, \\u2016z\\u2016 \\u2264 1 \\u2227 f n z = 0)"
  },
  {
    "informal_statement": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "formal_statement": "theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\\n (hG : card G = 312) :\\n \\u2203 (p : \\u2115) (P : sylow p G), P.normal"
  },
  {
    "informal_statement": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\\\equiv 1(p q)$.",
    "formal_statement": "theorem exercise_4_5 {p t : \\u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\\n (a : zmod p) :\\n is_primitive_root a p \\u2194 ((-a) ^ ((p-1)/2) = 1 \\u2227 \\u2200 (k : \\u2115), k < (p-1)/2 \\u2192 (-a)^k \\u2260 1)"
  },
  {
    "informal_statement": "If $\\\\Sigma a_{n}$ converges, and if $\\\\left\\\\{b_{n}\\\\right\\\\}$ is monotonic and bounded, prove that $\\\\Sigma a_{n} b_{n}$ converges.",
    "formal_statement": "theorem exercise_3_8\\n (a b : \\u2115 \\u2192 \\u211d)\\n (h1 : \\u2203 y, (tendsto (\\u03bb n, (\\u2211 i in (finset.range n), a i)) at_top (\\ud835\\udcdd y)))\\n (h2 : monotone b)\\n (h3 : metric.bounded (set.range b)) :\\n \\u2203 y, tendsto (\\u03bb n, (\\u2211 i in (finset.range n), (a i) * (b i))) at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Let $\\\\mathbf{x}_1, \\\\mathbf{x}_2, \\\\ldots$ be a sequence of the points of the product space $\\\\prod X_\\\\alpha$. Show that this sequence converges to the point $\\\\mathbf{x}$ if and only if the sequence $\\\\pi_\\\\alpha(\\\\mathbf{x}_i)$ converges to $\\\\pi_\\\\alpha(\\\\mathbf{x})$ for each $\\\\alpha$.",
    "formal_statement": "theorem exercise_19_6a\\n {n : \\u2115}\\n {f : fin n \\u2192 Type*} {x : \\u2115 \\u2192 \\u03a0a, f a}\\n (y : \\u03a0i, f i)\\n [\\u03a0a, topological_space (f a)] :\\n tendsto x at_top (\\ud835\\udcdd y) \\u2194 \\u2200 i, tendsto (\\u03bb j, (x j) i) at_top (\\ud835\\udcdd (y i))"
  },
  {
    "informal_statement": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\\\unlhd G$ and $A$ abelian.",
    "formal_statement": "theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \\n {H : subgroup G} (hH : H \\u2260 \\u22a5) [H.normal] : \\n \\u2203 A \\u2264 H, A.normal \\u2227 \\u2200 a b : A, a*b = b*a"
  },
  {
    "informal_statement": "If $\\\\mathcal{T}_\\\\alpha$ is a family of topologies on $X$, show that $\\\\bigcap \\\\mathcal{T}_\\\\alpha$ is a topology on $X$.",
    "formal_statement": "theorem exercise_13_4a1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n is_topology X (\\u22c2 i : I, T i)"
  },
  {
    "informal_statement": "Show that every locally compact Hausdorff space is regular.",
    "formal_statement": "theorem exercise_33_8\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0})\\n (A B : set X) (hA : is_closed A) (hB : is_closed B)\\n (hAB : disjoint A B)\\n (hAc : is_compact A) :\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f '' A = {0} \\u2227 f '' B = {1}"
  },
  {
    "informal_statement": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "formal_statement": "theorem exercise_2_11_22 {p : \\u2115} {n : \\u2115} {G : Type*} [fintype G] \\n [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\\n [fintype K] (hK : card K = p ^ (n-1)) : \\n K.normal"
  },
  {
    "informal_statement": "If $x, y$ are complex, prove that $||x|-|y|| \\\\leq |x-y|$.",
    "formal_statement": "theorem exercise_1_13 (x y : \\u2102) : \\n |(abs x) - (abs y)| \\u2264 abs (x - y)"
  },
  {
    "informal_statement": "Prove that for all $n>1$ that $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is not a group under multiplication of residue classes.",
    "formal_statement": "theorem exercise_1_1_5 (n : \\u2115) (hn : 1 < n) : \\n is_empty (group (zmod n))"
  },
  {
    "informal_statement": "Suppose $u, v \\\\in V$. Prove that $\\\\langle u, v\\\\rangle=0$ if and only if $\\\\|u\\\\| \\\\leq\\\\|u+a v\\\\|$ for all $a \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \\u2102 V]\\n [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = 0 \\u2194 \\u2200 (a : \\u2102), \\u2016u\\u2016 \\u2264 \\u2016u + a \\u2022 v\\u2016"
  },
  {
    "informal_statement": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\\\times Y)-(A \\\\times B)$ is connected.",
    "formal_statement": "theorem exercise_23_9 {X Y : Type*}\\n [topological_space X] [topological_space Y]\\n (A\\u2081 A\\u2082 : set X)\\n (B\\u2081 B\\u2082 : set Y)\\n (hA : A\\u2081 \\u2282 A\\u2082)\\n (hB : B\\u2081 \\u2282 B\\u2082)\\n (hA : is_connected A\\u2082)\\n (hB : is_connected B\\u2082) :\\n is_connected ({x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2082 \\u2227 b \\u2208 B\\u2082} \\\\\\n {x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2081 \\u2227 b \\u2208 B\\u2081})"
  },
  {
    "informal_statement": "Prove that the quotient ring $\\\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "formal_statement": "theorem exercise_9_1_6 : \\u00ac is_principal \\n (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \\u211a)))"
  },
  {
    "informal_statement": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "formal_statement": "theorem exercise_4_5_1a {p : \\u2115} {G : Type*} [group G] \\n {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \\n (hH : P \\u2264 H) : is_p_group p H"
  },
  {
    "informal_statement": "If $f$ is a real continuous function defined on a closed set $E \\\\subset \\\\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\\\in E$.",
    "formal_statement": "theorem exercise_4_5a\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (h\\u2081 : is_closed E)\\n (h\\u2082 : continuous_on f E)\\n : \\u2203 (g : \\u211d \\u2192 \\u211d), continuous g \\u2227 \\u2200 x \\u2208 E, f x = g x"
  },
  {
    "informal_statement": "If $\\\\mathcal{T}_\\\\alpha$ is a family of topologies on $X$, show that $\\\\bigcap \\\\mathcal{T}_\\\\alpha$ is a topology on $X$.",
    "formal_statement": "theorem exercise_13_4b1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n \\u2203! T', is_topology X T' \\u2227 (\\u2200 i, T i \\u2286 T') \\u2227\\n \\u2200 T'', is_topology X T'' \\u2192 (\\u2200 i, T i \\u2286 T'') \\u2192 T'' \\u2286 T'"
  },
  {
    "informal_statement": "Give an example of a nonempty subset $U$ of $\\\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\\\in U$ whenever $u \\\\in U$), but $U$ is not a subspace of $\\\\mathbf{R}^2$.",
    "formal_statement": "theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {\\u03b9 : Type*} (u : \\u03b9 \\u2192 submodule F V) :\\n \\u2203 U : submodule F V, (\\u22c2 (i : \\u03b9), (u i).carrier) = \\u2191U"
  },
  {
    "informal_statement": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "formal_statement": "theorem exercise_3_14 {p q n : \\u2115} (hp0 : p.prime \\u2227 p > 2) \\n (hq0 : q.prime \\u2227 q > 2) (hpq0 : p \\u2260 q) (hpq1 : p - 1 \\u2223 q - 1)\\n (hn : n.gcd (p*q) = 1) : \\n n^(q-1) \\u2261 1 [MOD p*q]"
  },
  {
    "informal_statement": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\\\not \\\\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "formal_statement": "theorem exercise_5_13 {p x: \\u2124} (hp : prime p) \\n (hpx : p \\u2223 (x^4 - x^2 + 1)) : p \\u2261 1 [ZMOD 12]"
  },
  {
    "informal_statement": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "formal_statement": "theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \\n subgroup.closure ((H : set G) \\\\ {1}) = \\u22a4"
  },
  {
    "informal_statement": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\\\perp}=\\\\{0\\\\}$ if and only if $U=V$",
    "formal_statement": "theorem exercise_7_6 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) :\\n T.range = T.adjoint.range"
  },
  {
    "informal_statement": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "formal_statement": "theorem exercise_4_24 {f : \\u211d \\u2192 \\u211d}\\n (hf : continuous f) (a b : \\u211d) (hab : a < b)\\n (h : \\u2200 x y : \\u211d, a < x \\u2192 x < b \\u2192 a < y \\u2192 y < b \\u2192 f ((x + y) / 2) \\u2264 (f x + f y) / 2) :\\n convex_on \\u211d (set.Ioo a b) f"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "formal_statement": "theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {S : End F V}\\n (hS : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c) :\\n \\u2203 c : F, S = c \\u2022 id"
  },
  {
    "informal_statement": "Suppose that $E$ is an uncountable subset of $\\\\mathbb{R}$. Prove that there exists a point $p \\\\in \\\\mathbb{R}$ at which $E$ condenses.",
    "formal_statement": "theorem exercise_3_4 (n : \\u2115) :\\n tendsto (\\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\\ud835\\udcdd 0)"
  },
  {
    "informal_statement": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "formal_statement": "theorem exercise_8_3_4 {R : Type*} {n : \\u2124} {r s : \\u211a} \\n (h : r^2 + s^2 = n) : \\n \\u2203 a b : \\u2124, a^2 + b^2 = n"
  },
  {
    "informal_statement": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "formal_statement": "theorem exercise_2_126 {E : set \\u211d}\\n (hE : \\u00ac set.countable E) : \\u2203 (p : \\u211d), cluster_pt p (\\ud835\\udcdf E)"
  },
  {
    "informal_statement": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "formal_statement": "theorem exercise_5_13 {p x: \\u2124} (hp : prime p) \\n (hpx : p \\u2223 (x^4 - x^2 + 1)) : p \\u2261 1 [ZMOD 12]"
  },
  {
    "informal_statement": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "formal_statement": "theorem exercise_4_1_19 : infinite {x : quaternion \\u211d | x^2 = -1}"
  },
  {
    "informal_statement": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "formal_statement": "theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \\n (hG : card G = 200) : \\n \\u2203 N : sylow 5 G, N.normal"
  },
  {
    "informal_statement": "Suppose $p \\\\in \\\\mathcal{P}(\\\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\\\prime}$ have no roots in common.",
    "formal_statement": "theorem exercise_4_4 (p : polynomial \\u2102) :\\n p.degree = @card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102) \\u2194\\n disjoint\\n (@card (root_set p.derivative \\u2102) (polynomial.root_set_fintype p.derivative \\u2102))\\n (@card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102))"
  },
  {
    "informal_statement": "Suppose $f$ is continuous in a region $\\\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "formal_statement": "theorem exercise_1_26\\n (f F\\u2081 F\\u2082 : \\u2102 \\u2192 \\u2102) (\\u03a9 : set \\u2102) (h1 : is_open \\u03a9) (h2 : is_connected \\u03a9)\\n (hF\\u2081 : differentiable_on \\u2102 F\\u2081 \\u03a9) (hF\\u2082 : differentiable_on \\u2102 F\\u2082 \\u03a9)\\n (hdF\\u2081 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2081 x = f x) (hdF\\u2082 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2082 x = f x)\\n : \\u2203 c : \\u2102, \\u2200 x, F\\u2081 x = F\\u2082 x + c"
  },
  {
    "informal_statement": "Prove that subgroups of a solvable group are solvable.",
    "formal_statement": "theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \\n {H : subgroup G} (hH : H \\u2260 \\u22a5) [H.normal] : \\n \\u2203 A \\u2264 H, A.normal \\u2227 \\u2200 a b : A, a*b = b*a"
  },
  {
    "informal_statement": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\\\in R$. Prove that every Boolean ring is commutative.",
    "formal_statement": "theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \\n \\u2211 g : G, monoid_algebra.of R G g \\u2208 center (monoid_algebra R G)"
  },
  {
    "informal_statement": "Let $f: S^{1} \\\\rightarrow \\\\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "formal_statement": "theorem exercise_24_2 {f : (metric.sphere 0 1 : set \\u211d) \\u2192 \\u211d}\\n (hf : continuous f) : \\u2203 x, f x = f (-x)"
  },
  {
    "informal_statement": "Prove that if $G$ is an abelian simple group then $G \\\\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "formal_statement": "theorem exercise_3_4_5a {G : Type*} [group G] \\n (H : subgroup G) [is_solvable G] : is_solvable H"
  },
  {
    "informal_statement": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "formal_statement": "theorem exercise_26_11\\n {X : Type*} [topological_space X] [compact_space X] [t2_space X]\\n (A : set (set X)) (hA : \\u2200 (a b : set X), a \\u2208 A \\u2192 b \\u2208 A \\u2192 a \\u2286 b \\u2228 b \\u2286 a)\\n (hA' : \\u2200 a \\u2208 A, is_closed a) (hA'' : \\u2200 a \\u2208 A, is_connected a) :\\n is_connected (\\u22c2\\u2080 A)"
  },
  {
    "informal_statement": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "formal_statement": "theorem exercise_2_57 {X : Type*} [topological_space X]\\n : \\u2203 (S : set X), is_connected S \\u2227 \\u00ac is_connected (interior S)"
  },
  {
    "informal_statement": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "formal_statement": "theorem exercise_2010_a4 (n : \\u2115) : \\n \\u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1)"
  },
  {
    "informal_statement": "Show that a group of order 5 must be abelian.",
    "formal_statement": "theorem exercise_2_1_27 {G : Type*} [group G] \\n [fintype G] : \\u2203 (m : \\u2115), \\u2200 (a : G), a ^ m = 1"
  },
  {
    "informal_statement": "Show that if $a$ is negative then $p \\\\equiv q(4 a) together with p\\\\not | a$ imply $(a / p)=(a / q)$.",
    "formal_statement": "theorem exercise_18_4 {n : \\u2115} (hn : \\u2203 x y z w : \\u2124, \\n x^3 + y^3 = n \\u2227 z^3 + w^3 = n \\u2227 x \\u2260 z \\u2227 x \\u2260 w \\u2227 y \\u2260 z \\u2227 y \\u2260 w) : \\n n \\u2265 1729"
  },
  {
    "informal_statement": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "formal_statement": "theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \\n [group G] [group H] (hG : card G = 21) (hH : card H = 21) \\n (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\\n G \\u2243* H"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}$ be the collection of open subsets of a metric space $\\\\mathrm{M}$, and $\\\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\\\mathcal{T}$ onto $\\\\mathcal{K}$.",
    "formal_statement": "theorem exercise_2_29 (M : Type*) [metric_space M]\\n (O C : set (set M))\\n (hO : O = {s | is_open s})\\n (hC : C = {s | is_closed s}) :\\n \\u2203 f : O \\u2192 C, bijective f"
  },
  {
    "informal_statement": "Show that if $\\\\prod X_\\\\alpha$ is regular, then so is $X_\\\\alpha$. Assume that each $X_\\\\alpha$ is nonempty.",
    "formal_statement": "theorem exercise_32_2b\\n {\\u03b9 : Type*} {X : \\u03b9 \\u2192 Type*} [\\u2200 i, topological_space (X i)]\\n (h : \\u2200 i, nonempty (X i)) (h2 : regular_space (\\u03a0 i, X i)) :\\n \\u2200 i, regular_space (X i)"
  },
  {
    "informal_statement": "If $G$ is a group and $a, x \\\\in G$, prove that $C\\\\left(x^{-1} a x\\\\right)=x^{-1} C(a) x$",
    "formal_statement": "theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) : \\n set.centralizer {x\\u207b\\u00b9*a*x} = \\n (\\u03bb g : G, x\\u207b\\u00b9*g*x) '' (set.centralizer {a})"
  },
  {
    "informal_statement": "Prove that convergence of $\\\\left\\\\{s_{n}\\\\right\\\\}$ implies convergence of $\\\\left\\\\{\\\\left|s_{n}\\\\right|\\\\right\\\\}$.",
    "formal_statement": "theorem exercise_3_3\\n : \\u2203 (x : \\u211d), tendsto f at_top (\\ud835\\udcdd x) \\u2227 \\u2200 n, f n < 2"
  },
  {
    "informal_statement": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_6_3 :\\n infinite {a : \\u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \\u211a)}"
  },
  {
    "informal_statement": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "formal_statement": "theorem exercise_4_8b\\n (E : set \\u211d) :\\n \\u2203 f : \\u211d \\u2192 \\u211d, uniform_continuous_on f E \\u2227 \\u00ac metric.bounded (set.image f E)"
  },
  {
    "informal_statement": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\\\left(\\\\frac{x+y}{2}\\\\right) \\\\leq \\\\frac{f(x)+f(y)}{2}$ for all $x, y \\\\in(a, b)$. Prove that $f$ is convex.",
    "formal_statement": "theorem exercise_5_2 {a b : \\u211d}\\n {f g : \\u211d \\u2192 \\u211d} (hf : \\u2200 x \\u2208 set.Ioo a b, deriv f x > 0)\\n (hg : g = f\\u207b\\u00b9)\\n (hg_diff : differentiable_on \\u211d g (set.Ioo a b)) :\\n differentiable_on \\u211d g (set.Ioo a b) \\u2227\\n \\u2200 x \\u2208 set.Ioo a b, deriv g x = 1 / deriv f x"
  },
  {
    "informal_statement": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2d {p : \\u2115} (hp : p.prime \\u2227 p > 2) \\n {f : polynomial \\u2124} (hf : f = (X + 2)^p): \\n irreducible (\\u2211 n in (f.support \\\\ {0}), (f.coeff n) * X ^ (n-1) : \\n polynomial \\u2124)"
  },
  {
    "informal_statement": "Prove that if $T \\\\in \\\\mathcal{L}(V)$ is normal, then $\\\\operatorname{range} T=\\\\operatorname{range} T^{*}.$",
    "formal_statement": "theorem exercise_7_10 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\\n is_self_adjoint T \\u2227 T^2 = T"
  },
  {
    "informal_statement": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\\\in G$. Show that $G$ is abelian.",
    "formal_statement": "theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) : \\n set.centralizer {x\\u207b\\u00b9*a*x} = \\n (\\u03bb g : G, x\\u207b\\u00b9*g*x) '' (set.centralizer {a})"
  },
  {
    "informal_statement": "Prove that $(x, y)$ is not a principal ideal in $\\\\mathbb{Q}[x, y]$.",
    "formal_statement": "theorem exercise_9_1_6 : \\u00ac is_principal \\n (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \\u211a)))"
  },
  {
    "informal_statement": "If $G$ is a nonabelian group of order 6, prove that $G \\\\simeq S_3$.",
    "formal_statement": "theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \\u2115}\\n (hp : nat.prime p) (hG : card G = p^2) :\\n \\u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \\u2227 N.normal"
  },
  {
    "informal_statement": "Prove that $x^2+y^2-1$ is irreducible in $\\\\mathbb{Q}[x,y]$.",
    "formal_statement": "theorem exercise_9_4_11 : \\n irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \\u211a)"
  },
  {
    "informal_statement": "Prove that if $|G|=132$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \\n (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \\n comm_group G"
  },
  {
    "informal_statement": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "formal_statement": "theorem exercise_1_1_3 (n : \\u2124) : \\n \\u2200 (a b c : \\u2124), (a+b)+c \\u2261 a+(b+c) [ZMOD n]"
  },
  {
    "informal_statement": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\\\partial D$ such that $f(z) = 1/z$ for $z \\\\in \\\\partial D$.",
    "formal_statement": "theorem exercise_2020_b5 (z : fin 4 \\u2192 \\u2102) (hz0 : \\u2200 n, \\u2016z n\\u2016 < 1) \\n (hz1 : \\u2200 n : fin 4, z n \\u2260 1) : \\n 3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \\u2260 0"
  },
  {
    "informal_statement": "Let $R$ be a ring in which $x^3 = x$ for every $x \\\\in R$. Prove that $R$ is commutative.",
    "formal_statement": "theorem exercise_4_2_9 {p : \\u2115} (hp : nat.prime p) (hp1 : odd p) :\\n \\u2203 (a b : \\u2124), (a / b : \\u211a) = \\u2211 i in finset.range p, 1 / (i + 1) \\u2192 \\u2191p \\u2223 a"
  },
  {
    "informal_statement": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2b : irreducible \\n (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \\u2124)"
  },
  {
    "informal_statement": "Prove that if $T \\\\in \\\\mathcal{L}(V)$ is normal, then $\\\\operatorname{range} T=\\\\operatorname{range} T^{*}.$",
    "formal_statement": "theorem exercise_7_6 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) :\\n T.range = T.adjoint.range"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}_\\\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\\\mathcal{T}_\\\\alpha$.",
    "formal_statement": "theorem exercise_13_4b1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n \\u2203! T', is_topology X T' \\u2227 (\\u2200 i, T i \\u2286 T') \\u2227\\n \\u2200 T'', is_topology X T'' \\u2192 (\\u2200 i, T i \\u2286 T'') \\u2192 T'' \\u2286 T'"
  },
  {
    "informal_statement": "Suppose $a \\\\in R^{1}, f$ is a twice-differentiable real function on $(a, \\\\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\\\left|f^{\\\\prime}(x)\\\\right|,\\\\left|f^{\\\\prime \\\\prime}(x)\\\\right|$, respectively, on $(a, \\\\infty)$. Prove that $M_{1}^{2} \\\\leq 4 M_{0} M_{2} .$",
    "formal_statement": "theorem exercise_5_15 {f : \\u211d \\u2192 \\u211d} (a M0 M1 M2 : \\u211d)\\n (hf' : differentiable_on \\u211d f (set.Ici a))\\n (hf'' : differentiable_on \\u211d (deriv f) (set.Ici a))\\n (hM0 : M0 = Sup {(| f x | )| x \\u2208 (set.Ici a)})\\n (hM1 : M1 = Sup {(| deriv f x | )| x \\u2208 (set.Ici a)})\\n (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\u2208 (set.Ici a)}) :\\n (M1 ^ 2) \\u2264 4 * M0 * M2"
  },
  {
    "informal_statement": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\\\in A$. Prove that $\\\\inf A=-\\\\sup (-A)$.",
    "formal_statement": "theorem exercise_1_11a (z : \\u2102) : \\n \\u2203 (r : \\u211d) (w : \\u2102), abs w = 1 \\u2227 z = r * w"
  },
  {
    "informal_statement": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "formal_statement": "theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \\u2115}\\n (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\\n is_simple_group G \\u2192 false"
  },
  {
    "informal_statement": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "formal_statement": "theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\\n [linear_order Y] [order_topology Y] {f g : X \\u2192 Y}\\n (hf : continuous f) (hg : continuous g) :\\n continuous (\\u03bb x, min (f x) (g x))"
  },
  {
    "informal_statement": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\\\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.",
    "formal_statement": "theorem exercise_2_11_22 {p : \\u2115} {n : \\u2115} {G : Type*} [fintype G] \\n [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\\n [fintype K] (hK : card K = p ^ (n-1)) : \\n K.normal"
  },
  {
    "informal_statement": "Suppose that $f(x)=\\\\sum_{i=0}^{\\\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "formal_statement": "theorem exercise_2017_b3 (f : \\u211d \\u2192 \\u211d) (c : \\u2115 \\u2192 \\u211d)\\n (hf : f = \\u03bb x, (\\u2211' (i : \\u2115), (c i) * x^i)) \\n (hc : \\u2200 n, c n = 0 \\u2228 c n = 1)\\n (hf1 : f (2/3) = 3/2) : \\n irrational (f (1/2))"
  },
  {
    "informal_statement": "Show that a connected metric space having more than one point is uncountable.",
    "formal_statement": "theorem exercise_28_5\\n (X : Type*) [topological_space X] :\\n countably_compact X \\u2194 \\u2200 (C : \\u2115 \\u2192 set X), (\\u2200 n, is_closed (C n)) \\u2227\\n (\\u2200 n, C n \\u2260 \\u2205) \\u2227 (\\u2200 n, C n \\u2286 C (n + 1)) \\u2192 \\u2203 x, \\u2200 n, x \\u2208 C n"
  },
  {
    "informal_statement": "If $k \\\\geq 2$ and $\\\\mathbf{x} \\\\in R^{k}$, prove that there exists $\\\\mathbf{y} \\\\in R^{k}$ such that $\\\\mathbf{y} \\\\neq 0$ but $\\\\mathbf{x} \\\\cdot \\\\mathbf{y}=0$",
    "formal_statement": "theorem exercise_1_19\\n (n : \\u2115)\\n (a b c x : euclidean_space \\u211d (fin n))\\n (r : \\u211d)\\n (h\\u2081 : r > 0)\\n (h\\u2082 : 3 \\u2022 c = 4 \\u2022 b - a)\\n (h\\u2083 : 3 * r = 2 * \\u2016x - b\\u2016)\\n : \\u2016x - a\\u2016 = 2 * \\u2016x - b\\u2016 \\u2194 \\u2016x - c\\u2016 = r"
  },
  {
    "informal_statement": "Prove that $-(-v) = v$ for every $v \\\\in V$.",
    "formal_statement": "theorem exercise_1_6 : \\u2203 U : set (\\u211d \\u00d7 \\u211d),\\n (U \\u2260 \\u2205) \\u2227\\n (\\u2200 (u v : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2227 v \\u2208 U \\u2192 u + v \\u2208 U) \\u2227\\n (\\u2200 (u : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2192 -u \\u2208 U) \\u2227\\n (\\u2200 U' : submodule \\u211d (\\u211d \\u00d7 \\u211d), U \\u2260 \\u2191U')"
  },
  {
    "informal_statement": "Show that X is countably compact if and only if every nested sequence $C_1 \\\\supset C_2 \\\\supset \\\\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "formal_statement": "theorem exercise_29_1 : \\u00ac locally_compact_space \\u211a"
  },
  {
    "informal_statement": "Show that $\\\\int_0^1 \\\\log(\\\\sin \\\\pi x) dx = - \\\\log 2$.",
    "formal_statement": "theorem exercise_3_22 (D : set \\u2102) (hD : D = ball 0 1) (f : \\u2102 \\u2192 \\u2102)\\n (hf : differentiable_on \\u2102 f D) (hfc : continuous_on f (closure D)) :\\n \\u00ac \\u2200 z \\u2208 (sphere (0 : \\u2102) 1), f z = 1 / z"
  },
  {
    "informal_statement": "If $A \\\\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\\\rightarrow A$ such that $r(a)=a$ for each $a \\\\in A$. Show that a retraction is a quotient map.",
    "formal_statement": "theorem exercise_22_2b {X : Type*} [topological_space X]\\n {A : set X} (r : X \\u2192 A) (hr : continuous r) (h : \\u2200 x : A, r x = x) :\\n quotient_map r"
  },
  {
    "informal_statement": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\\\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "formal_statement": "theorem exercise_4_6\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (G : set (\\u211d \\u00d7 \\u211d))\\n (h\\u2081 : is_compact E)\\n (h\\u2082 : G = {(x, f x) | x \\u2208 E})\\n : continuous_on f E \\u2194 is_compact G"
  },
  {
    "informal_statement": "Suppose that $S, T \\\\in \\\\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\\\operatorname{null} (T-\\\\lambda I)$ is invariant under $S$ for every $\\\\lambda \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {S : End F V}\\n (hS : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c) :\\n \\u2203 c : F, S = c \\u2022 id"
  },
  {
    "informal_statement": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\\\bar{V}$ is compact and $\\\\bar{V} \\\\subset U$.",
    "formal_statement": "theorem exercise_30_13 {X : Type*} [topological_space X]\\n (h : \\u2203 (s : set X), countable s \\u2227 dense s) (U : set (set X))\\n (hU : \\u2200 (x y : set X), x \\u2208 U \\u2192 y \\u2208 U \\u2192 x \\u2260 y \\u2192 x \\u2229 y = \\u2205) :\\n countable U"
  },
  {
    "informal_statement": "If $\\\\Sigma a_{n}$ converges, and if $\\\\left\\\\{b_{n}\\\\right\\\\}$ is monotonic and bounded, prove that $\\\\Sigma a_{n} b_{n}$ converges.",
    "formal_statement": "theorem exercise_3_20 {X : Type*} [metric_space X]\\n (p : \\u2115 \\u2192 X) (l : \\u2115) (r : X)\\n (hp : cauchy_seq p)\\n (hpl : tendsto (\\u03bb n, p (l * n)) at_top (\\ud835\\udcdd r)) :\\n tendsto p at_top (\\ud835\\udcdd r)"
  },
  {
    "informal_statement": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\\\in R$ then $x=\\\\pm 1$.",
    "formal_statement": "theorem exercise_7_1_11 {R : Type*} [ring R] [is_domain R] \\n {x : R} (hx : x^2 = 1) : x = 1 \\u2228 x = -1"
  },
  {
    "informal_statement": "Prove that $\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i<n} a_i = \\\\infty$, where $a_i = \\\\sqrt{i + 1} -\\\\sqrt{i}$.",
    "formal_statement": "theorem exercise_3_8\\n (a b : \\u2115 \\u2192 \\u211d)\\n (h1 : \\u2203 y, (tendsto (\\u03bb n, (\\u2211 i in (finset.range n), a i)) at_top (\\ud835\\udcdd y)))\\n (h2 : monotone b)\\n (h3 : metric.bounded (set.range b)) :\\n \\u2203 y, tendsto (\\u03bb n, (\\u2211 i in (finset.range n), (a i) * (b i))) at_top (\\ud835\\udcdd y)"
  },
  {
    "informal_statement": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "formal_statement": "theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\\n (hG : even (card G)) : \\u2203 x : G, order_of x = 2"
  },
  {
    "informal_statement": "If $s_{1}=\\\\sqrt{2}$, and $s_{n+1}=\\\\sqrt{2+\\\\sqrt{s_{n}}} \\\\quad(n=1,2,3, \\\\ldots),$ prove that $\\\\left\\\\{s_{n}\\\\right\\\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\\\ldots$.",
    "formal_statement": "theorem exercise_3_3\\n : \\u2203 (x : \\u211d), tendsto f at_top (\\ud835\\udcdd x) \\u2227 \\u2200 n, f n < 2"
  },
  {
    "informal_statement": "Let $\\\\Omega$ be a bounded open subset of $\\\\mathbb{C}$, and $\\\\varphi: \\\\Omega \\\\rightarrow \\\\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\\\in \\\\Omega$ such that $\\\\varphi\\\\left(z_{0}\\\\right)=z_{0} \\\\quad \\\\text { and } \\\\quad \\\\varphi^{\\\\prime}\\\\left(z_{0}\\\\right)=1$ then $\\\\varphi$ is linear.",
    "formal_statement": "theorem exercise_2_9\\n {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (b : metric.bounded \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (z \\u2208 \\u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\\n \\u2203 (f_lin : \\u2102 \\u2192L[\\u2102] \\u2102), \\u2200 x \\u2208 \\u03a9, f x = f_lin x"
  },
  {
    "informal_statement": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "formal_statement": "theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\\n (s : set X) : set.infinite s \\u2192 is_connected s"
  },
  {
    "informal_statement": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\\\rightarrow Y$ be continuous. Let $h: X \\\\rightarrow Y$ be the function $h(x)=\\\\min \\\\{f(x), g(x)\\\\}.$ Show that $h$ is continuous.",
    "formal_statement": "theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\\n [linear_order Y] [order_topology Y] {f g : X \\u2192 Y}\\n (hf : continuous f) (hg : continuous g) :\\n continuous (\\u03bb x, min (f x) (g x))"
  },
  {
    "informal_statement": "Prove that if $P \\\\in \\\\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\\\in \\\\operatorname{Syl}_{p}(H)$.",
    "formal_statement": "theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\\n (hG : card G = 312) :\\n \\u2203 (p : \\u2115) (P : sylow p G), P.normal"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}$ be the collection of open subsets of a metric space $\\\\mathrm{M}$, and $\\\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\\\mathcal{T}$ onto $\\\\mathcal{K}$.",
    "formal_statement": "theorem exercise_2_41 (m : \\u2115) {X : Type*} [normed_space \\u211d ((fin m) \\u2192 \\u211d)] :\\n is_compact (metric.closed_ball 0 1)"
  },
  {
    "informal_statement": "Prove that $\\\\mathbb{Q}$ has no proper subgroups of finite index.",
    "formal_statement": "theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\\n is_cyclic G \\u2227 \\u2203 G_fin : fintype G, nat.prime (@card G G_fin)"
  },
  {
    "informal_statement": "Prove that subgroups of a solvable group are solvable.",
    "formal_statement": "theorem exercise_3_4_5a {G : Type*} [group G] \\n (H : subgroup G) [is_solvable G] : is_solvable H"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "formal_statement": "theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] [finite_dimensional F V] {S T : End F V}\\n (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\\n (h2 : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c \\u2194 \\u2203 c : F, v \\u2208 eigenspace T c) :\\n S * T = T * S"
  },
  {
    "informal_statement": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\\\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "formal_statement": "theorem exercise_4_8b\\n (E : set \\u211d) :\\n \\u2203 f : \\u211d \\u2192 \\u211d, uniform_continuous_on f E \\u2227 \\u00ac metric.bounded (set.image f E)"
  },
  {
    "informal_statement": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "formal_statement": "theorem exercise_1998_a3 (f : \\u211d \\u2192 \\u211d) (hf : cont_diff \\u211d 3 f) : \\n \\u2203 a : \\u211d, (f a) * (deriv f a) * (iterated_deriv 2 f a) * (iterated_deriv 3 f a) \\u2265 0"
  },
  {
    "informal_statement": "Prove that the power series $\\\\sum zn/n^2$ converges at every point of the unit circle.",
    "formal_statement": "theorem exercise_1_26\\n (f F\\u2081 F\\u2082 : \\u2102 \\u2192 \\u2102) (\\u03a9 : set \\u2102) (h1 : is_open \\u03a9) (h2 : is_connected \\u03a9)\\n (hF\\u2081 : differentiable_on \\u2102 F\\u2081 \\u03a9) (hF\\u2082 : differentiable_on \\u2102 F\\u2082 \\u03a9)\\n (hdF\\u2081 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2081 x = f x) (hdF\\u2082 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2082 x = f x)\\n : \\u2203 c : \\u2102, \\u2200 x, F\\u2081 x = F\\u2082 x + c"
  },
  {
    "informal_statement": "Prove that $\\\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_11 : \\n irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \\u211a)"
  },
  {
    "informal_statement": "Prove that there is no rational number whose square is $12$.",
    "formal_statement": "theorem exercise_1_2 : \\u00ac \\u2203 (x : \\u211a), ( x ^ 2 = 12 )"
  },
  {
    "informal_statement": "Suppose $f$ is continuous in a region $\\\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "formal_statement": "theorem exercise_2_9\\n {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (b : metric.bounded \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (z \\u2208 \\u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\\n \\u2203 (f_lin : \\u2102 \\u2192L[\\u2102] \\u2102), \\u2200 x \\u2208 \\u03a9, f x = f_lin x"
  },
  {
    "informal_statement": "Prove that $x^3 - 3x - 1$ is irreducible over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \\u211a)"
  },
  {
    "informal_statement": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_2_4_16b {n : \\u2115} {hn : n \\u2260 0} \\n {R : subgroup (dihedral_group n)} \\n (hR : R = subgroup.closure {dihedral_group.r 1}) : \\n R \\u2260 \\u22a4 \\u2227 \\n \\u2200 K : subgroup (dihedral_group n), R \\u2264 K \\u2192 K = R \\u2228 K = \\u22a4"
  },
  {
    "informal_statement": "Prove that if $x^{2}=1$ for all $x \\\\in G$ then $G$ is abelian.",
    "formal_statement": "theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \\n (hx_inf : order_of x = 0) (n m : \\u2124) :\\n x ^ n \\u2260 x ^ m"
  },
  {
    "informal_statement": "Prove that $x^3 - 3x - 1$ is irreducible over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\\n (h : a * b = b * a) :\\n \\u2200 x y : closure {x | x = a \\u2228 x = b}, x*y = y*x"
  },
  {
    "informal_statement": "Show that the collection $\\\\{(a,b) \\\\mid a < b, a \\\\text{ and } b \\\\text{ rational}\\\\}$ is a basis that generates a topology different from the lower limit topology on $\\\\mathbb{R}$.",
    "formal_statement": "theorem exercise_13_8b :\\n (topological_space.generate_from {S : set \\u211d | \\u2203 a b : \\u211a, a < b \\u2227 S = Ico a b}).is_open \\u2260\\n (lower_limit_topology \\u211d).is_open"
  },
  {
    "informal_statement": "Prove that the quotient ring $\\\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "formal_statement": "theorem exercise_8_3_6a {R : Type*} [ring R]\\n (hR : R = (gaussian_int \\u29f8 ideal.span ({\\u27e80, 1\\u27e9} : set gaussian_int))) :\\n is_field R \\u2227 \\u2203 finR : fintype R, @card R finR = 2"
  },
  {
    "informal_statement": "Let $H \\\\leq K \\\\leq G$. Prove that $|G: H|=|G: K| \\\\cdot|K: H|$ (do not assume $G$ is finite).",
    "formal_statement": "theorem exercise_3_2_21a (H : add_subgroup \\u211a) (hH : H \\u2260 \\u22a4) : H.index = 0"
  },
  {
    "informal_statement": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "formal_statement": "theorem exercise_4_12\\n {\\u03b1 \\u03b2 \\u03b3 : Type*} [uniform_space \\u03b1] [uniform_space \\u03b2] [uniform_space \\u03b3]\\n {f : \\u03b1 \\u2192 \\u03b2} {g : \\u03b2 \\u2192 \\u03b3}\\n (hf : uniform_continuous f) (hg : uniform_continuous g) :\\n uniform_continuous (g \\u2218 f)"
  },
  {
    "informal_statement": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\\\varphi(N)$, where $\\\\varphi$ denotes Euler's $\\\\varphi$-function. Prove that if $M_{1} \\\\equiv M^{d} \\\\pmod N$ then $M \\\\equiv M_{1}^{d^{\\\\prime}} \\\\pmod N$ where $d^{\\\\prime}$ is the inverse of $d \\\\bmod \\\\varphi(N)$: $d d^{\\\\prime} \\\\equiv 1 \\\\pmod {\\\\varphi(N)}$.",
    "formal_statement": "theorem exercise_8_1_12 {N : \\u2115} (hN : N > 0) {M M': \\u2124} {d : \\u2115}\\n (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \\n (hM' : M' \\u2261 M^d [ZMOD N]) : \\n \\u2203 d' : \\u2115, d' * d \\u2261 1 [ZMOD N.totient] \\u2227 \\n M \\u2261 M'^d' [ZMOD N]"
  },
  {
    "informal_statement": "If $k \\\\geq 2$ and $\\\\mathbf{x} \\\\in R^{k}$, prove that there exists $\\\\mathbf{y} \\\\in R^{k}$ such that $\\\\mathbf{y} \\\\neq 0$ but $\\\\mathbf{x} \\\\cdot \\\\mathbf{y}=0$",
    "formal_statement": "theorem exercise_1_18a\\n (n : \\u2115)\\n (h : n > 1)\\n (x : euclidean_space \\u211d (fin n)) -- R^n\\n : \\u2203 (y : euclidean_space \\u211d (fin n)), y \\u2260 0 \\u2227 (inner x y) = (0 : \\u211d)"
  },
  {
    "informal_statement": "Let $\\\\|\\\\cdot\\\\|$ be any norm on $\\\\mathbb{R}^{m}$ and let $B=\\\\left\\\\{x \\\\in \\\\mathbb{R}^{m}:\\\\|x\\\\| \\\\leq 1\\\\right\\\\}$. Prove that $B$ is compact.",
    "formal_statement": "theorem exercise_2_57 {X : Type*} [topological_space X]\\n : \\u2203 (S : set X), is_connected S \\u2227 \\u00ac is_connected (interior S)"
  },
  {
    "informal_statement": "Let $G=\\\\left\\\\{g_{1}, \\\\ldots, g_{n}\\\\right\\\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "formal_statement": "theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \\n \\u2211 g : G, monoid_algebra.of R G g \\u2208 center (monoid_algebra R G)"
  },
  {
    "informal_statement": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\\\left|g^{-1} x g\\\\right|$.",
    "formal_statement": "theorem exercise_1_1_22a {G : Type*} [group G] (x g : G) :\\n order_of x = order_of (g\\u207b\\u00b9 * x * g)"
  },
  {
    "informal_statement": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "formal_statement": "theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\\n (hH : \\u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \\u2192 H = K) : \\n H.characteristic"
  },
  {
    "informal_statement": "Let $R$ be a ring in which $x^3 = x$ for every $x \\\\in R$. Prove that $R$ is commutative.",
    "formal_statement": "theorem exercise_4_2_5 {R : Type*} [ring R] \\n (h : \\u2200 x : R, x ^ 3 = x) : comm_ring R"
  },
  {
    "informal_statement": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "formal_statement": "theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\\n \\u2200 a b : A \\u29f8 B, a*b = b*a"
  },
  {
    "informal_statement": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "formal_statement": "theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\\n (H : I \\u2192 subgroup G) (hH : \\u2200 i : I, subgroup.normal (H i)) : \\n subgroup.normal (\\u2a05 (i : I), H i)"
  },
  {
    "informal_statement": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\\\varphi(N)$, where $\\\\varphi$ denotes Euler's $\\\\varphi$-function. Prove that if $M_{1} \\\\equiv M^{d} \\\\pmod N$ then $M \\\\equiv M_{1}^{d^{\\\\prime}} \\\\pmod N$ where $d^{\\\\prime}$ is the inverse of $d \\\\bmod \\\\varphi(N)$: $d d^{\\\\prime} \\\\equiv 1 \\\\pmod {\\\\varphi(N)}$.",
    "formal_statement": "theorem exercise_8_3_4 {R : Type*} {n : \\u2124} {r s : \\u211a} \\n (h : r^2 + s^2 = n) : \\n \\u2203 a b : \\u2124, a^2 + b^2 = n"
  },
  {
    "informal_statement": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\\\unlhd G$ and $A$ abelian.",
    "formal_statement": "theorem exercise_4_3_26 {\\u03b1 : Type*} [fintype \\u03b1] (ha : fintype.card \\u03b1 > 1)\\n (h_tran : \\u2200 a b: \\u03b1, \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u03c3 a = b) : \\n \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u2200 a : \\u03b1, \\u03c3 a \\u2260 a"
  },
  {
    "informal_statement": "Prove that if $x^{2}=1$ for all $x \\\\in G$ then $G$ is abelian.",
    "formal_statement": "theorem exercise_1_1_25 {G : Type*} [group G] \\n (h : \\u2200 x : G, x ^ 2 = 1) : \\u2200 a b : G, a*b = b*a"
  },
  {
    "informal_statement": "Suppose $\\\\left\\\\{p_{n}\\\\right\\\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\\\left\\\\{p_{n l}\\\\right\\\\}$ converges to a point $p \\\\in X$. Prove that the full sequence $\\\\left\\\\{p_{n}\\\\right\\\\}$ converges to $p$.",
    "formal_statement": "theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\\n (G : \\u2115 \\u2192 set X) (hG : \\u2200 n, is_open (G n) \\u2227 dense (G n)) :\\n \\u2203 x, \\u2200 n, x \\u2208 G n"
  },
  {
    "informal_statement": "Prove that a group of even order contains an element of order $2 .$",
    "formal_statement": "theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\\n (hG : even (card G)) : \\u2203 x : G, order_of x = 2"
  },
  {
    "informal_statement": "Show that X is countably compact if and only if every nested sequence $C_1 \\\\supset C_2 \\\\supset \\\\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "formal_statement": "theorem exercise_28_5\\n (X : Type*) [topological_space X] :\\n countably_compact X \\u2194 \\u2200 (C : \\u2115 \\u2192 set X), (\\u2200 n, is_closed (C n)) \\u2227\\n (\\u2200 n, C n \\u2260 \\u2205) \\u2227 (\\u2200 n, C n \\u2286 C (n + 1)) \\u2192 \\u2203 x, \\u2200 n, x \\u2208 C n"
  },

  {
    "informal_statement": "If $x, y$ are complex, prove that $||x|-|y|| \\\\leq |x-y|$.",
    "formal_statement": "theorem exercise_1_16a\\n (n : \\u2115)\\n (d r : \\u211d)\\n (x y z : euclidean_space \\u211d (fin n)) -- R^n\\n (h\\u2081 : n \\u2265 3)\\n (h\\u2082 : \\u2016x - y\\u2016 = d)\\n (h\\u2083 : d > 0)\\n (h\\u2084 : r > 0)\\n (h\\u2085 : 2 * r > d)\\n : set.infinite {z : euclidean_space \\u211d (fin n) | \\u2016z - x\\u2016 = r \\u2227 \\u2016z - y\\u2016 = r}"
  },
  {
    "informal_statement": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\\\in G$.",
    "formal_statement": "theorem exercise_2_1_27 {G : Type*} [group G] \\n [fintype G] : \\u2203 (m : \\u2115), \\u2200 (a : G), a ^ m = 1"
  },
  {
    "informal_statement": "Suppose (a) $f$ is continuous for $x \\\\geq 0$, (b) $f^{\\\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\\\prime}$ is monotonically increasing. Put $g(x)=\\\\frac{f(x)}{x} \\\\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "formal_statement": "theorem exercise_5_15 {f : \\u211d \\u2192 \\u211d} (a M0 M1 M2 : \\u211d)\\n (hf' : differentiable_on \\u211d f (set.Ici a))\\n (hf'' : differentiable_on \\u211d (deriv f) (set.Ici a))\\n (hM0 : M0 = Sup {(| f x | )| x \\u2208 (set.Ici a)})\\n (hM1 : M1 = Sup {(| deriv f x | )| x \\u2208 (set.Ici a)})\\n (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\u2208 (set.Ici a)}) :\\n (M1 ^ 2) \\u2264 4 * M0 * M2"
  },
  {
    "informal_statement": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\\\in G$.",
    "formal_statement": "theorem exercise_2_2_5 {G : Type*} [group G] \\n (h : \\u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \\u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\\n comm_group G"
  },
  {
    "informal_statement": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\\\not \\\\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "formal_statement": "theorem exercise_4_8 {p a : \\u2115} (hp : odd p) : \\n is_primitive_root a p \\u2194 (\\u2200 q \\u2223 (p-1), q.prime \\u2192 \\u00ac a^(p-1) \\u2261 1 [MOD p])"
  },
  {
    "informal_statement": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\\\colon X \\\\rightarrow [0, 1]$ such that $f(A) = \\\\{0\\\\}$ and $f(B) = \\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_33_8\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0})\\n (A B : set X) (hA : is_closed A) (hB : is_closed B)\\n (hAB : disjoint A B)\\n (hAc : is_compact A) :\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f '' A = {0} \\u2227 f '' B = {1}"
  },
  {
    "informal_statement": "Prove that $x^3 + 6x + 12$ is irreducible in $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\\n irreducible (12 + 6 * X + X ^ 3 : polynomial F)"
  },
  {
    "informal_statement": "Suppose that $f(x)=\\\\sum_{i=0}^{\\\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "formal_statement": "theorem exercise_2010_a4 (n : \\u2115) : \\n \\u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1)"
  },
  {
    "informal_statement": "Let $F = \\\\mathbb{Z}_p$ be the field of integers $\\\\mod p$, where $p$ is a prime, and let $q(x) \\\\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "formal_statement": "theorem exercise_4_5_16 {p n: \\u2115} (hp : nat.prime p) \\n {q : polynomial (zmod p)} (hq : irreducible q) (hn : q.degree = n) :\\n \\u2203 is_fin : fintype $ polynomial (zmod p) \\u29f8 ideal.span ({q} : set (polynomial $ zmod p)), \\n @card (polynomial (zmod p) \\u29f8 ideal.span {q}) is_fin = p ^ n \\u2227 \\n is_field (polynomial $ zmod p)"
  },
  {
    "informal_statement": "Prove that $x^3 + 6x + 12$ is irreducible in $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\\n irreducible (X ^ 3 - 9 : polynomial F)"
  },
  {
    "informal_statement": "Suppose that $E$ is an uncountable subset of $\\\\mathbb{R}$. Prove that there exists a point $p \\\\in \\\\mathbb{R}$ at which $E$ condenses.",
    "formal_statement": "theorem exercise_2_126 {E : set \\u211d}\\n (hE : \\u00ac set.countable E) : \\u2203 (p : \\u211d), cluster_pt p (\\ud835\\udcdf E)"
  },
  {
    "informal_statement": "Prove that $\\\\sum 1/k(\\\\log(k))^p$ diverges when $p \\\\leq 1$.",
    "formal_statement": "theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\\n (hG : card G = 5) :\\n comm_group G"
  },
  {
    "informal_statement": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "formal_statement": "theorem exercise_4_5a\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (h\\u2081 : is_closed E)\\n (h\\u2082 : continuous_on f E)\\n : \\u2203 (g : \\u211d \\u2192 \\u211d), continuous g \\u2227 \\u2200 x \\u2208 E, f x = g x"
  },
  {
    "informal_statement": "Prove that $x^2+y^2-1$ is irreducible in $\\\\mathbb{Q}[x,y]$.",
    "formal_statement": "theorem exercise_1_1a\\n (x : \\u211d) (y : \\u211a) :\\n ( irrational x ) -> irrational ( x + y )"
  },
  {
    "informal_statement": "Prove that $x^2+1$ is irreducible in $\\\\mathbb{F}_7$",
    "formal_statement": "theorem exercise_11_4_8 {p : \\u2115} (hp : prime p) (n : \\u2115) :\\n irreducible (X ^ n - p : polynomial \\u211a)"
  },
  {
    "informal_statement": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "formal_statement": "theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \\n H.normal \\u2194 \\u2045(\\u22a4 : subgroup G), H\\u2046 \\u2264 H"
  },
  {
    "informal_statement": "Let $\\\\left\\\\{A_{n}\\\\right\\\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\\\cap A_{n+1} \\\\neq \\\\varnothing$ for all $n$. Show that $\\\\bigcup A_{n}$ is connected.",
    "formal_statement": "theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\\n (s : set X) : set.infinite s \\u2192 is_connected s"
  },
  {
    "informal_statement": "Suppose that $S, T \\\\in \\\\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\\\operatorname{null} (T-\\\\lambda I)$ is invariant under $S$ for every $\\\\lambda \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] (S T : V \\u2192\\u2097[F] V) (hST : S \\u2218 T = T \\u2218 S) (c : F):\\n map S (T - c \\u2022 id).ker = (T - c \\u2022 id).ker"
  },
  {
    "informal_statement": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "formal_statement": "theorem exercise_3_1 {F V : Type*} \\n [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\\n (T : V \\u2192\\u2097[F] V) (hT : finrank F V = 1) :\\n \\u2203 c : F, \\u2200 v : V, T v = c \\u2022 v"
  },
  {
    "informal_statement": "Prove that the addition of residue classes $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is associative.",
    "formal_statement": "theorem exercise_1_1_5 (n : \\u2115) (hn : 1 < n) : \\n is_empty (group (zmod n))"
  },
  {
    "informal_statement": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\\\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_6_3 :\\n infinite {a : \\u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \\u211a)}"
  },
  {
    "informal_statement": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\\\partial D$ such that $f(z) = 1/z$ for $z \\\\in \\\\partial D$.",
    "formal_statement": "theorem exercise_3_22 (D : set \\u2102) (hD : D = ball 0 1) (f : \\u2102 \\u2192 \\u2102)\\n (hf : differentiable_on \\u2102 f D) (hfc : continuous_on f (closure D)) :\\n \\u00ac \\u2200 z \\u2208 (sphere (0 : \\u2102) 1), f z = 1 / z"
  },
  {
    "informal_statement": "Suppose that $T \\\\in \\\\mathcal{L}(V)$ has $\\\\operatorname{dim} V$ distinct eigenvalues and that $S \\\\in \\\\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "formal_statement": "theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] [finite_dimensional F V] {S T : End F V}\\n (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\\n (h2 : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c \\u2194 \\u2203 c : F, v \\u2208 eigenspace T c) :\\n S * T = T * S"
  },
  {
    "informal_statement": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "formal_statement": "theorem exercise_4_2_5 {R : Type*} [ring R] \\n (h : \\u2200 x : R, x ^ 3 = x) : comm_ring R"
  },
  {
    "informal_statement": "Suppose $\\\\left\\\\{p_{n}\\\\right\\\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\\\left\\\\{p_{n l}\\\\right\\\\}$ converges to a point $p \\\\in X$. Prove that the full sequence $\\\\left\\\\{p_{n}\\\\right\\\\}$ converges to $p$.",
    "formal_statement": "theorem exercise_3_20 {X : Type*} [metric_space X]\\n (p : \\u2115 \\u2192 X) (l : \\u2115) (r : X)\\n (hp : cauchy_seq p)\\n (hpl : tendsto (\\u03bb n, p (l * n)) at_top (\\ud835\\udcdd r)) :\\n tendsto p at_top (\\ud835\\udcdd r)"
  },
  {
    "informal_statement": "If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\\\in \\\\mathbb{Z}$ are all distinct.",
    "formal_statement": "theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \\n (hx_inf : order_of x = 0) (n m : \\u2124) :\\n x ^ n \\u2260 x ^ m"
  },
  {
    "informal_statement": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "formal_statement": "theorem exercise_4_19\\n {f : \\u211d \\u2192 \\u211d} (hf : \\u2200 a b c, a < b \\u2192 f a < c \\u2192 c < f b \\u2192 \\u2203 x, a < x \\u2227 x < b \\u2227 f x = c)\\n (hg : \\u2200 r : \\u211a, is_closed {x | f x = r}) : continuous f"
  },
  {
    "informal_statement": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "formal_statement": "theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\\n [subgroup.characteristic H] : subgroup.normal H"
  },
  {
    "informal_statement": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\\\leq H$.",
    "formal_statement": "theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \\n H.normal \\u2194 \\u2045(\\u22a4 : subgroup G), H\\u2046 \\u2264 H"
  },
  {
    "informal_statement": "If $A \\\\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\\\rightarrow A$ such that $r(a)=a$ for each $a \\\\in A$. Show that a retraction is a quotient map.",
    "formal_statement": "theorem exercise_23_2 {X : Type*}\\n [topological_space X] {A : \\u2115 \\u2192 set X} (hA : \\u2200 n, is_connected (A n))\\n (hAn : \\u2200 n, A n \\u2229 A (n + 1) \\u2260 \\u2205) :\\n is_connected (\\u22c3 n, A n)"
  },
  {
    "informal_statement": "Prove that $x^2+1$ is irreducible in $\\\\mathbb{F}_7$",
    "formal_statement": "theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\\n irreducible (X ^ 3 - 9 : polynomial F)"
  },
  {
    "informal_statement": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\\\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "formal_statement": "theorem exercise_2_11_6 {G : Type*} [group G] {p : \\u2115} (hp : nat.prime p) \\n {P : sylow p G} (hP : P.normal) :\\n \\u2200 (Q : sylow p G), P = Q"
  },
  {
    "informal_statement": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "formal_statement": "theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\\n (hx : order_of x = 2) (hx1 : \\u2200 y, order_of y = 2 \\u2192 y = x) :\\n x \\u2208 center G"
  },
  {
    "informal_statement": "Prove that if $P \\\\in \\\\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\\\in \\\\operatorname{Syl}_{p}(H)$.",
    "formal_statement": "theorem exercise_4_5_1a {p : \\u2115} {G : Type*} [group G] \\n {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \\n (hH : P \\u2264 H) : is_p_group p H"
  },
  {
    "informal_statement": "Suppose $k \\\\geq 3, x, y \\\\in \\\\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\\\in \\\\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "formal_statement": "theorem exercise_1_16a\\n (n : \\u2115)\\n (d r : \\u211d)\\n (x y z : euclidean_space \\u211d (fin n)) -- R^n\\n (h\\u2081 : n \\u2265 3)\\n (h\\u2082 : \\u2016x - y\\u2016 = d)\\n (h\\u2083 : d > 0)\\n (h\\u2084 : r > 0)\\n (h\\u2085 : 2 * r > d)\\n : set.infinite {z : euclidean_space \\u211d (fin n) | \\u2016z - x\\u2016 = r \\u2227 \\u2016z - y\\u2016 = r}"
  },
  {
    "informal_statement": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "formal_statement": "theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\\n irreducible (12 + 6 * X + X ^ 3 : polynomial F)"
  },
  {
    "informal_statement": "Suppose that $T \\\\in \\\\mathcal{L}(V)$ has $\\\\operatorname{dim} V$ distinct eigenvalues and that $S \\\\in \\\\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "formal_statement": "theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \\u2102 V]\\n [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = 0 \\u2194 \\u2200 (a : \\u2102), \\u2016u\\u2016 \\u2264 \\u2016u + a \\u2022 v\\u2016"
  },
  {
    "informal_statement": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "formal_statement": "theorem exercise_3_5 : \\u00ac \\u2203 x y : \\u2124, 7*x^3 + 2 = y^3"
  },
  {
    "informal_statement": "Suppose (a) $f$ is continuous for $x \\\\geq 0$, (b) $f^{\\\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\\\prime}$ is monotonically increasing. Put $g(x)=\\\\frac{f(x)}{x} \\\\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "formal_statement": "theorem exercise_5_6\\n {f : \\u211d \\u2192 \\u211d}\\n (hf1 : continuous f)\\n (hf2 : \\u2200 x, differentiable_at \\u211d f x)\\n (hf3 : f 0 = 0)\\n (hf4 : monotone (deriv f)) :\\n monotone_on (\\u03bb x, f x / x) (set.Ioi 0)"
  },
  {
    "informal_statement": "Prove that the addition of residue classes $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is associative.",
    "formal_statement": "theorem exercise_1_1_3 (n : \\u2124) : \\n \\u2200 (a b c : \\u2124), (a+b)+c \\u2261 a+(b+c) [ZMOD n]"
  },
  {
    "informal_statement": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \\n subgroup.closure ((H : set G) \\\\ {1}) = \\u22a4"
  },
  {
    "informal_statement": "Prove that if $V$ is a complex inner-product space, then $\\\\langle u, v\\\\rangle=\\\\frac{\\\\|u+v\\\\|^{2}-\\\\|u-v\\\\|^{2}+\\\\|u+i v\\\\|^{2} i-\\\\|u-i v\\\\|^{2} i}{4}$ for all $u, v \\\\in V$.",
    "formal_statement": "theorem exercise_6_7 {V : Type*} [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = (\\u2016u + v\\u2016^2 - \\u2016u - v\\u2016^2 + I*\\u2016u + I\\u2022v\\u2016^2 - I*\\u2016u-I\\u2022v\\u2016^2) / 4"
  },
  {
    "informal_statement": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\\\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "formal_statement": "theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \\n (hG : card G > 2) (H : subgroup G) [fintype H] : \\n card H \\u2260 card G - 1"
  },
  {
    "informal_statement": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "formal_statement": "theorem exercise_4_12\\n {\\u03b1 \\u03b2 \\u03b3 : Type*} [uniform_space \\u03b1] [uniform_space \\u03b2] [uniform_space \\u03b3]\\n {f : \\u03b1 \\u2192 \\u03b2} {g : \\u03b2 \\u2192 \\u03b3}\\n (hf : uniform_continuous f) (hg : uniform_continuous g) :\\n uniform_continuous (g \\u2218 f)"
  },
  {
    "informal_statement": "Prove that if $V$ is a complex inner-product space, then $\\\\langle u, v\\\\rangle=\\\\frac{\\\\|u+v\\\\|^{2}-\\\\|u-v\\\\|^{2}+\\\\|u+i v\\\\|^{2} i-\\\\|u-i v\\\\|^{2} i}{4}$ for all $u, v \\\\in V$.",
    "formal_statement": "theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\\n {U : submodule K V} : \\n U.orthogonal = \\u22a5 \\u2194 U = \\u22a4"
  },
  {
    "informal_statement": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\\\{z \\\\in \\\\mathbb{C}:|z| \\\\leq 1\\\\}$.",
    "formal_statement": "theorem exercise_2017_b3 (f : \\u211d \\u2192 \\u211d) (c : \\u2115 \\u2192 \\u211d)\\n (hf : f = \\u03bb x, (\\u2211' (i : \\u2115), (c i) * x^i)) \\n (hc : \\u2200 n, c n = 0 \\u2228 c n = 1)\\n (hf1 : f (2/3) = 3/2) : \\n irrational (f (1/2))"
  },
  {
    "informal_statement": "Prove that there is no rational number whose square is $12$.",
    "formal_statement": "theorem exercise_1_5 (A minus_A : set \\u211d) (hA : A.nonempty) \\n (hA_bdd_below : bdd_below A) (hminus_A : minus_A = {x | -x \\u2208 A}) :\\n Inf A = Sup minus_A"
  },
  {
    "informal_statement": "Suppose $p \\\\in \\\\mathcal{P}(\\\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\\\prime}$ have no roots in common.",
    "formal_statement": "theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] (S T : V \\u2192\\u2097[F] V) (hST : S \\u2218 T = T \\u2218 S) (c : F):\\n map S (T - c \\u2022 id).ker = (T - c \\u2022 id).ker"
  },
  {
    "informal_statement": "Prove that the multiplicative groups $\\\\mathbb{R}-\\\\{0\\\\}$ and $\\\\mathbb{C}-\\\\{0\\\\}$ are not isomorphic.",
    "formal_statement": "theorem exercise_1_6_17 {G : Type*} [group G] (f : G \\u2192 G) \\n (hf : f = \\u03bb g, g\\u207b\\u00b9) :\\n \\u2200 x y : G, f x * f y = f (x*y) \\u2194 \\u2200 x y : G, x*y = y*x"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is self-adjoint, $\\\\lambda \\\\in \\\\mathbf{F}$, and $\\\\epsilon>0$. Prove that if there exists $v \\\\in V$ such that $\\\\|v\\\\|=1$ and $\\\\|T v-\\\\lambda v\\\\|<\\\\epsilon,$ then $T$ has an eigenvalue $\\\\lambda^{\\\\prime}$ such that $\\\\left|\\\\lambda-\\\\lambda^{\\\\prime}\\\\right|<\\\\epsilon$.",
    "formal_statement": "theorem exercise_7_14 {\\ud835\\udd5c V : Type*} [is_R_or_C \\ud835\\udd5c]\\n [inner_product_space \\ud835\\udd5c V] [finite_dimensional \\ud835\\udd5c V]\\n {T : End \\ud835\\udd5c V} (hT : is_self_adjoint T)\\n {l : \\ud835\\udd5c} {\\u03b5 : \\u211d} (he : \\u03b5 > 0) : \\u2203 v : V, \\u2016v\\u2016= 1 \\u2227 (\\u2016T v - l \\u2022 v\\u2016 < \\u03b5 \\u2192\\n (\\u2203 l' : T.eigenvalues, \\u2016l - l'\\u2016 < \\u03b5))"
  },
  {
    "informal_statement": "Show that the rationals $\\\\mathbb{Q}$ are not locally compact.",
    "formal_statement": "theorem exercise_29_1 : \\u00ac locally_compact_space \\u211a"
  },
  {
    "informal_statement": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "formal_statement": "theorem exercise_6_8_1 {G : Type*} [group G]\\n (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3}"
  },
  {
    "informal_statement": "A map $f: X \\\\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\\\pi_{1}: X \\\\times Y \\\\rightarrow X$ and $\\\\pi_{2}: X \\\\times Y \\\\rightarrow Y$ are open maps.",
    "formal_statement": "theorem exercise_17_4 {X : Type*} [topological_space X]\\n (U A : set X) (hU : is_open U) (hA : is_closed A) :\\n is_open (U \\\\ A) \\u2227 is_closed (A \\\\ U)"
  },
  {
    "informal_statement": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\\\operatorname{dim} V=1$ and $T \\\\in \\\\mathcal{L}(V, V)$, then there exists $a \\\\in \\\\mathbf{F}$ such that $T v=a v$ for all $v \\\\in V$.",
    "formal_statement": "theorem exercise_4_4 (p : polynomial \\u2102) :\\n p.degree = @card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102) \\u2194\\n disjoint\\n (@card (root_set p.derivative \\u2102) (polynomial.root_set_fintype p.derivative \\u2102))\\n (@card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102))"
  },
  {
    "informal_statement": "Prove that characteristic subgroups are normal.",
    "formal_statement": "theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\\n (hH : \\u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \\u2192 H = K) : \\n H.characteristic"
  },
  {
    "informal_statement": "Show that the lower limit topology $\\\\mathbb{R}_l$ and $K$-topology $\\\\mathbb{R}_K$ are not comparable.",
    "formal_statement": "theorem exercise_13_8b :\\n (topological_space.generate_from {S : set \\u211d | \\u2203 a b : \\u211a, a < b \\u2227 S = Ico a b}).is_open \\u2260\\n (lower_limit_topology \\u211d).is_open"
  },
  {
    "informal_statement": "is: If $a \\\\neq 0$, then the interior of the hyperplane $\\\\{x \\\\in \\\\mathbb{R}^n \\\\mid a \\\\cdot x = b\\\\}$ is empty.\"} {\"text\": \"constants (p q : Prop) (H : p \\u2227 q)\\ntheorem t_proof_left : p := and.elim_left H\\ntheorem t_proof_right : q := and.elim_right H\\ncheck t_proof_left -- t_proof_left : p\\ncheck t_proof_right -- t_proof_right : q\\n\"} {\"text\": \"\\ntheorem Ex003_1 (a b: Prop) : \\u00aca \\u2192 a \\u2192 b :=\\nassume A:\\u00aca,\\n assume B:a,\\n have C:false, from A B,\\n show b, from false.elim C\\n\\n\\ntheorem Ex003_2 (a b : Prop) : \\u00aca \\u2192 a \\u2192 b := \\nbegin\\n intro,\\n intro,\\n contradiction\\nend \\n\\n\\n\\n\\n\"} {\"text\": \"in",
    "formal_statement": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\\\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.formal statement theorem exercise_2_11_6 {G : Type*} [group G] {p : \\u2115} (hp : nat.prime p) \\n {P : sylow p G} (hP : P.normal) :\\n \\u2200 (Q : sylow p G), P = Q"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}_\\\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\\\mathcal{T}_\\\\alpha$.",
    "formal_statement": "theorem exercise_13_5a {X : Type*}\\n [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\\n generate_from A = generate_from (sInter {T | is_topology X T \\u2227 A \\u2286 T})"
  },
  {
    "informal_statement": "Prove that $\\\\cos 1^{\\\\circ}$ is algebraic over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \\u211a)"
  },
  {
    "informal_statement": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\\\cap J$ in $R / I J$ is nilpotent.",
    "formal_statement": "theorem exercise_10_7_10 {R : Type*} [ring R]\\n (M : ideal R) (hM : \\u2200 (x : R), x \\u2209 M \\u2192 is_unit x) :\\n is_maximal M \\u2227 \\u2200 (N : ideal R), is_maximal N \\u2192 N = M"
  },
  {
    "informal_statement": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\\\in R$ then $x=\\\\pm 1$.",
    "formal_statement": "theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \\u2200 a : R, a^2 = a) :\\n comm_ring R"
  },
  {
    "informal_statement": "A map $f: X \\\\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\\\pi_{1}: X \\\\times Y \\\\rightarrow X$ and $\\\\pi_{2}: X \\\\times Y \\\\rightarrow Y$ are open maps.",
    "formal_statement": "theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\\n (\\u03c0\\u2081 : X \\u00d7 Y \\u2192 X)\\n (\\u03c0\\u2082 : X \\u00d7 Y \\u2192 Y)\\n (h\\u2081 : \\u03c0\\u2081 = prod.fst)\\n (h\\u2082 : \\u03c0\\u2082 = prod.snd) :\\n is_open_map \\u03c0\\u2081 \\u2227 is_open_map \\u03c0\\u2082"
  },
  {
    "informal_statement": "Prove that $\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i<n} a_i = \\\\infty$, where $a_i = \\\\sqrt{i + 1} -\\\\sqrt{i}$.",
    "formal_statement": "theorem exercise_3_6a\\n: tendsto (\\u03bb (n : \\u2115), (\\u2211 i in finset.range n, g i)) at_top at_top"
  },
  {
    "informal_statement": "Suppose $X$ is a nonempty complete metric space, and $\\\\left\\\\{G_{n}\\\\right\\\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\\\bigcap_{1}^{\\\\infty} G_{n}$ is not empty.",
    "formal_statement": "theorem exercise_4_2a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (h\\u2081 : continuous f)\\n : \\u2200 (x : set \\u03b1), f '' (closure x) \\u2286 closure (f '' x)"
  },
  {
    "informal_statement": "Suppose $u, v \\\\in V$. Prove that $\\\\langle u, v\\\\rangle=0$ if and only if $\\\\|u\\\\| \\\\leq\\\\|u+a v\\\\|$ for all $a \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_6_7 {V : Type*} [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = (\\u2016u + v\\u2016^2 - \\u2016u - v\\u2016^2 + I*\\u2016u + I\\u2022v\\u2016^2 - I*\\u2016u-I\\u2022v\\u2016^2) / 4"
  },
  {
    "informal_statement": "Show that the collection $\\\\{(a,b) \\\\mid a < b, a \\\\text{ and } b \\\\text{ rational}\\\\}$ is a basis that generates a topology different from the lower limit topology on $\\\\mathbb{R}$.",
    "formal_statement": "theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\\n (\\u03c0\\u2081 : X \\u00d7 Y \\u2192 X)\\n (\\u03c0\\u2082 : X \\u00d7 Y \\u2192 Y)\\n (h\\u2081 : \\u03c0\\u2081 = prod.fst)\\n (h\\u2082 : \\u03c0\\u2082 = prod.snd) :\\n is_open_map \\u03c0\\u2081 \\u2227 is_open_map \\u03c0\\u2082"
  },
  {
    "informal_statement": "If $f$ is a real continuous function defined on a closed set $E \\\\subset \\\\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\\\in E$.",
    "formal_statement": "theorem exercise_4_6\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (G : set (\\u211d \\u00d7 \\u211d))\\n (h\\u2081 : is_compact E)\\n (h\\u2082 : G = {(x, f x) | x \\u2208 E})\\n : continuous_on f E \\u2194 is_compact G"
  },
  {
    "informal_statement": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "formal_statement": "theorem exercise_9_4_2b : irreducible \\n (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \\u2124)"
  },
  {
    "informal_statement": "Let $X$ be a compact Hausdorff space. Let $\\\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\\\bigcap_{A \\\\in \\\\mathcal{A}} A$ is connected.",
    "formal_statement": "theorem exercise_26_11\\n {X : Type*} [topological_space X] [compact_space X] [t2_space X]\\n (A : set (set X)) (hA : \\u2200 (a b : set X), a \\u2208 A \\u2192 b \\u2208 A \\u2192 a \\u2286 b \\u2228 b \\u2286 a)\\n (hA' : \\u2200 a \\u2208 A, is_closed a) (hA'' : \\u2200 a \\u2208 A, is_connected a) :\\n is_connected (\\u22c2\\u2080 A)"
  },
  {
    "informal_statement": "Suppose $a, b \\\\in R^k$. Find $c \\\\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "formal_statement": "theorem exercise_2_24 {X : Type*} [metric_space X]\\n (hX : \\u2200 (A : set X), infinite A \\u2192 \\u2203 (x : X), x \\u2208 closure A) :\\n separable_space X"
  },
  {
    "informal_statement": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "formal_statement": "theorem exercise_4_5_16 {p q r : \\u2115} {G : Type*} [group G] \\n [fintype G] (hpqr : p < q \\u2227 q < r) \\n (hpqr1 : p.prime \\u2227 q.prime \\u2227 r.prime)(hG : card G = p*q*r) : \\n nonempty (sylow p G) \\u2228 nonempty(sylow q G) \\u2228 nonempty(sylow r G)"
  },
  {
    "informal_statement": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "formal_statement": "theorem exercise_1_1_18 {G : Type*} [group G]\\n (x y : G) : x * y = y * x \\u2194 y\\u207b\\u00b9 * x * y = x \\u2194 x\\u207b\\u00b9 * y\\u207b\\u00b9 * x * y = 1"
  },
  {
    "informal_statement": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "formal_statement": "theorem exercise_6_8_1 {G : Type*} [group G]\\n (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3}"
  },
  {
    "informal_statement": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "formal_statement": "theorem exercise_3_5 : \\u00ac \\u2203 x y : \\u2124, 7*x^3 + 2 = y^3"
  },
  {
    "informal_statement": "Show that 2 is divisible by $(1+i)^{2}$ in $\\\\mathbb{Z}[i]$.",
    "formal_statement": "theorem exercise_2_21 {l : \\u2115 \\u2192 \\u211d} \\n (hl : \\u2200 p n : \\u2115, p.prime \\u2192 l (p^n) = log p )\\n (hl1 : \\u2200 m : \\u2115, \\u00ac is_prime_pow m \\u2192 l m = 0) :\\n l = \\u03bb n, \\u2211 d : divisors n, moebius (n/d) * log d"
  },
  {
    "informal_statement": "Define $\\\\wedge(n)=\\\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\\\sum_{A \\\\mid n} \\\\mu(n / d) \\\\log d$ $=\\\\wedge(n)$.",
    "formal_statement": "theorem exercise_2_21 {l : \\u2115 \\u2192 \\u211d} \\n (hl : \\u2200 p n : \\u2115, p.prime \\u2192 l (p^n) = log p )\\n (hl1 : \\u2200 m : \\u2115, \\u00ac is_prime_pow m \\u2192 l m = 0) :\\n l = \\u03bb n, \\u2211 d : divisors n, moebius (n/d) * log d"
  },
  {
    "informal_statement": "For all odd $n$ show that $8 \\\\mid n^{2}-1$.",
    "formal_statement": "theorem exercise_1_31 : (\\u27e81, 1\\u27e9 : gaussian_int) ^ 2 \\u2223 2"
  },
  {
    "informal_statement": "Define $f_{n}:[0,1] \\\\rightarrow \\\\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\\\left(f_{n}(x)\\\\right)$ converges for each $x \\\\in[0,1]$.",
    "formal_statement": "theorem exercise_21_8\\n {X : Type*} [topological_space X] {Y : Type*} [metric_space Y]\\n {f : \\u2115 \\u2192 X \\u2192 Y} {x : \\u2115 \\u2192 X}\\n (hf : \\u2200 n, continuous (f n))\\n (x\\u2080 : X)\\n (hx : tendsto x at_top (\\ud835\\udcdd x\\u2080))\\n (f\\u2080 : X \\u2192 Y)\\n (hh : tendsto_uniformly f f\\u2080 at_top) :\\n tendsto (\\u03bb n, f n (x n)) at_top (\\ud835\\udcdd (f\\u2080 x\\u2080))"
  },
  {
    "informal_statement": "If $G$ is a group and $a, x \\\\in G$, prove that $C\\\\left(x^{-1} a x\\\\right)=x^{-1} C(a) x$",
    "formal_statement": "theorem exercise_2_4_36 {a n : \\u2115} (h : a > 1) :\\n n \\u2223 (a ^ n - 1).totient"
  },
  {
    "informal_statement": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\\\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\\\left(f_{n}\\\\right)$ converges uniformly to $f$, then $\\\\left(f_{n}\\\\left(x_{n}\\\\right)\\\\right)$ converges to $f(x)$.",
    "formal_statement": "theorem exercise_22_2b {X : Type*} [topological_space X]\\n {A : set X} (r : X \\u2192 A) (hr : continuous r) (h : \\u2200 x : A, r x = x) :\\n quotient_map r"
  },
  {
    "informal_statement": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "formal_statement": "theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\\n \\u2200 a b : A \\u29f8 B, a*b = b*a"
  },
  {
    "informal_statement": "Prove that characteristic subgroups are normal.",
    "formal_statement": "theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\\n [subgroup.characteristic H] : subgroup.normal H"
  },
  {
    "informal_statement": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "formal_statement": "theorem exercise_8_3_6a {R : Type*} [ring R]\\n (hR : R = (gaussian_int \\u29f8 ideal.span ({\\u27e80, 1\\u27e9} : set gaussian_int))) :\\n is_field R \\u2227 \\u2203 finR : fintype R, @card R finR = 2"
  },
  {
    "informal_statement": "Let $H \\\\leq K \\\\leq G$. Prove that $|G: H|=|G: K| \\\\cdot|K: H|$ (do not assume $G$ is finite).",
    "formal_statement": "theorem exercise_3_2_11 {G : Type*} [group G] {H K : subgroup G}\\n (hHK : H \\u2264 K) : \\n H.index = K.index * H.relindex K"
  },
  {
    "informal_statement": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "formal_statement": "theorem exercise_3_1 : infinite {p : primes // p \\u2261 -1 [ZMOD 6]}"
  },
  {
    "informal_statement": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "formal_statement": "theorem exercise_32_1 {X : Type*} [topological_space X]\\n (hX : normal_space X) (A : set X) (hA : is_closed A) :\\n normal_space {x // x \\u2208 A}"
  },
  {
    "informal_statement": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "formal_statement": "theorem exercise_4_1_19 : infinite {x : quaternion \\u211d | x^2 = -1}"
  },
  {
    "informal_statement": "Define $\\\\wedge(n)=\\\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\\\sum_{A \\\\mid n} \\\\mu(n / d) \\\\log d$ $=\\\\wedge(n)$.",
    "formal_statement": "theorem exercise_3_1 : infinite {p : primes // p \\u2261 -1 [ZMOD 6]}"
  },
  {
    "informal_statement": "If $C_{0}+\\\\frac{C_{1}}{2}+\\\\cdots+\\\\frac{C_{n-1}}{n}+\\\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\\\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "formal_statement": "theorem exercise_5_6\\n {f : \\u211d \\u2192 \\u211d}\\n (hf1 : continuous f)\\n (hf2 : \\u2200 x, differentiable_at \\u211d f x)\\n (hf3 : f 0 = 0)\\n (hf4 : monotone (deriv f)) :\\n monotone_on (\\u03bb x, f x / x) (set.Ioi 0)"
  },
  {
    "informal_statement": "Show that $\\\\int_0^1 \\\\log(\\\\sin \\\\pi x) dx = - \\\\log 2$.",
    "formal_statement": "theorem exercise_3_9 : \\u222b x in 0..1, real.log (real.sin (real.pi * x)) = - real.log 2"
  },
  {
    "informal_statement": "Prove that $\\\\cos 1^{\\\\circ}$ is algebraic over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_3_10 : is_algebraic \\u211a (cos (real.pi / 180))"
  },
  {
    "informal_statement": "Let $F = \\\\mathbb{Z}_p$ be the field of integers $\\\\mod p$, where $p$ is a prime, and let $q(x) \\\\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "formal_statement": "theorem exercise_4_5_25 {p : \\u2115} (hp : nat.prime p) :\\n irreducible (\\u2211 i : finset.range p, X ^ p : polynomial \\u211a)"
  },
  {
    "informal_statement": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "formal_statement": "theorem exercise_6_1_14 (G : Type*) [group G]\\n (hG : is_cyclic $ G \\u29f8 (center G)) :\\n center G = \\u22a4"
  },
  {
    "informal_statement": "If $s_{1}=\\\\sqrt{2}$, and $s_{n+1}=\\\\sqrt{2+\\\\sqrt{s_{n}}} \\\\quad(n=1,2,3, \\\\ldots),$ prove that $\\\\left\\\\{s_{n}\\\\right\\\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\\\ldots$.",
    "formal_statement": "theorem exercise_3_6a\\n: tendsto (\\u03bb (n : \\u2115), (\\u2211 i in finset.range n, g i)) at_top at_top"
  },
  {
    "informal_statement": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "formal_statement": "theorem exercise_4_4a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (s : set \\u03b1)\\n (h\\u2081 : continuous f)\\n (h\\u2082 : dense s)\\n : f '' set.univ \\u2286 closure (f '' s)"
  },
  {
    "informal_statement": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "formal_statement": "theorem exercise_2000_a2 : \\n \\u2200 N : \\u2115, \\u2203 n : \\u2115, n > N \\u2227 \\u2203 i : fin 6 \\u2192 \\u2115, n = (i 0)^2 + (i 1)^2 \\u2227 \\n n + 1 = (i 2)^2 + (i 3)^2 \\u2227 n + 2 = (i 4)^2 + (i 5)^2"
  },
  {
    "informal_statement": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\\\geq 1$. Prove that the ideal $p \\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$ is a nilpotent ideal in the ring $\\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$.",
    "formal_statement": "theorem exercise_7_3_37 {R : Type*} {p m : \\u2115} (hp : p.prime) \\n (N : ideal $ zmod $ p^m) : \\n is_nilpotent N \\u2194 is_nilpotent (ideal.span ({p} : set $ zmod $ p^m))"
  },
  {
    "informal_statement": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.",
    "formal_statement": "theorem exercise_1998_a3 (f : \\u211d \\u2192 \\u211d) (hf : cont_diff \\u211d 3 f) : \\n \\u2203 a : \\u211d, (f a) * (deriv f a) * (iterated_deriv 2 f a) * (iterated_deriv 3 f a) \\u2265 0"
  },
  {
    "informal_statement": "Suppose $k \\\\geq 3, x, y \\\\in \\\\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\\\in \\\\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "formal_statement": "theorem exercise_1_18a\\n (n : \\u2115)\\n (h : n > 1)\\n (x : euclidean_space \\u211d (fin n)) -- R^n\\n : \\u2203 (y : euclidean_space \\u211d (fin n)), y \\u2260 0 \\u2227 (inner x y) = (0 : \\u211d)"
  },
  {
    "informal_statement": "Prove that $\\\\mathbb{Q}$ has no proper subgroups of finite index.",
    "formal_statement": "theorem exercise_3_2_21a (H : add_subgroup \\u211a) (hH : H \\u2260 \\u22a4) : H.index = 0"
  },
  {
    "informal_statement": "Show that if $\\\\prod X_\\\\alpha$ is regular, then so is $X_\\\\alpha$. Assume that each $X_\\\\alpha$ is nonempty.",
    "formal_statement": "theorem exercise_32_3 {X : Type*} [topological_space X]\\n (hX : locally_compact_space X) (hX' : t2_space X) :\\n regular_space X"
  },
  {
    "informal_statement": "Let $R$ be the ring of $2 \\\\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "formal_statement": "theorem exercise_4_5_16 {p n: \\u2115} (hp : nat.prime p) \\n {q : polynomial (zmod p)} (hq : irreducible q) (hn : q.degree = n) :\\n \\u2203 is_fin : fintype $ polynomial (zmod p) \\u29f8 ideal.span ({q} : set (polynomial $ zmod p)), \\n @card (polynomial (zmod p) \\u29f8 ideal.span {q}) is_fin = p ^ n \\u2227 \\n is_field (polynomial $ zmod p)"
  },
  {
    "informal_statement": "Let $\\\\Omega$ be a bounded open subset of $\\\\mathbb{C}$, and $\\\\varphi: \\\\Omega \\\\rightarrow \\\\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\\\in \\\\Omega$ such that $\\\\varphi\\\\left(z_{0}\\\\right)=z_{0} \\\\quad \\\\text { and } \\\\quad \\\\varphi^{\\\\prime}\\\\left(z_{0}\\\\right)=1$ then $\\\\varphi$ is linear.",
    "formal_statement": "theorem exercise_3_3 (a : \\u211d) (ha : 0 < a) :\\n tendsto (\\u03bb y, \\u222b x in -y..y, real.cos x / (x ^ 2 + a ^ 2))\\n at_top (\\ud835\\udcdd (real.pi * (real.exp (-a) / a)))"
  },
  {
    "informal_statement": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\\\overline{E}) \\\\subset \\\\overline{f(E)}$ for every set $E \\\\subset X$. ($\\\\overline{E}$ denotes the closure of $E$).",
    "formal_statement": "theorem exercise_4_2a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (h\\u2081 : continuous f)\\n : \\u2200 (x : set \\u03b1), f '' (closure x) \\u2286 closure (f '' x)"
  },
  {
    "informal_statement": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "formal_statement": "theorem exercise_5_3_10 : is_algebraic \\u211a (cos (real.pi / 180))"
  },
  {
    "informal_statement": "Let $f: S^{1} \\\\rightarrow \\\\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "formal_statement": "theorem exercise_25_4 {X : Type*} [topological_space X]\\n [loc_path_connected_space X] (U : set X) (hU : is_open U)\\n (hcU : is_connected U) : is_path_connected U"
  },
  {
    "informal_statement": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "formal_statement": "theorem exercise_3_2_11 {G : Type*} [group G] {H K : subgroup G}\\n (hHK : H \\u2264 K) : \\n H.index = K.index * H.relindex K"
  },
  {
    "informal_statement": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\\\left|g^{-1} x g\\\\right|$.",
    "formal_statement": "theorem exercise_1_1_25 {G : Type*} [group G] \\n (h : \\u2200 x : G, x ^ 2 = 1) : \\u2200 a b : G, a*b = b*a"
  },
  {
    "informal_statement": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\\\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\\\left(f_{n}\\\\right)$ converges uniformly to $f$, then $\\\\left(f_{n}\\\\left(x_{n}\\\\right)\\\\right)$ converges to $f(x)$.",
    "formal_statement": "theorem exercise_21_8\\n {X : Type*} [topological_space X] {Y : Type*} [metric_space Y]\\n {f : \\u2115 \\u2192 X \\u2192 Y} {x : \\u2115 \\u2192 X}\\n (hf : \\u2200 n, continuous (f n))\\n (x\\u2080 : X)\\n (hx : tendsto x at_top (\\ud835\\udcdd x\\u2080))\\n (f\\u2080 : X \\u2192 Y)\\n (hh : tendsto_uniformly f f\\u2080 at_top) :\\n tendsto (\\u03bb n, f n (x n)) at_top (\\ud835\\udcdd (f\\u2080 x\\u2080))"
  },
  {
    "informal_statement": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\\\overline{E}) \\\\subset \\\\overline{f(E)}$ for every set $E \\\\subset X$. ($\\\\overline{E}$ denotes the closure of $E$).",
    "formal_statement": "theorem exercise_4_4a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (s : set \\u03b1)\\n (h\\u2081 : continuous f)\\n (h\\u2082 : dense s)\\n : f '' set.univ \\u2286 closure (f '' s)"
  },
  {
    "informal_statement": "is: The function of_real is the identity function on the reals.\"} {\"text\": \"variables (a b c d e : \\u2115)\\nvariable h1 : a = b\\nvariable h2 : b = c + 1\\nvariable h3 : c = d\\nvariable h4 : e = 1 + d\\n\\ninclude h1 h2 h3 h4\\ntheorem T : a = e :=\\n calc\\n a = d + 1 : by rw [h1, h2, h3]\\n ... = 1 + d : by rw add_comm\\n ... = e : by rw h4\\n\"} {\"text\": \"import \\n .lemmas.substitution\\n .lemmas.big_step\\n\\nopen env_big_step\\n\\nlemma big_subst_sound {E e S r} :\\n big_subst E e \\u27f9 r\\n \\u2192 (E, compile e, S) \\u27f9\\u2099\\u1d65 (E, r :: S) := \\nbegin\\n assume h,\\n induction' e,\\n case EVal {\\n rw compile,\\n rw big_subst_val at h,\\n cases' h,\\n apply ERunPush,\\n apply ERunEmpty\\n },\\n case EVar {\\n rw compile,\\n cases' big_subst_var_implies_bound h with v hbound,\\n apply ERunLookup hbound,\\n rw big_subst_bound_var hbound h,\\n exact ERunEmpty\\n },\\n case EOp {\\n rw compile, simp,\\n rw big_subst_spread_op at h,\\n cases' h,\\n apply from_interm_results' (ih_e_1 h_1),\\n apply from_interm_results' (ih_e h),\\n apply ERunOpInstr,\\n apply ERunEmpty\\n },\\n case EIf {\\n rw compile, simp,\\n rw big_subst_spread_if at h,\\n cases' h,\\n case RunIfT { \\n apply from_interm_results' (ih_e h),\\n apply ERunTBranch,\\n apply from_interm_results' (ih_e_1 h_1),\\n apply ERunJump,\\n exact at_least_refl,\\n rw list.drop_length,\\n apply ERunEmpty\\n },\\n case RunIfF {\\n apply from_interm_results' (ih_e h),\\n apply ERunFBranch,\\n { rw [at_least], simp },\\n rw [nat.add_comm, \\n list.drop_add, \\n list.drop_one,\\n list.drop_append_of_le_length, \\n list.drop_length,\\n list.nil_append, \\n list.tail],\\n exact ih_e_2 h_1,\\n refl\\n }\\n },\\n case ELet {\\n rw compile, simp,\\n rw big_subst_spread_let at h,\\n cases' h,\\n apply from_interm_results' (ih_e h),\\n apply ERunOpenScope,\\n rw [subst_merge, \\n big_subst_remove_append] at h_1,\\n apply from_interm_results' (ih_e_1 h_1),\\n apply ERunCloseScope,\\n apply ERunEmpty\\n }\\nend\\n\\ntheorem compile_sound_nv {e : exp} {v : val} :\\n e \\u27f9 v\\n \\u2192 ([], compile e, []) \\u27f9\\u2099\\u1d65 ([], [v]) :=\\n\\u03bb h, big_subst_sound $ eq.subst (big_subst_empty e) h\\n\\ntheorem compile_sound (e : exp) (v : val) : \\n e \\u27f9 v\\n \\u2192 ([], compile e, []) \\u27f9\\u1d65\\u2098 [v] :=\\nenv_vm_big_step \\u2218 compile_sound_nv\"} {\"text\": \"theory Rudin\\n imports Complex_Main (* comment by Angeliki: switched to Complex_Main and imported some Analysis*)\\n\\\"HOL-Analysis.Abstract_Euclidean_Space\\\"\\n\\\"HOL-Analysis.Derivative\\\"\\n\\\"HOL-Analysis.Interval_Integral\\\"\\n\\\"HOL-Analysis.Elementary_Topology\\\"\\n(*\\\"HOL-Hahn_Banach.Function_Order\\\"*)\\nbegin\\n\\n(*\\nproblem_number:1_1a\\nnatural language statement:\\nIf $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.\\nlean statement:\\ntheorem exercise_1_1a\\n (x : \\\\<real>) (y : \\\\<rat>) :\\n ( irrational x ) -> irrational ( x + y ) :=\\nbegin\\n apply irrational.add_rat,\\nend\\n\\ncodex statement:\\ntheorem irrational_of_add_irrational_rational:\\n fixes r :: real and x::real\\n assumes \\\"r \\\\<noteq> 0\\\" \\\"irrational x\\\"\\n shows \\\"irrational (r + x)\\\"\\n(*Our comment on the codex statement: <wrong: missed one assumption,so what it wants to \\nprove is false. Also used the def.\\n \\\"irrational\\\" which doesn't exist >*)\\n*) \\ntheorem exercise_1_1a: \\n fixes r :: rat and x::real\\n assumes \\\"r \\\\<noteq> 0\\\" \\\" x \\\\<notin> Rats\\\"\\n shows \\\" (r + x) \\\\<notin> Rats \\\"\\n oops\\n\\n\\n(*\\nproblem_number:1_1b\\nnatural language statement:\\nIf $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.\\nlean statement:\\ntheorem exercise_1_1b\\n(x : \\\\<real>)\\n(y : \\\\<rat>)\\n(h : y \\\\<noteq> 0)\\n: ( irrational x ) -> irrational ( x * y ) :=\\nbegin\\n intro g,\\n apply irrational.mul_rat g h,\\nend\\n\\ncodex statement:\\ntheorem irrational_of_rational_times_irrational:\\n fixes r::real and x::real\\n assumes \\\"r \\\\<noteq> 0\\\" \\\"irrational x\\\" \\\"rational r\\\"\\n shows \\\"irrational (r*x)\\\"\\nOur comment on the codex statement: < the mistake here is that it used the def \\\"irrational\\\" which\\ndoesn't exist in Isabelle>\\n *)\\ntheorem exercise_1_1b: \\n fixes r :: rat and x::real\\n assumes \\\"r \\\\<noteq> 0\\\" \\\" x \\\\<notin> Rats\\\"\\n shows \\\" r*x \\\\<notin> Rats \\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:1_2\\nnatural language statement:\\nProve that there is no rational number whose square is $12$.\\nlean statement:\\ntheorem exercise_1_2\\n: \\u00ac \\\\<exists> (x : \\\\<rat>), ( x ^ 2 = 12 ) :=\\n\\ncodex statement:\\ntheorem no_rational_square_eq_12:\\n assumes \\\"\\\\<exists>x. x^2 = 12\\\"\\n shows \\\"False\\\"\\nOur comment on the codex statement: <it didn't include the rationality assumption; \\nthe formalisation is wrong, plus the claim it presents is not true.>\\n *)\\ntheorem exercise_1_2: assumes \\\"\\\\<exists> x \\\\<in> Rats. x^2 = 12\\\"\\n shows False oops\\n\\n\\n(*\\nproblem_number:1_4\\nnatural language statement:\\nLet $E$ be a nonempty subset of an ordered set; suppose $\\\\alpha$ is a lower bound of $E$ and \\n$\\\\beta$ is an upper bound of $E$. Prove that $\\\\alpha \\\\leq \\\\beta$.\\nlean statement:\\ntheorem exercise_1_4\\n(\\\\<alpha> : Type* ) [partial_order \\\\<alpha>]\\n(s : set \\\\<alpha>)\\n(x y : \\\\<alpha>)\\n(h\\u2080 : set.nonempty s)\\n(h_1 : x \\\\<in> lower_bounds s)\\n(h_2 : y \\\\<in> upper_bounds s)\\n: x \\\\<le> y :=\\nbegin\\n have h : \\\\<exists> z, z \\\\<in> s := h\\u2080,\\n cases h with z,\\n have xlez : x \\\\<le> z :=\\n begin\\n apply h_1,\\n assumption,\\n end,\\n have zley : z \\\\<le> y :=\\n begin\\n apply h_2,\\n assumption,\\n end,\\n exact xlez.trans zley,\\nend\\n\\ncodex statement:\\ntheorem lower_bound_leq_upper_bound:\\n fixes E::\\\"'a::linorder set\\\"\\n assumes \\\"E \\\\<noteq> {}\\\" \\\"\\\\<forall>x\\\\<in>E. \\\\<alpha> \\\\<le> x\\\" \\\"\\\\<forall>x\\\\<in>E. x \\\\<le> \\u03b2\\\"\\n shows \\\"\\\\<alpha> \\\\<le> \\u03b2\\\"\\n \\nOur comment on the codex statement: <correct formalisation! I copy-paste it below.>\\n *)\\n\\ntheorem exercise_1_4: fixes E::\\\"'a::linorder set\\\"\\n assumes \\\"E \\\\<noteq> {}\\\" \\\"\\\\<forall>x\\\\<in>E. \\\\<alpha> \\\\<le> x\\\" \\\"\\\\<forall>x\\\\<in>E. x \\\\<le> \\\\<beta>\\\"\\n shows \\\"\\\\<alpha> \\\\<le> \\\\<beta>\\\"\\n oops\\n\\n(*\\n\\nproblem_number:1_5\\nnatural language statement:\\nLet $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all \\nnumbers $-x$, where $x \\\\in A$. Prove that $\\\\inf A=-\\\\sup (-A)$.\\nlean statement:\\ntheorem exercise_1_5\\n (A minus_A : set \\\\<real>) (hA : A.nonempty) (hA_bdd_below : bdd_below A)\\n (hminus_A : minus_A = {x | -x \\\\<in> A}) :\\n Inf A = Sup minus_A :=\\n\\ncodex statement:\\ntheorem inf_of_neg_sup_of_neg:\\n fixes A::\\\"real set\\\"\\n assumes \\\"bdd_below A\\\" \\\"A \\\\<noteq> {}\\\"\\n shows \\\"Inf A = - Sup (-A)\\\"\\nOur comment on the codex statement: < chosen notation is wrong: -A denotes\\nthe complement of A >\\n*) \\n\\ntheorem exercise_1_5: fixes A::\\\"real set\\\" and minusA::\\\"real set\\\" \\n assumes \\\"bdd_below A\\\" \\\"A \\\\<noteq> {}\\\" and \\\" minusA = {x. -x \\\\<in> A}\\\"\\n shows \\\"Inf A = - Sup (minusA)\\\"\\n\\n\\n oops\\n\\n\\n(*\\nproblem_number:1_8\\nnatural language statement:\\nProve that no order can be defined in the complex field that turns it into an ordered field. \\nHint: $-1$ is a square.\\nlean statement:\\ntheorem exercise_1_8\\n : \\u00ac \\\\<exists> (r : \\\\<complex> \\\\<rightarrow> \\\\<complex> \\\\<rightarrow> Prop), is_linear_order \\\\<complex> r :=\\n\\ncodex statement:\\ntheorem no_order_in_complex_field:\\n fixes z::complex\\n assumes \\\"\\\\<forall>x y. x \\\\<le> y \\\\<longrightarrow> x + z \\\\<le> y + z\\\" \\n\\\"\\\\<forall>x y. x \\\\<le> y \\\\<longrightarrow> x * z \\\\<le> y * z\\\" \\\"\\\\<forall>x. x \\\\<le> x\\\" \\n\\\"\\\\<forall>x y. x \\\\<le> y \\\\<longrightarrow> y \\\\<le> x \\\\<longrightarrow> x = y\\\" \\n\\\"\\\\<forall>x y z. x \\\\<le> y \\\\<longrightarrow> x + z \\\\<le> y + z\\\" \\\"\\\\<forall>x y. x \\\\<le> y \\\\<longrightarrow> x * y \\\\<le> y * x\\\" \\n\\\"\\\\<forall>x y z. x \\\\<le> y \\\\<longrightarrow> x * (y + z) \\\\<le> x * y + x * z\\\" \\\"\\\\<exists>x. x < x\\\"\\n shows False\\nOur comment on the codex statement: < overall wrong>\\n\\n*)\\n\\ntheorem exercise_1_8:\\n fixes C:: \\\"complex set\\\"\\n shows \\\"\\\\<not> (\\\\<exists> r. linear_order_on C r)\\\" \\n \\n oops\\n\\n\\n(*\\nproblem_number:1_17\\nnatural language statement:\\nProve that $|\\\\mathbf{x}+\\\\mathbf{y}|^{2}+|\\\\mathbf{x}-\\\\mathbf{y}|^{2}=2|\\\\mathbf{x}|^{2}+2|\\\\mathbf{y}|^{2}$ \\nif $\\\\mathbf{x} \\\\in R^{k}$ and $\\\\mathbf{y} \\\\in R^{k}$.\\nlean statement:\\nexercise_1_17\\n(n : \\u2115)\\n(x y : euclidean_space \\u211d (fin n)) -- R^n\\n: \\u2225x + y\\u2225^2 + \\u2225x - y\\u2225^2 = 2*\\u2225x\\u2225^2 + 2*\\u2225y\\u2225^2 :\\ncodex statement:\\ntheorem sum_add_square_sub_square_eq_sum_square:\\n fixes x y::\\\"'a::euclidean_space\\\" \\n shows \\\"norm (x+y)^2 + norm (x - y) ^ 2 = 2 * (norm x)^2 + 2* (norm y)^2\\\"\\n\\n\\nOur comment on the codex statement: < correct,I copy-paste it below >\\n *)\\n\\ntheorem exercise_1_17:\\n fixes x y::\\\"'a::euclidean_space\\\"\\n shows \\\"norm (x+y)^2 + norm (x - y) ^ 2 = 2 * (norm x)^2 + 2* (norm y)^2\\\"\\n\\n oops\\n(*\\nproblem_number:1_14\\nnatural language statement:\\nIf $z$ is a complex number such that $|z|=1$, that is, such that $z \\\\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.\\nlean statement:\\ntheorem exercise_1_14\\n (z : \\\\<complex>) (h : abs z = 1)\\n : (abs (1 + z)) ^ 2 + (abs (1 - z)) ^ 2 = 4 :=\\n\\ncodex statement:\\ntheorem sum_square_of_sum_sub_of_abs_eq_one:\\n fixes z::complex\\n assumes \\\"norm z = 1\\\"\\n shows \\\"norm (1 + z)^2 + norm (1 - z)^2 = 4\\\"\\nOur comment on the codex statement: <Unsure how to compare: the natural language version says\\n\\\"compute\\\" without giving the answer, both the formalised and codex-autoformalised versions\\ngive the answer and ask for proving what it is. The extra hint \\\"that is, such that $z \\\\bar{z}=1$\\\" did not need to\\nbe formalised and wasn't autoformalised either. The autoformalisation is correct, I copy-paste it below. >\\n *)\\ntheorem exercise_1_14: \\n fixes z::complex\\n assumes \\\"norm z = 1\\\"\\n shows \\\"norm (1 + z)^2 + norm (1 - z)^2 = 4\\\" \\n oops\\n\\n\\n(*\\nproblem_number:1_18a\\nnatural language statement:\\nIf $k \\\\geq 2$ and $\\\\mathbf{x} \\\\in R^{k}$, prove that \\nthere exists $\\\\mathbf{y} \\\\in R^{k}$ such that $\\\\mathbf{y} \\\\neq 0$ but $\\\\mathbf{x} \\\\cdot \\\\mathbf{y}=0$\\nlean statement:\\ntheorem exercise_1_18a\\n (n : \\\\<nat>)\\n (h : n > 1)\\n (x : euclidean_space \\\\<real> (fin n)) -- R^n\\n : \\\\<exists> (y : euclidean_space \\\\<real> (fin n)), y \\\\<noteq> 0 \\\\<and> (inner x y) = (0 : \\\\<real>) :=\\n\\ncodex statement:\\ntheorem exists_nonzero_orthogonal_vector:\\n fixes x::\\\"'a::euclidean_space\\\"\\n assumes \\\"k\\\\<ge>2\\\"\\n shows \\\"\\\\<exists>y. y \\\\<noteq> 0 \\\\<and> x \\u22c5 y = 0\\\"\\nOur comment on the codex statement: < missed the assumption that k is the dimension\\nand had wrong inner product symbol>\\n *) \\ntheorem exercise_1_18a:\\n fixes x::\\\"'a::euclidean_space\\\"\\n assumes \\\" DIM('a::euclidean_space) \\\\<ge> 2\\\"\\n shows \\\"\\\\<exists>y. y \\\\<noteq> 0 \\\\<and> inner x y = 0\\\" \\n \\n oops\\n\\n\\n(*\\nproblem_number:1_25\\nnatural language statement:\\n25: Prove that every compact metric space $K$ has a countable base.\\nlean statement:\\nMISSING\\ncodex statement:\\n\\ntheorem compact_metric_space_has_countable_base:\\n fixes K::\\\"'a::metric_space set\\\"\\n assumes \\\"compact K\\\"\\n shows \\\"countable (UNIV::'a set)\\\"\\n\\n\\nOur comment on the codex statement: <wrong conclusion>\\n\\n*)\\ntheorem exercise_1_25:\\n \\n fixes K::\\\"'a::metric_space set\\\"\\n assumes \\\"compact K\\\" \\n shows \\n \\\"\\\\<exists> B. (countable B) \\\\<and> (topological_basis B)\\n \\\\<and> (\\\\<forall> b\\\\<in> B. b \\\\<subseteq> K)\\\"\\n oops\\n\\n(* TODO CHECK THE ABOVE *)\\n\\n(*\\nproblem_number:1_27a\\nnatural language statement:\\n27a: Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set \\nof condensation points of $E$. Prove that $P$ is perfect.\\nlean statement:\\n\\ncodex statement:\\ntheorem perfect_of_uncountable_condensation_points:\\n fixes E::\\\"'a::euclidean_space set\\\"\\n assumes \\\"uncountable E\\\" \\\"P = condensation_points E\\\"\\n shows \\\"perfect P\\\"\\nOur comment on the codex statement: <makes up definitions that don't exist in Isabelle,\\n(perfect which doesn't work for perfect set, condensation_points). >\\n*)\\n\\ntheorem exercise_1_27a:\\nundefined \\n\\n(*shows \\\" P= {x. x islimpt P}\\\"*) \\n oops (* TODO note the def: If every neighbourhood of x contains uncountably many points of \\nS, then x is a type of limit point called a condensation point of S. *)\\n\\n(*\\nproblem_number:1_27b\\nnatural language statement:\\n27b: Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. \\nProve that at most countably many point of $E$ are not in $P$.\\nlean statement:\\nMISSING\\ncodex statement:\\ntheorem countable_of_uncountable_set_of_condensation_points:\\n fixes E::\\\"'a::euclidean_space set\\\"\\n assumes \\\"uncountable E\\\"\\n shows \\\"countable {x\\\\<in>E. x\\\\<notin>condensation_points E}\\\"\\nOur comment on the codex statement: < uses nonexistent\\nIsabelle definitions (condensation_points) otherwise correct\\n>\\n *)\\ntheorem exercise_1_27b: \\n undefined oops\\n\\n\\n(*\\nproblem_number:1_28\\nnatural language statement:\\nProve that every closed set in a separable metric space is the union of a \\n(possibly empty) perfect set and a set which is at most countable.\\nlean statement:\\nMISSING\\ncodex statement:\\ntheorem closed_set_union_perfect_set_countable_set:\\n fixes X::\\\"'a::metric_space set\\\"\\n assumes \\\"separable X\\\" \\\"closed X\\\"\\n shows \\\"\\\\<exists>P C. perfect P \\\\<and> countable C \\\\<and> X = P \\u222a C\\\"\\nOur comment on the codex statement: <uses nonexistent Isabelle definitions (perfect which\\ndoesn't work for perfect set, separable)> *)\\n\\ntheorem exercise_1_28:\\n\\n fixes X::\\\"'a::metric_space set\\\" \\n assumes \\\"\\\\<exists> T \\u2286 X . countable T \\\\<and> X \\u2286 closure T\\\" \\\"closed S\\\" and \\\"S \\\\<subseteq> X\\\"\\n shows \\\"\\\\<exists> P C. countable C \\\\<and> P = {x \\\\<in> P. x islimpt P} \\\\<and> S = P \\u222a C \\\"\\n\\n oops\\n\\n\\n\\n\\n\\n(*\\nproblem_number:1_29\\nnatural language statement:\\nProve that every open set in $\\\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.\\nlean statement:\\nMISSING\\ncodex statement:\\ntheorem open_set_union_of_countable_disjoint_segments:\\n fixes A::\\\"real set\\\"\\n assumes \\\"open A\\\"\\n\\n shows \\\"\\\\<exists>f. countable (f ` (UNIV::nat set)) \\\\<and> pairwise disjoint (f ` (UNIV::nat set)) \\n\\\\<and> (\\\\<Union>i\\\\<in>UNIV. f i) = A\\\"\\nOur comment on the codex statement: <wrong >\\n\\n *)\\ntheorem exercise_1_29: \\n undefined oops\\n\\n\\n(*\\nproblem_number:2_19a\\nnatural language statement:\\nIf $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.\\nlean statement:\\ntheorem exercise_2_19a {X : Type*} [metric_space X]\\n (A B : set X) (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\\n separated_nhds A B :=\\n\\ncodex statement:\\ntheorem separated_of_disjoint_closed:\\n fixes A B::\\\"'a::metric_space set\\\"\\n assumes \\\"closed A\\\" \\\"closed B\\\" \\\"A \\u2229 B = {}\\\"\\n shows \\\"separated A B\\\"\\nOur comment on the codex statement: < Almost correct: used nonexistent Isabelle definition\\n(separated)> *)\\ntheorem exercise_2_19a:\\n \\n fixes A B::\\\"'a::metric_space set\\\"\\n assumes \\\"closed A\\\" \\\"closed B\\\" \\\"A \\u2229 B = {}\\\" \\\"A \\u2286 topspace X\\\"\\n \\\"B \\u2286 topspace X\\\"\\n shows \\\"separatedin X A B\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:2_24\\nnatural language statement:\\nLet $X$ be a metric space in which every infinite subset has a limit point.\\n Prove that $X$ is separable. Hint: Fix $\\\\delta>0$, and pick $x_{1} \\\\in X$. \\nHaving chosen $x_{1}, \\\\ldots, x_{J} \\\\in X$,\\nlean statement:\\ntheorem exercise_2_24 {X : Type*} [metric_space X]\\n (hX : \\\\<forall> (A : set X), infinite A \\\\<rightarrow> \\\\<exists> (x : X), x \\\\<in> closure A) :\\n separable_space X :=\\n\\ncodex statement:\\ntheorem separable_of_infinite_subset_has_limit_point:\\n fixes X::\\\"'a::metric_space set\\\"\\n assumes \\n\\\"\\\\<forall>A. infinite A \\\\<longrightarrow> \\n\\\\<exists>x\\\\<in>A. \\\\<forall>\\\\<epsilon>>0. \\\\<exists>y\\\\<in>A. y\\\\<noteq>x \\\\<and> dist x y < \\\\<epsilon>\\\"\\n shows \\\"separable X\\\"\\nOur comment on the codex statement: <uses nonexistent Isabelle definition (separable), \\nsyntax error due to not including expression in parenthesis, missed that\\nA \\\\<subseteq> X in assumption, missed the Isabelle limit point definition>\\n *)\\ntheorem exercise_2_24:\\n \\n fixes X::\\\"'a::metric_space set\\\"\\n assumes \\\"\\\\<forall>A \\\\<subseteq> X. infinite A \\\\<longrightarrow>\\n( \\\\<exists>x\\\\<in>A. x islimpt A )\\\"\\n obtains T where \\\"countable T\\\" \\\"T \\u2286 X\\\" \\\"X \\u2286 closure T\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:3_1a\\nnatural language statement:\\nProve that convergence of $\\\\left\\\\{s_{n}\\\\right\\\\}$ implies convergence of $\\\\left\\\\{\\\\left|s_{n}\\\\right|\\\\right\\\\}$.\\nlean statement: \\ntheorem exercise_3_1a\\n (f : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (h : \\\\<exists> (a : \\\\<real>), tendsto (\\\\<lambda> (n : \\\\<nat>), f n) at_top (\\ud835\\udcdd a))\\n : \\\\<exists> (a : \\\\<real>), tendsto (\\\\<lambda> (n : \\\\<nat>), |f n|) at_top (\\ud835\\udcdd a) :=\\nbegin\\n cases h with a h,\\n use |a|,\\n apply filter.tendsto.abs h,\\nend\\n\\ncodex statement:\\ntheorem convergent_of_convergent_abs:\\n fixes s::\\\"nat \\\\<Rightarrow> 'a::real_normed_vector\\\"\\n assumes \\\"convergent s\\\"\\n shows \\\"convergent (\\\\<lambda>n. norm (s n))\\\"\\nOur comment on the codex statement: < correct, copy-pasted below>\\n *)\\ntheorem exercise_3_1a:\\n fixes s::\\\"nat \\\\<Rightarrow> 'a::real_normed_vector\\\"\\n assumes \\\"convergent s\\\"\\n shows \\\"convergent (\\\\<lambda>n. norm (s n))\\\"\\noops\\n\\n\\n(*\\nproblem_number:3_3\\nnatural language statement:\\nIf $s_{1}=\\\\sqrt{2}$, and $s_{n+1}=\\\\sqrt{2+\\\\sqrt{s_{n}}} \\\\quad(n=1,2,3, \\\\ldots),$ \\nprove that $\\\\left\\\\{s_{n}\\\\right\\\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\\\ldots$.\\nlean statement:\\ntheorem exercise_3_3\\n : \\\\<exists> (x : \\\\<real>), tendsto f at_top (\\ud835\\udcdd x) \\\\<and> \\\\<forall> n, f n < 2 :=\\n\\ncodex statement:\\ntheorem sqrt_2_lt_2_of_sqrt_2_plus_sqrt_s_n:\\n fixes s::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"s 1 = sqrt 2\\\" \\\"\\\\<forall>n. s (n+1) = sqrt (2 + sqrt (s n))\\\"\\n shows \\\"\\\\<forall>n. s n < 2\\\"\\nOur comment on the codex statement: < missed one of the conclusions to be shown, otherwise ok>\\n *)\\ntheorem exercise_3_3:\\n \\n fixes s::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"s 1 = sqrt 2\\\" \\\"\\\\<forall>n. s (n+1) = sqrt (2 + sqrt (s n))\\\"\\n shows \\\"convergent s \\\" and \\\"\\\\<forall>n. s n < 2\\\"\\n oops\\n\\n\\n(*\\nproblem_number:3_5\\nnatural language statement:\\nFor any two real sequences $\\\\left\\\\{a_{n}\\\\right\\\\},\\\\left\\\\{b_{n}\\\\right\\\\}$, \\nprove that $\\\\limsup _{n \\\\rightarrow \\\\infty}\\\\left(a_{n}+b_{n}\\\\right) \\\\leq \\n\\\\limsup _{n \\\\rightarrow \\\\infty} a_{n}+\\\\limsup _{n \\\\rightarrow \\\\infty} b_{n},$ \\nprovided the sum on the right is not of the form $\\\\infty-\\\\infty$.\\nlean statement:\\ntheorem exercise_3_5 -- TODO fix\\n (a b : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (h : limsup a + limsup b \\\\<noteq> 0) :\\n limsup (\\\\<lambda> n, a n + b n) \\\\<le> limsup a + limsup b :=\\n\\ncodex statement:\\ntheorem limsup_sum_leq_sum_limsup:\\n fixes a b::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>n. a n \\\\<le> b n\\\"\\n shows \\\"limsup (\\\\<lambda>n. a n + b n) \\\\<le> limsup a + limsup b\\\"\\nOur comment on the codex statement: < not sure about the natural language statement here \\n(* TODO check *)\\ncodex is wrong as it's adding nonexistent \\\\<le> assumption > \\n *)\\ntheorem exercise_3_5: \\n fixes a b::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"convergent a\\\" and \\\"convergent b \\\"\\n shows \\\"limsup (\\\\<lambda>n. \\u00a6 a n + b n\\u00a6) \\\\<le> limsup a + limsup b\\\" oops \\n\\n(*\\nproblem_number:3_7\\nnatural language statement:\\nProve that the convergence of $\\\\Sigma a_{n}$ implies the convergence of $\\\\sum \\\\frac{\\\\sqrt{a_{n}}}{n}$ if $a_n\\\\geq 0$.\\nlean statement:\\ntheorem exercise_3_7\\n (a : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (h : \\\\<exists> y, (tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), a i)) at_top (\\ud835\\udcdd y))) :\\n \\\\<exists> y, tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), sqrt (a i) / n)) at_top (\\ud835\\udcdd y) :=\\n\\ncodex statement:\\ntheorem sum_sqrt_div_n_converges_of_sum_converges:\\n fixes a::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"summable a\\\" \\\"\\\\<forall>n. a n \\\\<ge> 0\\\"\\n shows \\\"summable (\\\\<lambda>n. sqrt (a n) / n)\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below. Note that the natural\\nlanguage statement features both \\\\Sigma and \\\\sum.>\\n *)\\ntheorem exercise_3_7: \\n \\n fixes a::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"summable a\\\" \\\"\\\\<forall>n. a n \\\\<ge> 0\\\"\\n shows \\\"summable (\\\\<lambda>n. sqrt (a n) / n)\\\" \\n oops\\n\\n\\n(*\\nproblem_number:3_8\\nnatural language statement:\\nIf $\\\\Sigma a_{n}$ converges, and if $\\\\left\\\\{b_{n}\\\\right\\\\}$ \\nis monotonic and bounded, prove that $\\\\Sigma a_{n} b_{n}$ converges.\\nlean statement:\\ntheorem exercise_3_8\\n (a b : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (h1 : \\\\<exists> y, (tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), a i)) at_top (\\ud835\\udcdd y)))\\n (h2 : monotone b)\\n (h3 : metric.bounded (set.range b)) :\\n \\\\<exists> y, tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), (a i) * (b i))) at_top (\\ud835\\udcdd y) :=\\n\\ncodex statement:\\ntheorem convergent_of_convergent_and_monotonic_bounded:\\n fixes a::\\\"nat \\\\<Rightarrow> real\\\" and b::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"convergent a\\\" \\\"bounded (range b)\\\" \\\"mono b\\\"\\n shows \\\"convergent (\\\\<lambda>n. a n * b n)\\\"\\nOur comment on the codex statement: < the mistake is that here it is meant summable by \\\\Sigma, \\nso it should not be translated as convergent>\\n *)\\ntheorem exercise_3_8: \\n fixes a::\\\"nat \\\\<Rightarrow> real\\\" and b::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"summable a \\\" \\\"bounded (range b)\\\" \\\"mono b\\\"\\n shows \\\"summable (\\\\<lambda>n. a n * b n)\\\"\\n oops\\n\\n\\n(*\\nproblem_number:3_13\\nnatural language statement:\\nProve that the Cauchy product of two absolutely convergent series converges absolutely.\\nlean statement: \\ntheorem exercise_3_13\\n (a b : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (ha : \\\\<exists> y, (tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), |a i|)) at_top (\\ud835\\udcdd y)))\\n (hb : \\\\<exists> y, (tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n), |b i|)) at_top (\\ud835\\udcdd y))) :\\n \\\\<exists> y, (tendsto (\\\\<lambda> n, (\\\\<Sum> i in (finset.range n),\\n \\\\<lambda> i, (\\\\<Sum> j in finset.range (i + 1), a j * b (i - j)))) at_top (\\ud835\\udcdd y)) :=\\n\\ncodex statement:\\ntheorem abs_convergent_of_cauchy_product:\\n fixes f g::\\\"nat \\\\<Rightarrow> 'a::real_normed_algebra_1\\\"\\n assumes \\\"summable (\\\\<lambda>n. abs (f n))\\\" \\\"summable (\\\\<lambda>n. abs (g n))\\\"\\n shows \\\"summable (\\\\<lambda>n. abs (\\\\<Sum>i<n. f i * g (n - i)))\\\"\\nOur comment on the codex statement: < mistake in type: should be real instead of real_normed_algebra_1.\\nOtherwise impressive> *)\\n\\ntheorem exercise_3_13:\\n fixes f g::\\\"nat \\\\<Rightarrow> real\\\"\\n assumes \\\"summable (\\\\<lambda>n. abs (f n))\\\" \\\"summable (\\\\<lambda>n. abs (g n))\\\"\\n shows \\\"summable (\\\\<lambda>n. abs (\\\\<Sum>i<n. f i * g (n - i)))\\\"\\n\\n oops\\n\\n\\n(*\\nproblem_number:3_20\\nnatural language statement:\\nSuppose $\\\\left\\\\{p_{n}\\\\right\\\\}$ is a Cauchy sequence in a metric space $X$, \\nand some sequence $\\\\left\\\\{p_{n l}\\\\right\\\\}$ converges to a point $p \\\\in X$.\\n Prove that the full sequence $\\\\left\\\\{p_{n}\\\\right\\\\}$ converges to $p$.\\nlean statement:\\ntheorem exercise_3_20 {X : Type*} [metric_space X]\\n (p : \\\\<nat> \\\\<rightarrow> X) (l : \\\\<nat>) (r : X)\\n (hp : cauchy_seq p)\\n (hpl : tendsto (\\\\<lambda> n, p (l * n)) at_top (\\ud835\\udcdd r)) :\\n tendsto p at_top (\\ud835\\udcdd r) :=\\n\\ncodex statement:\\ntheorem convergent_of_subseq_convergent:\\n fixes X::\\\"'a::metric_space\\\" and p::\\\"'a\\\" and pn::\\\"nat \\\\<Rightarrow> 'a\\\"\\n assumes \\\"Cauchy pn\\\" \\\"convergent (\\\\<lambda>n. pn (n l))\\\" \\\"\\\\<forall>n. pn (n l) \\\\<longrightarrow> p\\\"\\n shows \\\"pn \\\\<longrightarrow> p\\\"\\nOur comment on the codex statement: < close but wrong>\\n *)\\n\\ntheorem exercise_3_20:\\n\\n fixes X::\\\"'a::metric_space\\\" and p::\\\"'a\\\" and pn::\\\"nat \\\\<Rightarrow> 'a\\\"\\n assumes \\\"Cauchy pn\\\" and \\\" ((\\u03bbl. pn(n l)) \\u290f p) sequentially\\\"\\nshows \\\" ((\\u03bbn. pn(n )) \\u290f p) sequentially\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:3_21\\nnatural language statement:\\nIf $\\\\left\\\\{E_{n}\\\\right\\\\}$ is a sequence of closed nonempty and bounded sets in a complete metric \\nspace $X$, if $E_{n} \\\\supset E_{n+1}$, \\nand if $\\\\lim _{n \\\\rightarrow \\\\infty} \\\\operatorname{diam} E_{n}=0,$ \\nthen $\\\\bigcap_{1}^{\\\\infty} E_{n}$ consists of exactly one point.\\nlean statement:\\ntheorem exercise_3_21\\n {X : Type*} [metric_space X] [complete_space X]\\n (E : \\\\<nat> \\\\<rightarrow> set X)\\n (hE : \\\\<forall> n, E n \\u2283 E (n + 1))\\n (hE' : tendsto (\\\\<lambda> n, metric.diam (E n)) at_top (\\ud835\\udcdd 0)) :\\n \\\\<exists> a, set.Inter E = {a} :=\\n\\ncodex statement:\\ntheorem singleton_of_closed_nonempty_bounded_diam_zero:\\n fixes X::\\\"'a::metric_space set\\\"\\n assumes \\\"\\\\<forall>n. closed (E n)\\\" \\\"\\\\<forall>n. E n \\\\<noteq> {}\\\" \\\"\\\\<forall>n. bounded (E n)\\\" \\n\\\"\\\\<forall>n. E n \\\\<subseteq> E (n+1)\\\" \\\"diameter (E n) \\\\<longrightarrow> 0\\\"\\n shows \\\"\\\\<exists>x. (\\u2229n. E n) = {x}\\\"\\nOur comment on the codex statement: <several mistakes: symbols, misses assumptions, uses\\nsubset instead of superset>\\n *)\\ntheorem exercise_3_21:\\n\\nfixes X::\\\"'a::metric_space set\\\" and E:: \\\" nat \\\\<Rightarrow> 'a set\\\"\\n\\nassumes \\\"\\\\<forall>n. closed (E n)\\\" \\\"complete X\\\" \\\"\\\\<forall>n. E n \\\\<noteq> {}\\\" \\n\\\"\\\\<forall>n. bounded (E n)\\\" \\n\\\"\\\\<forall>n. E n \\\\<supset> E (n+1)\\\" \\\"((\\u03bbn. diameter (E n)) \\u290f 0) sequentially\\\"\\nshows\\n \\\" \\\\<exists> x. ((\\\\<Inter>n\\\\<in> \\\\<nat>. E n) ={x})\\\"\\n \\n \\n oops\\n\\n\\n(*\\nproblem_number:3_22\\nnatural language statement:\\nSuppose $X$ is a nonempty complete metric space, \\nand $\\\\left\\\\{G_{n}\\\\right\\\\}$ is a sequence of dense open sets of $X$. \\nProve Baire's theorem, namely, that $\\\\bigcap_{1}^{\\\\infty} G_{n}$ is not empty.\\nlean statement:\\ntheorem exercise_3_22 (X : Type* ) [metric_space X] [complete_space X]\\n (G : \\\\<nat> \\\\<rightarrow> set X) (hG : \\\\<forall> n, is_open (G n) \\\\<and> dense (G n)) :\\n \\\\<exists> x, \\\\<forall> n, x \\\\<in> G n :=\\n\\ncodex statement:\\ntheorem baire_theorem:\\n fixes X::\\\"'a::metric_space set\\\" and G::\\\"'a set set\\\"\\n assumes \\\"complete_space X\\\" \\\"\\\\<forall>n. openin (subtopology X UNIV) (G n)\\\" \\\"\\n\\\\<forall>n. dense_in (subtopology X UNIV) (G n)\\\"\\n shows \\\"\\\\<exists>x. \\\\<forall>n. x\\\\<in>G n\\\"\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE >\\n *)\\n\\n\\ntheorem exercise_3_22: \\n \\n undefined\\n \\n oops\\n\\n(*\\nproblem_number:4_2a\\nnatural language statement:\\nIf $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that \\n$f(\\\\overline{E}) \\\\subset \\\\overline{f(E)}$ for every set $E \\\\subset X$. ($\\\\overline{E}$ denotes the closure of $E$).\\nlean statement:\\ntheorem exercise_4_2a\\n {\\\\<alpha> : Type} [metric_space \\\\<alpha>]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\\\<alpha> \\\\<rightarrow> \\u03b2)\\n (h_1 : continuous f)\\n : \\\\<forall> (x : set \\\\<alpha>), f '' (closure x) \\\\<subseteq> closure (f '' x) :=\\nbegin\\n intros X x h_2 Y h\\u2083,\\n simp at *,\\n cases h\\u2083 with h\\u2083 h\\u2084,\\n cases h_2 with w h\\u2085,\\n cases h\\u2085 with h\\u2085 h\\u2086,\\n have h\\u2088 : is_closed (f \\u207b\\u00b9' Y) := is_closed.preimage h_1 h\\u2083,\\n have h\\u2089 : closure X \\\\<subseteq> f \\u207b\\u00b9' Y := closure_minimal h\\u2084 h\\u2088,\\n rw \\u2190h\\u2086,\\n exact h\\u2089 h\\u2085,\\nend\\n\\ncodex statement:\\ntheorem closure_of_continuous_image_subset_continuous_image_closure:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and E::\\\"'a set\\\"\\n assumes \\\"continuous_on UNIV f\\\"\\n shows \\\"closure (f ` E) \\\\<subseteq> f ` closure E\\\"\\nOur comment on the codex statement: <shows the opposite (wrong) inclusion >\\n *)\\ntheorem exercise_4_2a:\\n \\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and E::\\\"'a set\\\"\\n assumes \\\"continuous_on UNIV f\\\"\\n shows \\\" f ` ( closure E) \\\\<subseteq> closure (f ` E)\\\" \\n oops\\n\\n\\n(*\\nproblem_number:4_3\\nnatural language statement:\\nLet $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) \\nbe the set of all $p \\\\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.\\nlean statement:\\ntheorem exercise_4_3\\n {\\\\<alpha> : Type} [metric_space \\\\<alpha>]\\n (f : \\\\<alpha> \\\\<rightarrow> \\\\<real>) (h : continuous f) (z : set \\\\<alpha>) (g : z = inv f' {0})\\n : is_closed z :=\\nbegin\\n rw g,\\n apply is_closed.preimage h,\\n exact is_closed_singleton,\\nend\\n\\ncodex statement:\\ntheorem zero_set_of_continuous_is_closed:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on UNIV f\\\"\\n shows \\\"closed {x\\\\<in>UNIV. f x = 0}\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below>\\n *)\\ntheorem exercise_4_3:\\n \\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on UNIV f\\\"\\n shows \\\"closed {x\\\\<in>UNIV. f x = 0}\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:4_4a\\nnatural language statement:\\nLet $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, \\nand let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.\\nlean statement:\\ntheorem exercise_4_4a\\n {\\\\<alpha> : Type} [metric_space \\\\<alpha>]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\\\<alpha> \\\\<rightarrow> \\u03b2)\\n (s : set \\\\<alpha>)\\n (h_1 : continuous f)\\n (h_2 : dense s)\\n : f '' set.univ \\\\<subseteq> closure (f '' s) :=\\nbegin\\n simp,\\n exact continuous.range_subset_closure_image_dense h_1 h_2,\\nend\\n\\ncodex statement:\\ntheorem dense_of_continuous_dense:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and \\ng::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\"\\n assumes \\\"continuous_on UNIV f\\\" \\\"continuous_on UNIV g\\\" \\\"dense (f ` UNIV)\\\" \\\"dense (g ` UNIV)\\\"\\n shows \\\"dense ((f \\u2218 g) ` UNIV)\\\"\\nOur comment on the codex statement: <wrong: missing assumptions, wrong statement to show,\\nuses nonexistent definition>\\n *)\\ntheorem exercise_4_4a: \\n \\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" \\nand g::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and E::\\\"'a set\\\"\\nassumes \\\" closure E = UNIV\\\"\\n\\\"continuous_on UNIV f\\\" \\\"continuous_on UNIV g\\\"\\nshows \\\"closure( f ` E) = ( f ` UNIV) \\\"\\n \\n oops\\n\\n(* TODO In the natural language statement above, why is g introduced? something to check?*)\\n\\n(*\\nproblem_number:4_5a\\nnatural language statement:\\nIf $f$ is a real continuous function defined on a closed set $E \\\\subset R^{1}$, \\nprove that there exist continuous real functions $g$ on $R^{1}$ such that $g(x)=f(x)$ for all $x \\\\in E$.\\nlean statement:\\ntheorem exercise_4_5a\\n (f : \\\\<real> \\\\<rightarrow> \\\\<real>)\\n (E : set \\\\<real>)\\n (h_1 : is_closed E)\\n (h_2 : continuous_on f E)\\n : \\\\<exists> (g : \\\\<real> \\\\<rightarrow> \\\\<real>), continuous g \\\\<and> \\\\<forall> x \\\\<in> E, f x = g x :=\\n\\ncodex statement:\\ntheorem exists_continuous_extension:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and E::\\\"real set\\\"\\n assumes \\\"continuous_on E f\\\" \\\"closed E\\\"\\n shows \\\"\\\\<exists>g. continuous_on UNIV g \\\\<and> (\\\\<forall>x\\\\<in>E. g x = f x)\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below>\\n *)\\ntheorem exercise_4_5a:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and E::\\\"real set\\\"\\n assumes \\\"continuous_on E f\\\" \\\"closed E\\\"\\n shows \\\"\\\\<exists>g. continuous_on UNIV g \\\\<and> (\\\\<forall>x\\\\<in>E. g x = f x)\\\"\\n oops\\n\\n\\n(*\\nproblem_number:4_6\\nnatural language statement:\\nIf $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, \\nfor $x \\\\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, \\nthe graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is \\ncontinuous on $E$ if and only if its graph is compact.\\nlean statement:\\ntheorem exercise_4_6\\n (f : \\\\<real> \\\\<rightarrow> \\\\<real>)\\n (E : set \\\\<real>)\\n (G : set (\\\\<real> \\\\<times> \\\\<real>))\\n (h_1 : is_compact E)\\n (h_2 : G = {(x, f x) | x \\\\<in> E})\\n : continuous_on f E \\\\<longleftrightarrow> is_compact G :=\\n\\ncodex statement:\\ntheorem compact_of_continuous_graph:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and E::\\\"'a::metric_space set\\\"\\n assumes \\\"compact E\\\" \\\"continuous_on E f\\\"\\n shows \\\"compact {(x, f x) | x. x \\\\<in> E}\\\"\\nOur comment on the codex statement: < missed the double implication but otherwise correct>\\n *)\\ntheorem exercise_4_6: fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" \\nand E::\\\"'a::metric_space set\\\" \\nassumes \\\"compact E\\\"\\nshows \\\"continuous_on E f \\\\<longleftrightarrow> compact {(x, f x) | x. x \\\\<in> E} \\\" oops\\n\\n(*\\nproblem_number:4_8a\\nnatural language statement:\\nLet $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. \\nProve that $f$ is bounded on $E$.\\nlean statement:\\ntheorem exercise_4_8a\\n (E : set \\\\<real>) (f : \\\\<real> \\\\<rightarrow> \\\\<real>) (hf : uniform_continuous_on f E)\\n (hE : metric.bounded E) : metric.bounded (set.image f E) :=\\n\\ncodex statement:\\ntheorem bounded_of_uniformly_continuous_on_bounded:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::real_normed_vector\\\"\\n assumes \\\"bounded (UNIV::'a set)\\\" \\\"uniformly_continuous_on UNIV f\\\"\\n shows \\\"bounded (range f)\\\"\\nOur comment on the codex statement: < wrong (didn't refer to set E, wrong types) but quite close >\\n *)\\ntheorem exercise_4_8a: \\n \\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and E::\\\" real set\\\"\\n assumes \\\"bounded E\\\" \\\"uniformly_continuous_on E f\\\"\\n shows \\\"bounded (range f)\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:4_11a\\nnatural language statement:\\nSuppose $f$ is a uniformly continuous mapping of a metric \\nspace $X$ into a metric space $Y$ and prove that $\\\\left\\\\{f\\\\left(x_{n}\\\\right)\\\\right\\\\}$ \\nis a Cauchy sequence in\\nlean statement:\\ntheorem exercise_4_11a\\n {X : Type*} [metric_space X]\\n {Y : Type*} [metric_space Y]\\n (f : X \\\\<rightarrow> Y) (hf : uniform_continuous f)\\n (x : \\\\<nat> \\\\<rightarrow> X) (hx : cauchy_seq x) :\\n cauchy_seq (\\\\<lambda> n, f (x n)) :=\\n\\ncodex statement:\\ntheorem cauchy_of_uniform_continuous:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\"\\n assumes \\\"uniformly_continuous_on UNIV f\\\" \\\"cauchy (f \\u2218 g)\\\"\\n shows \\\"cauchy g\\\"\\nOur comment on the codex statement: <overall wrong, and it's\\nstrange that it makes a function g appear out of nowhere. Also uses\\ncauchy instead of Cauchy (the former doesn't exist>\\n *)\\n\\n(*TODO something wrong with natural language statement? *)\\ntheorem exercise_4_11a: undefined\\n oops\\n\\n(*\\nproblem_number:4_12\\nnatural language statement:\\nA uniformly continuous function of a uniformly continuous function is uniformly continuous.\\nlean statement:\\ntheorem exercise_4_12\\n {\\\\<alpha> \\u03b2 \\\\<nu> : Type*} [uniform_space \\\\<alpha>] [uniform_space \\u03b2] [uniform_space \\\\<nu>]\\n {f : \\\\<alpha> \\\\<rightarrow> \\u03b2} {g : \\u03b2 \\\\<rightarrow> \\\\<nu>}\\n (hf : uniform_continuous f) (hg : uniform_continuous g) :\\n uniform_continuous (g \\u2218 f) :=\\n\\ncodex statement:\\ntheorem uniform_continuous_of_uniform_continuous_comp:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and g::\\\"'b::metric_space \\\\<Rightarrow> 'c::metric_space\\\"\\n assumes \\\"uniformly_continuous_on UNIV f\\\" \\\"uniformly_continuous_on UNIV g\\\"\\n shows \\\"uniformly_continuous_on UNIV (g \\u2218 f)\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below>\\n *)\\ntheorem exercise_4_12:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and \\ng::\\\"'b::metric_space \\\\<Rightarrow> 'c::metric_space\\\"\\n assumes \\\"uniformly_continuous_on UNIV f\\\" \\\"uniformly_continuous_on UNIV g\\\"\\n shows \\\"uniformly_continuous_on UNIV (g \\u2218 f)\\\"\\n oops\\n\\n\\n(*\\nproblem_number:4_14\\nnatural language statement:\\nLet $I=[0,1]$ be the closed unit interval. \\nSuppose $f$ is a continuous mapping of $I$ into $I$. Prove that $f(x)=x$ for at least one $x \\\\in I$.\\nlean statement:\\ntheorem exercise_4_14 [topological_space I]\\n [linear_order I] (f : I \\\\<rightarrow> I) (hf : continuous f) :\\n \\\\<exists> (x : I), f x = x :=\\n\\ncodex statement:\\ntheorem exists_fixed_point_of_continuous_on_closed_interval:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {0..1} f\\\"\\n shows \\\"\\\\<exists>x. x\\\\<in>{0..1} \\\\<and> f x = x\\\"\\nOur comment on the codex statement: <almost correct, forgot range>\\n *)\\ntheorem exercise_4_14: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {0..1} f\\\" and \\\"range f = {0..1}\\\"\\n shows \\\"\\\\<exists>x. x\\\\<in>{0..1} \\\\<and> f x = x\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:4_15\\nnatural language statement:\\nProve that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.\\nlean statement:\\ntheorem exercise_4_15 {f : \\\\<real> \\\\<rightarrow> \\\\<real>}\\n (hf : continuous f) (hof : is_open_map f) :\\n monotone f :=\\n\\ncodex statement:\\ntheorem monotonic_of_continuous_open_mapping:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on UNIV f\\\" \\\"open_mapping f\\\"\\n shows \\\"mono f\\\"\\nOur comment on the codex statement: < wrong: used the definition open_mapping which doesn't exist.\\nAlso, mono in Isabelle means monotone increasing, while it can either be monotone increasing\\nor monotone decreasing>\\n *)\\ntheorem exercise_4_15:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on UNIV f\\\" \\\"open (f ` UNIV) \\\"\\n shows \\\"mono f \\\\<or> antimono f \\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:4_19\\nnatural language statement:\\nSuppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property. \\nIf $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational \\n$r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.\\nlean statement:\\ntheorem exercise_4_19\\n {f : \\\\<real> \\\\<rightarrow> \\\\<real>} (hf : \\\\<forall> a b c, a < b \\\\<rightarrow> f a < c \\\\<rightarrow> c < f b \\\\<rightarrow> \\\\<exists> x, a < x \\\\<and> x < b \\\\<and> f x = c)\\n (hg : \\\\<forall> r : \\\\<rat>, is_closed {x | f x = r}) : continuous f :=\\n\\ncodex statement:\\ntheorem continuous_of_intermediate_value_property_and_closed_set_of_rational_value:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>a b c. a < b \\\\<longrightarrow> f a < c \\\\<longrightarrow> c < f b \\\\<longrightarrow> \\n\\\\<exists>x. a < x \\\\<longrightarrow> x < b \\\\<longrightarrow> f x = c\\\"\\n \\\"\\\\<forall>r. closed {x | x \\\\<in> UNIV \\\\<and> f x = r}\\\"\\n shows \\\"continuous_on UNIV f\\\"\\nOur comment on the codex statement: <wrong >\\n *)\\ntheorem exercise_4_19: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\" \\\\<forall> a b c. ( (f a < c \\\\<and> c < f b ) \\\\<longrightarrow>\\n(\\\\<exists> x::real. (f x) =c \\\\<and> ((x \\\\<le> a \\\\<and> x \\\\<ge> b) \\\\<or>(x \\\\<le> b \\\\<and> x \\\\<ge> a)) ) )\\\"\\n and \\\"\\\\<forall>r::rat. (closed {x. x \\\\<in> UNIV \\\\<and> f x = r})\\\"\\n shows \\\"continuous_on UNIV f\\\"\\n oops\\n\\n\\n(*\\nproblem_number:4_21a\\nnatural language statement:\\nSuppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. \\nProve that there exists $\\\\delta>0$ such that $d(p, q)>\\\\delta$ if $p \\\\in K, q \\\\in F$.\\nlean statement:\\ntheorem exercise_4_21a {X : Type*} [metric_space X]\\n (K F : set X) (hK : is_compact K) (hF : is_closed F) (hKF : disjoint K F) :\\n \\\\<exists> (\\u03b4 : \\\\<real>), \\u03b4 > 0 \\\\<and> \\\\<forall> (p q : X), p \\\\<in> K \\\\<rightarrow> q \\\\<in> F \\\\<rightarrow> dist p q \\\\<ge> \\u03b4 :=\\n\\ncodex statement:\\ntheorem exists_delta_of_disjoint_compact_closed:\\n fixes K F::\\\"'a::metric_space set\\\"\\n assumes \\\"compact K\\\" \\\"closed F\\\" \\\"K \\u2229 F = {}\\\"\\n shows \\\"\\\\<exists>\\u03b4>0. \\\\<forall>p\\\\<in>K. \\\\<forall>q\\\\<in>F. dist p q > \\u03b4\\\"\\nOur comment on the codex statement: <correct formalisation, my formulation slightly differs>\\n *)\\ntheorem exercise_4_21a: \\n \\n fixes X::\\\"'a::metric_space set\\\" \\n assumes \\\"K \\\\<subseteq> X\\\" \\\"F \\\\<subseteq> X\\\" \\\"compact K\\\" \\\"closed F\\\" \\\"K \\u2229 F = {}\\\" \\n shows \\\"\\\\<exists> \\\\<delta>>0. \\\\<forall>p\\\\<in>K. \\\\<forall>q\\\\<in>F. dist p q > \\\\<delta>\\\" \\n oops\\n\\n\\n(*\\nproblem_number:4_24\\nnatural language statement:\\nAssume that $f$ is a continuous real function defined in $(a, b)$ \\nsuch that $f\\\\left(\\\\frac{x+y}{2}\\\\right) \\\\leq \\\\frac{f(x)+f(y)}{2}$ for all $x, y \\\\in(a, b)$. \\nProve that $f$ is convex.\\nlean statement:\\ntheorem exercise_4_24 {f : \\\\<real> \\\\<rightarrow> \\\\<real>}\\n (hf : continuous f) (a b : \\\\<real>) (hab : a < b)\\n (h : \\\\<forall> x y : \\\\<real>, a < x \\\\<rightarrow> x < b \\\\<rightarrow> a < y \\\\<rightarrow> y < b \\\\<rightarrow> f ((x + y) / 2) \\\\<le> (f x + f y) / 2) :\\n convex_on \\\\<real> (set.Ioo a b) f :=\\n\\ncodex statement:\\ntheorem convex_of_continuous_and_ineq:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {a<..<b} f\\\" \\\"\\\\<forall>x y. x \\\\<in> {a<..<b} \\\\<longrightarrow> y \\\\<in> {a<..<b} \\\\<longrightarrow> f ((x + y) / 2) \\\\<le> (f x + f y) / 2\\\"\\n shows \\\"convex_on {a<..<b} f\\\"\\nOur comment on the codex statement: <close but not correct. Missed the absolute value.>\\n *)\\ntheorem exercise_4_24:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes\\n\\n \\\"continuous_on {a<..<b} f\\\"\\n\\\"\\\\<forall>x y. (x \\\\<in> {a<..<b} \\\\<and> y \\\\<in> {a<..<b} \\n\\\\<longrightarrow> f (abs((x + y) / 2)) \\\\<le> (f x + f y) / 2)\\\"\\n shows \\\"convex_on {a<..<b} f\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:4_26a\\nnatural language statement:\\nSuppose $X, Y, Z$ are metric spaces, and $Y$ is compact. \\nLet $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, \\nand put $h(x)=g(f(x))$ for $x \\\\in X$. \\nProve that $f$ is uniformly continuous if $h$ is uniformly continuous.\\nlean statement:\\n\\ncodex statement:\\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp:\\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" and g::\\\"'b::metric_space \\\\<Rightarrow> 'c::metric_space\\\"\\n assumes \\\"compact (UNIV::'b set)\\\" \\\"continuous_on UNIV g\\\" \\\"inj g\\\" \\\"uniformly_continuous_on UNIV (g \\u2218 f)\\\"\\n shows \\\"uniformly_continuous_on UNIV f\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below>\\n *)\\ntheorem exercise_4_26a: \\n \\n fixes f::\\\"'a::metric_space \\\\<Rightarrow> 'b::metric_space\\\" \\nand g::\\\"'b::metric_space \\\\<Rightarrow> 'c::metric_space\\\"\\nassumes \\\"compact (UNIV::'b set)\\\" \\\"continuous_on UNIV g\\\" \\\"inj g\\\"\\n\\n\\\"uniformly_continuous_on UNIV (g \\u2218 f)\\\"\\n shows \\\"uniformly_continuous_on UNIV f\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:5_1\\nnatural language statement:\\nLet $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\n\\\\leq(x-y)^{2}$for all real $x$ and $y$. Prove that $f$ is constant.\\nlean statement:\\ntheorem exercise_5_1\\n {f : \\\\<real> \\\\<rightarrow> \\\\<real>} (hf : \\\\<forall> x y : \\\\<real>, | (f x - f y) | \\\\<le> (x - y) ^ 2) :\\n \\\\<exists> c, f = \\\\<lambda> x, c :=\\n\\ncodex statement:\\ntheorem constant_of_diff_leq_square_diff:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x y. abs (f x - f y) \\\\<le> (x - y)^2\\\"\\n shows \\\"f constant_on UNIV\\\"\\nOur comment on the codex statement: <correct, I copy-paste it below>\\n *)\\ntheorem exercise_5_1:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x y. abs (f x - f y) \\\\<le> (x - y)^2\\\"\\n shows \\\"f constant_on UNIV\\\"\\n oops\\n\\n\\n(*\\nproblem_number:5_2\\nnatural language statement:\\nSuppose $f^{\\\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly \\nincreasing in $(a, b)$, and let $g$ be its inverse function. \\nProve that $g$ is differentiable, and that$g^{\\\\prime}(f(x))=\\\\frac{1}{f^{\\\\prime}(x)} \\\\quad(a<x<b)$\\nlean statement:\\ntheorem exercise_5_2 {a b : \\\\<real>}\\n {f g : \\\\<real> \\\\<rightarrow> \\\\<real>} (hf : \\\\<forall> x \\\\<in> set.Ioo a b, deriv f x > 0)\\n (hg : g = inv f)\\n (hg_diff : differentiable_on \\\\<real> g (set.Ioo a b)) :\\n differentiable_on \\\\<real> g (set.Ioo a b) \\\\<and>\\n \\\\<forall> x \\\\<in> set.Ioo a b, deriv g x = 1 / deriv f x :=\\n\\ncodex statement:\\ntheorem derivative_of_inverse_function:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and g::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"a < b\\\" \\\"continuous_on {a..b} f\\\" \\\"\\\\<forall>x\\\\<in>{a..b}. f differentiable (at x)\\\" \\n\\\"\\\\<forall>x\\\\<in>{a..b}. 0 < f' x\\\"\\n shows \\\"\\\\<forall>x\\\\<in>{a..b}. g differentiable (at x)\\\" \\\"\\\\<forall>x\\\\<in>{a..b}. g' x = 1 / f' (g x)\\\"\\nOur comment on the codex statement: <quite close but wrong deriv notation, misses one assumption\\nand one concl. >*)\\n\\ntheorem exercise_5_2: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and g::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x\\\\<in>{a..b}. f differentiable (at x)\\\" \\n\\\"\\\\<forall>x\\\\<in>{a..b}. 0 < deriv f x\\\" and \\\"\\\\<forall> x\\\\<in>{a..b} . g x = 1/ f x\\\"\\n\\nshows \\\"mono f\\\" \\\"\\\\<forall>x\\\\<in>{a..b}. g differentiable (at x)\\\" \\n\\\"\\\\<forall>x\\\\<in>{a..b}. deriv g ( f x) = 1 / deriv f x\\\"\\n oops\\n \\n\\n(*\\nproblem_number:5_3\\nnatural language statement:\\nSuppose $g$ is a real function on $R^{1}$, with bounded derivative \\n(say $\\\\left|g^{\\\\prime}\\\\right| \\\\leq M$ ). Fix $\\\\varepsilon>0$, and define $f(x)=x+\\\\varepsilon g(x)$. \\nProve that $f$ is one-to-one if $\\\\varepsilon$ is small enough.\\nlean statement:\\ntheorem exercise_5_3 {g : \\\\<real> \\\\<rightarrow> \\\\<real>} (hg : continuous g)\\n (hg' : \\\\<exists> M : \\\\<real>, \\\\<forall> x : \\\\<real>, | deriv g x | \\\\<le> M) :\\n \\\\<exists> N, \\\\<forall> \\\\<epsilon> > 0, \\\\<epsilon> < N \\\\<rightarrow> \\nfunction.injective (\\\\<lambda> x : \\\\<real>, x + \\\\<epsilon> * g x) :=\\n\\ncodex statement:\\ntheorem injective_of_small_epsilon:\\n fixes g::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. abs (g' x) \\\\<le> M\\\"\\n shows \\\"\\\\<exists>\\\\<epsilon>>0. \\\\<forall>x y. abs (x - y) < \\\\<epsilon> \\\\<longrightarrow> g x \\\\<noteq> g y\\\"\\nOur comment on the codex statement: <wrong >\\n *)\\ntheorem exercise_5_3: \\n fixes g::\\\"real \\\\<Rightarrow> real\\\" and \\\\<epsilon> K M:: real and f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. abs (deriv g x) \\\\<le> M\\\" and \\\" \\\\<forall> x. f x =x + \\\\<epsilon> *( g x )\\\"\\n shows \\\" \\\\<epsilon> < K \\\\<longrightarrow> inj f\\\"\\n\\n oops\\n\\n\\n(*\\nproblem_number:5_4\\nnatural language statement:\\nIf $C_{0}+\\\\frac{C_{1}}{2}+\\\\cdots+\\\\frac{C_{n-1}}{n}+\\\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\\\ldots, \\nC_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ \\nhas at least one real root between 0 and 1 .\\nlean statement:\\ntheorem exercise_5_4 {n : \\\\<nat>}\\n (C : \\\\<nat> \\\\<rightarrow> \\\\<real>)\\n (hC : \\\\<Sum> i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\\n \\\\<exists> x, x \\\\<in> (set.Icc (0 : \\\\<real>) 1) \\\\<and> \\\\<Sum> i in finset.range (n + 1), (C i) * (x^i) = 0 :=\\n\\ncodex statement:\\ntheorem exists_real_root_of_polynomial_of_sum_eq_zero:\\n fixes C::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>n. C n = 0\\\" \\\"\\\\<Sum>n. C n / (n+1) = 0\\\"\\n shows \\\"\\\\<exists>x. 0 < x \\\\<and> x < 1 \\\\<and> (\\\\<Sum>n. C n * x^n) = 0\\\"\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\\n *)\\ntheorem exercise_5_4: \\n undefined\\n oops\\n\\n\\n(*\\nproblem_number:5_5\\nnatural language statement:\\nSuppose $f$ is defined and differentiable for every $x>0$,\\n and $f^{\\\\prime}(x) \\\\rightarrow 0$ as $x \\\\rightarrow+\\\\infty$. Put $g(x)=f(x+1)-f(x)$. \\nProve that $g(x) \\\\rightarrow 0$ as $x \\\\rightarrow+\\\\infty$.\\nlean statement:\\ntheorem exercise_5_5\\n {f : \\\\<real> \\\\<rightarrow> \\\\<real>}\\n (hfd : differentiable \\\\<real> f)\\n (hf : tendsto (deriv f) at_top (\\ud835\\udcdd 0)) :\\n tendsto (\\\\<lambda> x, f (x + 1) - f x) at_top at_top :=\\n\\ncodex statement:\\ntheorem tendsto_zero_of_tendsto_zero_derivative:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. 0 < x \\\\<longrightarrow> f differentiable (at x)\\\" \\\"((\\\\<lambda>x. f' x) ---> 0) at_top\\\"\\n shows \\\"((\\\\<lambda>x. f (x + 1) - f x) ---> 0) at_top\\\"\\nOur comment on the codex statement: <several wrong symbols>\\n *)\\ntheorem exercise_5_5: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and g::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x >0. f differentiable (at x)\\\" \\\"\\\\<forall> x. g(x)=f(x+1)-f(x)\\\"\\n\\\"eventually ((\\u03bbx. deriv f(x )) \\u290f 0) at_top\\\"\\n shows \\\"eventually ((\\u03bbx. deriv g(x )) \\u290f 0) at_top\\\"\\n oops\\n(*\\nproblem_number:5_6\\nnatural language statement:\\nSuppose (a) $f$ is continuous for $x \\\\geq 0$, \\n(b) $f^{\\\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, \\n(d) $f^{\\\\prime}$ is monotonically increasing. Put $g(x)=\\\\frac{f(x)}{x} \\\\quad(x>0)$ \\nand prove that $g$ is monotonically increasing.\\nlean statement:\\ntheorem exercise_5_6\\n {f : \\\\<real> \\\\<rightarrow> \\\\<real>}\\n (hf1 : continuous f)\\n (hf2 : \\\\<forall> x, differentiable_at \\\\<real> f x)\\n (hf3 : f 0 = 0)\\n (hf4 : monotone (deriv f)) :\\n monotone_on (\\\\<lambda> x, f x / x) (set.Ioi 0) :=\\n\\ncodex statement:\\ntheorem monotone_increasing_of_continuous_derivative_monotone_increasing:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {0..} f\\\" \\\"\\\\<forall>x>0. (f has_real_derivative f' x) (at x)\\\" \\\"f 0 = 0\\\" \\\"mono f'\\\"\\n shows \\\"mono (\\\\<lambda>x. f x / x)\\\"\\nOur comment on the codex statement: <correct, copy-pasted with slight change>\\n *)\\ntheorem exercise_5_6: fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {0..} f\\\" \\n\\\"\\\\<forall>x>0. (f has_real_derivative f' x) (at x)\\\" \\\"f 0 = 0\\\" \\\"mono f'\\\"\\n\\\"\\\\<forall> x>0. g x = f x / x\\\"\\n shows \\\"mono g\\\"\\n \\n oops\\n\\n\\n(*\\nproblem_number:5_7\\nnatural language statement:\\nSuppose $f^{\\\\prime}(x), g^{\\\\prime}(x)$ exist, $g^{\\\\prime}(x) \\\\neq 0$, \\nand $f(x)=g(x)=0$. Prove that $\\\\lim _{t \\\\rightarrow x} \\\\frac{f(t)}{g(t)}=\\\\frac{f^{\\\\prime}(x)}{g^{\\\\prime}(x)}.$\\nlean statement:\\ntheorem exercise_5_7\\n {f g : \\\\<real> \\\\<rightarrow> \\\\<real>} {x : \\\\<real>}\\n (hf' : differentiable_at \\\\<real> f 0)\\n (hg' : differentiable_at \\\\<real> g 0)\\n (hg'_ne_0 : deriv g 0 \\\\<noteq> 0)\\n (f0 : f 0 = 0) (g0 : g 0 = 0) :\\n tendsto (\\\\<lambda> x, f x / g x) (\\ud835\\udcdd x) (\\ud835\\udcdd (deriv f x / deriv g x)) :=\\n\\ncodex statement:\\ntheorem lim_frac_of_derivative_eq_derivative_frac:\\n fixes f g::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"f differentiable (at x)\\\" \\\"g differentiable (at x)\\\" \\\"g x \\\\<noteq> 0\\\" \\\"f x = g x = 0\\\"\\n shows \\\"(f has_real_derivative (f' x)) (at x)\\\" \\\"(g has_real_derivative (g' x)) (at x)\\\"\\nOur comment on the codex statement: <codex gives wrong assumptions and conclusions>\\n *)\\ntheorem exercise_5_7:\\n (* fixes f g::\\\"real \\\\<Rightarrow> real\\\" assumes\\n \\\" (f has_real_derivative f' x) (at x)\\\"\\n \\\" (g has_real_derivative g' x) (at x)\\\"\\n \\\"g' x \\\\<noteq> 0\\\" \\\" f x = g x\\\" \\\"f x = 0\\\"\\n*)\\nundefined oops\\n\\n(*\\nproblem_number:5_15\\nnatural language statement:\\nSuppose $a \\\\in R^{1}, f$ is a twice-differentiable real function \\non $(a, \\\\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper \\nbounds of $|f(x)|,\\\\left|f^{\\\\prime}(x)\\\\right|,\\\\left|f^{\\\\prime \\\\prime}(x)\\\\right|$, \\nrespectively, on $(a, \\\\infty)$. Prove that $M_{1}^{2} \\\\leq 4 M_{0} M_{2} .$\\nlean statement:\\ntheorem exercise_5_15 {f : \\\\<real> \\\\<rightarrow> \\\\<real>} (a M0 M1 M2 : \\\\<real>)\\n (hf' : differentiable_on \\\\<real> f (set.Ici a))\\n (hf'' : differentiable_on \\\\<real> (deriv f) (set.Ici a))\\n (hM0 : M0 = Sup {(| f x | )| x \\\\<in> (set.Ici a)})\\n (hM1 : M1 = Sup {(| deriv f x | )| x \\\\<in> (set.Ici a)})\\n (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\\\<in> (set.Ici a)}) :\\n (M1 ^ 2) \\\\<le> 4 * M0 * M2 :=\\n\\ncodex statement: (* TODO MISSING*)\\n\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\\n *)\\ntheorem exercise_5_15: undefined oops\\n\\n\\n(*\\nproblem_number:5_17\\nnatural language statement:\\nSuppose $f$ is a real, three times differentiable function on $[-1,1]$, \\nsuch that $f(-1)=0, \\\\quad f(0)=0, \\\\quad f(1)=1, \\\\quad f^{\\\\prime}(0)=0 .$ \\nProve that $f^{(3)}(x) \\\\geq 3$ for some $x \\\\in(-1,1)$.\\nlean statement:\\ntheorem exercise_5_17\\n {f : \\\\<real> \\\\<rightarrow> \\\\<real>}\\n (hf' : differentiable_on \\\\<real> f (set.Icc (-1) 1))\\n (hf'' : differentiable_on \\\\<real> (deriv f) (set.Icc 1 1))\\n (hf''' : differentiable_on \\\\<real> (deriv (deriv f)) (set.Icc 1 1))\\n (hf0 : f (-1) = 0)\\n (hf1 : f 0 = 0)\\n (hf2 : f 1 = 1)\\n (hf3 : deriv f 0 = 0) :\\n \\\\<exists> x, x \\\\<in> set.Ioo (-1 : \\\\<real>) 1 \\\\<and> deriv (deriv (deriv f)) x \\\\<ge> 3 :=\\n\\ncodex statement:\\ntheorem exists_x_in_interval_of_three_times_differentiable_function:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. f differentiable (at x)\\\" \\\"\\\\<forall>x. f differentiable (at x within {-1..1})\\\" \\\"\\\\<forall>x. f differentiable (at x within {-1..1})\\\" \\\"f (-1) = 0\\\" \\\"f 0 = 0\\\" \\\"f 1 = 1\\\" \\\"f' 0 = 0\\\"\\n shows \\\"\\\\<exists>x\\\\<in>{-1..1}. f''' x \\\\<ge> 3\\\"\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\\n *)\\ntheorem exercise_5_17: undefined oops\\n\\n\\n(*\\nproblem_number:6_1\\nnatural language statement:\\nSuppose $\\\\alpha$ increases on $[a, b], \\na \\\\leq x_{0} \\\\leq b, \\\\alpha$ is continuous at $x_{0}, f\\\\left(x_{0}\\\\right)=1$, \\nand $f(x)=0$ if $x \\\\neq x_{0}$. Prove that $f \\\\in \\\\mathcal{R}(\\\\alpha)$ and that $\\\\int f d \\\\alpha=0$.\\nlean statement:\\n\\ncodex statement:\\ntheorem integral_of_continuous_function_eq_zero:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\" and \\\\<alpha>::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"a \\\\<le> x\\u2080\\\" \\\"x\\u2080 \\\\<le> b\\\" \\\"continuous (at x\\u2080) \\\\<alpha>\\\" \\\"f x\\u2080 = 1\\\" \\n\\\"f x = 0\\\" \\\"\\\\<forall>x. a \\\\<le> x \\\\<and> x \\\\<le> b \\\\<longrightarrow> \\\\<alpha> x \\\\<le> \\\\<alpha> x\\u2080\\\"\\n shows \\\"f \\\\<in> borel_measurable \\\\<alpha>\\\" \\\"integral \\\\<alpha> f = 0\\\"\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\\n *)\\ntheorem exercise_6_1: undefined oops\\n(*TODO: note there are different kinds of integration, do we need Riemann here? *)\\n\\n\\n(*\\nproblem_number:6_2\\nnatural language statement:\\nSuppose $f \\\\geq 0, f$ is continuous on $[a, b]$, and $\\\\int_{a}^{b} f(x) d x=0$. \\nProve that $f(x)=0$ for all $x \\\\in[a, b]$.\\nlean statement:\\n\\ncodex statement:\\ntheorem zero_integral_of_continuous_nonneg_implies_zero_function:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {a..b} f\\\" \\\"f \\\\<ge> 0\\\" \\\"integral {a..b} f = 0\\\"\\n shows \\\"\\\\<forall>x\\\\<in>{a..b}. f x = 0\\\"\\nOur comment on the codex statement: <almost correct, but syntactical error in one of the assumptions.\\n By the way: TODO it is not \\nactually clear which kind of integral is required from the nat lang. statement. >\\n *)\\ntheorem exercise_6_2: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"continuous_on {a..b} f\\\" \\\"\\\\<forall> x \\\\<in> UNIV. f x \\\\<ge> 0\\\" \\\"integral {a..b} f = 0\\\"\\n shows \\\"\\\\<forall>x\\\\<in>{a..b}. f x = 0\\\"\\n oops\\n\\n\\n(*\\nproblem_number:6_4\\nnatural language statement:\\nIf $f(x)=0$ for all irrational $x, f(x)=1$ for all rational $x$, \\nprove that $f \\\\notin \\\\mathcal{R}$ on $[a, b]$ for any $a<b$.\\nlean statement:\\n\\ncodex statement:\\ntheorem not_Riemann_integrable_of_zero_for_irrational_one_for_rational:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. irrational x \\\\<longrightarrow> f x = 0\\\" \\\"\\\\<forall>x. rational x \\\\<longrightarrow> f x = 1\\\"\\n shows \\\"\\\\<forall>a b. a < b \\\\<longrightarrow> \\u00ac (f integrable_on {a..b})\\\"\\nOur comment on the codex statement: <uses nonexistent Isabelle defs like rational, irrational>\\n *)\\ntheorem exercise_6_4: \\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"\\\\<forall>x. x \\\\<notin> Rats \\\\<longrightarrow> f x = 0\\\" \\n\\\"\\\\<forall>x \\\\<in> Rats. f x = 1\\\"\\n shows \\\"\\\\<forall>a b. a < b \\\\<longrightarrow> \\u00ac (f integrable_on {a..b})\\\"\\n oops\\n(*TODO: again note there are different kinds of integration, don't we need Riemann here? *)\\n\\n(*\\nproblem_number:6_6\\nnatural language statement:\\nLet $P$ be the Cantor set. Let $f$ be a bounded real function on $[0,1]$ \\nwhich is continuous at every point outside $P$. Prove that $f \\\\in \\\\mathcal{R}$ on $[0,1]$.\\nlean statement:\\nMISSING\\ncodex statement:\\ntheorem R_of_bounded_continuous_at_outside_Cantor:\\n fixes f::\\\"real \\\\<Rightarrow> real\\\"\\n assumes \\\"bounded (range f)\\\" \\\"\\\\<forall>x\\\\<in>{0..1} - cantor. continuous (at x) f\\\"\\n shows \\\"f \\\\<in> R {0..1}\\\"\\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\\n *)\\ntheorem exercise_6_6:\\n \\n undefined oops\\n\\n\\n\\n\\nend\\n\"} {\"text\": \"(*\\n Authors: Asta Halkj\\u00e6r From, Agnes Moesg\\u00e5rd Eschen & J\\u00f8rgen Villadsen, DTU Compute\\n*)\\n\\ntheory System_F1 imports System_L3 begin\\n\\ntext \\\\<open>System F from Gottlob Frege: Begriffsschrift (1879)\\\\<close>\\n\\ntext \\\\<open>Derivations are taken from: On Axiom Systems of Propositional Calculi. VII\\n by Yoshinari Arai and Kiyoshi Iseki (1965)\\\\<close>\\n\\ninductive F (\\\\<open>\\\\<FF>\\\\<close>) where\\n F_MP: \\\\<open>\\\\<FF> q\\\\<close> if \\\\<open>\\\\<FF> p\\\\<close> and \\\\<open>\\\\<FF> (p \\\\<rightarrow> q)\\\\<close> |\\n F_1: \\\\<open>\\\\<FF> (p \\\\<rightarrow> (q \\\\<rightarrow> p))\\\\<close> |\\n F_2: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> (q \\\\<rightarrow> r)) \\\\<rightarrow> ((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close> |\\n F_3: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> q) \\\\<rightarrow> ((\\\\<sim> q) \\\\<rightarrow> (\\\\<sim> p)))\\\\<close> |\\n F_4: \\\\<open>\\\\<FF> ((\\\\<sim> (\\\\<sim> p)) \\\\<rightarrow> p)\\\\<close> |\\n F_5: \\\\<open>\\\\<FF> (p \\\\<rightarrow> (\\\\<sim> (\\\\<sim> p)))\\\\<close>\\n\\nlemma F_6: \\\\<open>\\\\<FF> ((q \\\\<rightarrow> r) \\\\<rightarrow> ((p \\\\<rightarrow> (q \\\\<rightarrow> r)) \\\\<rightarrow> ((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r))))\\\\<close>\\n using F_1 F_2 F_MP by metis\\n\\nlemma F_7: \\\\<open>\\\\<FF> ((q \\\\<rightarrow> r) \\\\<rightarrow> ((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using F_1 F_2 F_6 F_MP by metis\\n\\nlemma F_8: \\\\<open>\\\\<FF> (((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)) \\\\<rightarrow> (q \\\\<rightarrow> (p \\\\<rightarrow> q)))\\\\<close>\\n using F_1 F_MP by metis\\n\\nlemma F_9: \\\\<open>\\\\<FF> (((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)) \\\\<rightarrow> ((q \\\\<rightarrow> (p \\\\<rightarrow> q)) \\\\<rightarrow> (q \\\\<rightarrow> (p \\\\<rightarrow> r))))\\\\<close>\\n using F_7.\\n\\nlemma F_10: \\\\<open>\\\\<FF> (((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)) \\\\<rightarrow> (q \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using F_2 F_8 F_9 F_MP by metis\\n\\nlemma F_11: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> (q \\\\<rightarrow> r)) \\\\<rightarrow> (q \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using F_2 F_7 F_10 F_MP by metis\\n\\nlemma F_12: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> q) \\\\<rightarrow> ((q \\\\<rightarrow> r) \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using F_7 F_11 F_MP by metis\\n\\nlemma F_13: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> (\\\\<sim> q)) \\\\<rightarrow> ((\\\\<sim> (\\\\<sim> q)) \\\\<rightarrow> (\\\\<sim> p)))\\\\<close>\\n using F_3.\\n\\nlemma F_14: \\\\<open>\\\\<FF> (((\\\\<sim> (\\\\<sim> q)) \\\\<rightarrow> (\\\\<sim> p)) \\\\<rightarrow> (q \\\\<rightarrow> (\\\\<sim> p)))\\\\<close>\\n using F_5 F_12 F_MP by metis\\n\\nlemma F_15: \\\\<open>\\\\<FF> ((p \\\\<rightarrow> (\\\\<sim> q)) \\\\<rightarrow> (q \\\\<rightarrow> (\\\\<sim> p)))\\\\<close>\\n using F_12 F_13 F_14 F_MP by metis\\n\\nlemma F_16: \\\\<open>\\\\<FF> ((q \\\\<rightarrow> (\\\\<sim> (\\\\<sim> p))) \\\\<rightarrow> (q \\\\<rightarrow> p))\\\\<close>\\n using F_4 F_7 F_MP by metis\\n\\nlemma F_17: \\\\<open>\\\\<FF> (((\\\\<sim> p) \\\\<rightarrow> (\\\\<sim> q)) \\\\<rightarrow> (q \\\\<rightarrow> p))\\\\<close>\\n using F_12 F_15 F_16 F_MP by metis\\n\\ntheorem F_iff_L3: \\\\<open>\\\\<FF> p \\\\<longleftrightarrow> \\\\<LL>\\\\<^sub>3 p\\\\<close>\\nproof\\n have L3_F_3: \\\\<open>\\\\<LL>\\\\<^sub>3 ((p \\\\<rightarrow> q) \\\\<rightarrow> ((\\\\<sim> q) \\\\<rightarrow> (\\\\<sim> p)))\\\\<close> for p q\\n using L3_completeness by simp\\n have L3_F_4: \\\\<open>\\\\<LL>\\\\<^sub>3 ((\\\\<sim> (\\\\<sim> p)) \\\\<rightarrow> p)\\\\<close> for p\\n using L3_completeness by simp\\n have L3_F_5: \\\\<open>\\\\<LL>\\\\<^sub>3 (p \\\\<rightarrow> (\\\\<sim> (\\\\<sim> p)))\\\\<close> for p\\n using L3_completeness by simp\\n show \\\\<open>\\\\<LL>\\\\<^sub>3 p\\\\<close> if \\\\<open>\\\\<FF> p\\\\<close>\\n using that by (induct) (metis L3_MP, metis L3_1, metis L3_2,\\n metis L3_F_3, metis L3_F_4, metis L3_F_5)\\n show \\\\<open>\\\\<FF> p\\\\<close> if \\\\<open>\\\\<LL>\\\\<^sub>3 p\\\\<close>\\n using that by (induct) (metis F_MP, metis F_1, metis F_2, metis F_17)\\nqed\\n\\ntheorem F_soundness: \\\\<open>\\\\<FF> p \\\\<Longrightarrow> I \\\\<Turnstile> p\\\\<close>\\n by (induct rule: F.induct) auto\\n\\ntheorem F_completeness: \\\\<open>\\\\<forall>I. (I \\\\<Turnstile> p) \\\\<Longrightarrow> \\\\<FF> p\\\\<close>\\n using F_iff_L3 by (simp add: L3_completeness)\\n\\nsection \\\\<open>Soundness and Completeness\\\\<close>\\n\\ntheorem main: \\\\<open>valid p = \\\\<FF> p\\\\<close>\\n unfolding valid_def using F_soundness F_completeness by blast\\n\\nlemmas F1 = F.intros main\\n\\nend\\n\"} {\"text\": \"{-# OPTIONS --enable-prop #-}\\n\\ndata Squash {\\u2113} (A : Set \\u2113) : Prop \\u2113 where\\n squash : A \\u2192 Squash A\\n\\nsquash-elim : \\u2200 {\\u2113\\u2081 \\u2113\\u2082} (A : Set \\u2113\\u2081) (P : Prop \\u2113\\u2082)\\n \\u2192 (A \\u2192 P) \\u2192 Squash A \\u2192 P\\nsquash-elim A P f (squash x) = f x\\n\"} {\"text\": \"{-# OPTIONS --without-K #-}\\nmodule GroupoidStructure {a} {A : Set a} where\\n\\nopen import PathOperations\\nopen import Types\\n\\np\\u00b7p\\u207b\\u00b9 : {a b : A} (p : a \\u2261 b) \\u2192 p \\u00b7 p \\u207b\\u00b9 \\u2261 refl\\np\\u00b7p\\u207b\\u00b9 = J (\\u03bb _ _ p \\u2192 p \\u00b7 p \\u207b\\u00b9 \\u2261 refl) (\\u03bb _ \\u2192 refl) _ _\\n\\np\\u207b\\u00b9\\u00b7p : {a b : A} (p : a \\u2261 b) \\u2192 p \\u207b\\u00b9 \\u00b7 p \\u2261 refl\\np\\u207b\\u00b9\\u00b7p = J (\\u03bb _ _ p \\u2192 p \\u207b\\u00b9 \\u00b7 p \\u2261 refl) (\\u03bb _ \\u2192 refl) _ _\\n\\np\\u00b7id : {a b : A} (p : a \\u2261 b) \\u2192 p \\u00b7 refl \\u2261 p\\np\\u00b7id = J (\\u03bb _ _ p \\u2192 p \\u00b7 refl \\u2261 p) (\\u03bb _ \\u2192 refl) _ _\\n\\nid\\u00b7p : {a b : A} (p : a \\u2261 b) \\u2192 refl \\u00b7 p \\u2261 p\\nid\\u00b7p _ = refl\\n\\np\\u00b7q\\u00b7r : {a b c d : A} (p : a \\u2261 b) (q : b \\u2261 c) (r : c \\u2261 d) \\u2192\\n p \\u00b7 (q \\u00b7 r) \\u2261 (p \\u00b7 q) \\u00b7 r\\np\\u00b7q\\u00b7r {c = c} {d = d} = J\\n (\\u03bb _ b p \\u2192 (q : b \\u2261 c) (r : c \\u2261 d) \\u2192 p \\u00b7 q \\u00b7 r \\u2261 (p \\u00b7 q) \\u00b7 r)\\n (\\u03bb b \\u2192 J\\n (\\u03bb _ c q \\u2192 (r : c \\u2261 d) \\u2192 refl \\u00b7 q \\u00b7 r \\u2261 (refl \\u00b7 q) \\u00b7 r)\\n (\\u03bb _ _ \\u2192 refl) _ _)\\n _ _\\n\"} {\"text\": \"lemma zero_le (a : mynat) : 0 \\u2264 a :=\\nbegin\\nuse a,\\nrw zero_add,\\nrefl,\\nend\\n\"} {\"text\": \"theorem ex [Add \\u03b1]\\n (assoc : {a b c : \\u03b1} \\u2192 a + b + c = a + (b + c))\\n (comm : {a b : \\u03b1} \\u2192 a + b = b + a)\\n (f : \\u03b1 \\u2192 \\u03b1) (x y z : \\u03b1) : f (x + (y + z)) = f (y + (x + z)) := by\\n let leftAssoc {a b c : \\u03b1} : a + (b + c) = b + (a + c) := by\\n rw [\\u2190 assoc, comm (a := a), assoc]\\n simp [leftAssoc]\\n\"} {\"text\": \"theory exercise_2_2\\n imports Main\\nbegin\\n(*set add function*)\\nfun add::\\\"nat\\\\<Rightarrow>nat\\\\<Rightarrow>nat\\\"\\n where\\n\\\"add m 0 =m\\\"|\\n\\\"add m (Suc n)=Suc(add m n)\\\"\\n\\n(*set association*)\\ntheorem add_assoc:\\\"add x (add y z) =add (add x y) z\\\"\\n apply(induction z)\\n apply(auto)\\n done\\n(*set add 0 x*)\\nlemma add_zero:\\\"add 0 x=x\\\"\\n apply(induction x)\\n apply(auto)\\n done\\n\\nlemma suc_add:\\\"Suc(add y x) = add (Suc y) x\\\"\\n apply(induction x)\\n apply(auto)\\n done\\ntheorem add_com:\\\"add x y=add y x\\\"\\n apply(induction y)(*the different with using x or y as value ? ?*)\\n apply(auto)\\n apply(simp add:add_zero)\\n apply(simp add:suc_add)\\n done\\n\\n(*fun double*)\\nfun double::\\\"nat\\\\<Rightarrow>nat\\\" \\n where\\n\\\"double 0=0\\\"|\\n\\\"double (Suc m) =2+(double m)\\\"(*Why here is add ,not mutl? ?*)\\ntheorem double_add:\\\"double m=add m m\\\"\\n apply(induction m)\\n apply(auto)\\n apply(simp add:add_com)\\n done\\nend\"} {\"text\": \"in",
    "formal_statement": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.formal statement theorem exercise_2000_a2 : \\n \\u2200 N : \\u2115, \\u2203 n : \\u2115, n > N \\u2227 \\u2203 i : fin 6 \\u2192 \\u2115, n = (i 0)^2 + (i 1)^2 \\u2227 \\n n + 1 = (i 2)^2 + (i 3)^2 \\u2227 n + 2 = (i 4)^2 + (i 5)^2"
  },
  {
    "informal_statement": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\\\leq H$.",
    "formal_statement": "theorem exercise_7_1_11 {R : Type*} [ring R] [is_domain R] \\n {x : R} (hx : x^2 = 1) : x = 1 \\u2228 x = -1"
  },
  {
    "informal_statement": "Let $G=\\\\left\\\\{g_{1}, \\\\ldots, g_{n}\\\\right\\\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "formal_statement": "theorem exercise_7_3_37 {R : Type*} {p m : \\u2115} (hp : p.prime) \\n (N : ideal $ zmod $ p^m) : \\n is_nilpotent N \\u2194 is_nilpotent (ideal.span ({p} : set $ zmod $ p^m))"
  },
  {
    "informal_statement": "is: The closure of the empty set is the empty set.\"} {\"text\": \"module Examples\\n\\nimport Data.Vect\\nimport ProcessLib\\nimport Proto\\nimport HoriComp\\nimport VertComp\\nimport Primitives\\nimport SumWire\\nimport Dualise\\nimport SumWire\\nimport CupCap\\nimport Util\\n\\n%flag C \\\"-O3\\\"\\n\\ngt5: Hom [Down Int] [Down Int, Down Int]\\ngt5 = mkPure \\\"gt5: \\\" (\\\\n => if n > 5 then Left n else Right n) -*- splitEither\\n\\ninc: Hom [Down Int] [Down Int]\\ninc = mkPure \\\"inc: \\\" (\\\\i => i + 1)\\n\\ndownIntWire: Hom [Down Int] [Down Int]\\ndownIntWire = mkPure \\\"down int: \\\" id\\n\\nupIntWire: Hom [Up Int] [Up Int]\\nupIntWire = dualise downIntWire\\n\\nmyProc: Hom [Down Int] []\\nmyProc = downIntWire + cap\\n -*- (splice -*- inc -*- gt5) + upIntWire\\n -*- downPrinter + cup\\n\\ntest: Client ()\\ntest = do Just proc <- Spawn myProc | _ => Action (putStrLn \\\"failed to spawn the process\\\")\\n val_resp <- Request proc (Val (TopInWire Here) 1)\\n Action $ putStrLn $ \\\"result: \\\" ++ show val_resp\\n Util.dot_sleeper 20\\n\\nnamespace Main\\n main: IO ()\\n main = runProc test\\n\"} {\"text\": \"import Smt\\n\\ntheorem verum : true := by\\n smt\\n simp_all\\n\"} {\"text\": \"(*\\n Authors: Asta Halkj\\u00e6r From, Agnes Moesg\\u00e5rd Eschen & J\\u00f8rgen Villadsen, DTU Compute\\n*)\\n\\ntheory LT1 imports System_L1 begin\\n\\ntext \\\\<open>System from Jan Lukasiewicz and Alfred Tarski (1930): Untersuchungen \\u00fcber den Aussagenkalk\\u00fcl\\\\<close>\\n\\ntext \\\\<open>Inspired by Shotaro Tanaka (1965): On Axiom Systems of Propositional Calculi. XIII\\\\<close>\\n\\ninductive LT (\\\\<open>\\\\<tturnstile>\\\\<close>) where\\n LT_MP: \\\\<open>\\\\<tturnstile> q\\\\<close> if \\\\<open>\\\\<tturnstile> p\\\\<close> and \\\\<open>\\\\<tturnstile> (p \\\\<rightarrow> q)\\\\<close> |\\n LT_1: \\\\<open>\\\\<tturnstile> (((p \\\\<rightarrow> (q \\\\<rightarrow> p))\\n \\\\<rightarrow> (((\\\\<sim> r \\\\<rightarrow> (s \\\\<rightarrow> \\\\<sim> t)) \\\\<rightarrow> ((r \\\\<rightarrow> (s \\\\<rightarrow> u)) \\\\<rightarrow> ((t \\\\<rightarrow> s) \\\\<rightarrow> (t \\\\<rightarrow> u)))) \\\\<rightarrow> v))\\n \\\\<rightarrow> (w \\\\<rightarrow> v))\\\\<close>\\n\\nlemma LT_3: \\\\<open>\\\\<tturnstile> (p \\\\<rightarrow> (q \\\\<rightarrow> p))\\\\<close>\\n using LT_1 LT_MP by metis\\n\\nlemma LT_5: \\\\<open>\\\\<tturnstile> ((p \\\\<rightarrow> (q \\\\<rightarrow> r)) \\\\<rightarrow> ((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using LT_1 LT_MP by metis\\n\\nlemma LT_13: \\\\<open>\\\\<tturnstile> (((p \\\\<rightarrow> q) \\\\<rightarrow> (p \\\\<rightarrow> r)) \\\\<rightarrow> (q \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using LT_1 LT_5 LT_MP by metis\\n\\nlemma LT_11: \\\\<open>\\\\<tturnstile> ((p \\\\<rightarrow> q) \\\\<rightarrow> ((q \\\\<rightarrow> r) \\\\<rightarrow> (p \\\\<rightarrow> r)))\\\\<close>\\n using LT_3 LT_5 LT_MP by metis\\n\\nlemma LT_20: \\\\<open>\\\\<tturnstile> ((\\\\<sim> p \\\\<rightarrow> p) \\\\<rightarrow> p)\\\\<close>\\n using LT_1 LT_3 LT_13 LT_MP by metis\\n\\nlemma LT_21: \\\\<open>\\\\<tturnstile> (p \\\\<rightarrow> (\\\\<sim> p \\\\<rightarrow> q))\\\\<close>\\n using LT_1 LT_3 LT_13 LT_MP by metis\\n\\ntheorem LT_iff_L1: \\\\<open>\\\\<tturnstile> p \\\\<longleftrightarrow> \\\\<turnstile> p\\\\<close>\\nproof\\n have L1_LT_1:\\n \\\\<open>\\\\<turnstile> (((p \\\\<rightarrow> (q \\\\<rightarrow> p))\\n \\\\<rightarrow> (((\\\\<sim> r \\\\<rightarrow> (s \\\\<rightarrow> \\\\<sim> t)) \\\\<rightarrow> ((r \\\\<rightarrow> (s \\\\<rightarrow> u)) \\\\<rightarrow> ((t \\\\<rightarrow> s) \\\\<rightarrow> (t \\\\<rightarrow> u)))) \\\\<rightarrow> v))\\n \\\\<rightarrow> (w \\\\<rightarrow> v))\\\\<close> for p q r s t u v w\\n using L1_completeness by simp\\n show \\\\<open>\\\\<turnstile> p\\\\<close> if \\\\<open>\\\\<tturnstile> p\\\\<close>\\n using that by (induct) (metis MP, metis L1_LT_1)\\n show \\\\<open>\\\\<tturnstile> p\\\\<close> if \\\\<open>\\\\<turnstile> p\\\\<close>\\n using that by (induct) (metis LT_MP, metis LT_11, metis LT_20, metis LT_21)\\nqed\\n\\ntheorem LT_soundness: \\\\<open>\\\\<tturnstile> p \\\\<Longrightarrow> I \\\\<Turnstile> p\\\\<close>\\n by (induct rule: LT.induct) auto\\n\\ntheorem LT_completeness: \\\\<open>\\\\<forall>I. (I \\\\<Turnstile> p) \\\\<Longrightarrow> \\\\<tturnstile> p\\\\<close>\\n using LT_iff_L1 by (simp add: L1_completeness)\\n\\nsection \\\\<open>Soundness and Completeness\\\\<close>\\n\\ntheorem main: \\\\<open>valid p = \\\\<tturnstile> p\\\\<close>\\n unfolding valid_def using LT_soundness LT_completeness by blast\\n\\nlemmas LT = LT.intros main\\n\\nend\\n\"} {\"text\": \"[STATEMENT]\\nlemma \\n iNext_iEx_iff_singleton : \\\"(\\\\<circle> t t0 I. P t) = (\\\\<diamond> t {inext t0 I}. P t)\\\" and\\n iLast_iEx_iff_singleton : \\\"(\\\\<ominus> t t0 I. P t) = (\\\\<diamond> t {iprev t0 I}. P t)\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. iNext t0 I P = (\\\\<diamond> t {inext t0 I}. P t) &&& iLast t0 I P = (\\\\<diamond> t {iprev t0 I}. P t)\\n[PROOF STEP]\\nby (fastforce simp: iTL_Next_defs iT_add iIN_0)+\"} {\"text\": \"lemma to_fract_eq_0_iff [simp]: \\\"to_fract x = 0 \\\\<longleftrightarrow> x = 0\\\"\"} {\"text\": \"/-\\nCopyright (c) 2018 Chris Hughes. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Chris Hughes, Joey van Langen, Casper Putz\\n-/\\nimport tactic.apply_fun\\nimport data.equiv.ring\\nimport data.zmod.basic\\nimport linear_algebra.basis\\nimport ring_theory.integral_domain\\nimport field_theory.separable\\n\\n/-!\\n# Finite fields\\n\\nThis file contains basic results about finite fields.\\nThroughout most of this file, `K` denotes a finite field\\nand `q` is notation for the cardinality of `K`.\\n\\nSee `ring_theory.integral_domain` for the fact that the unit group of a finite field is a\\ncyclic group, as well as the fact that every finite integral domain is a field\\n(`field_of_integral_domain`).\\n\\n## Main results\\n\\n1. `card_units`: The unit group of a finite field is has cardinality `q - 1`.\\n2. `sum_pow_units`: The sum of `x^i`, where `x` ranges over the units of `K`, is\\n - `q-1` if `q-1 \\u2223 i`\\n - `0` otherwise\\n3. `finite_field.card`: The cardinality `q` is a power of the characteristic of `K`.\\n See `card'` for a variant.\\n\\n## Notation\\n\\nThroughout most of this file, `K` denotes a finite field\\nand `q` is notation for the cardinality of `K`.\\n\\n-/\\n\\nvariables {K : Type*} [field K] [fintype K]\\nvariables {R : Type*} [integral_domain R]\\nlocal notation `q` := fintype.card K\\n\\nopen_locale big_operators\\n\\nnamespace finite_field\\nopen finset function\\n\\nsection polynomial\\n\\nopen polynomial\\n\\n/-- The cardinality of a field is at most `n` times the cardinality of the image of a degree `n`\\n polynomial -/\\nlemma card_image_polynomial_eval [decidable_eq R] [fintype R] {p : polynomial R}\\n (hp : 0 < p.degree) : fintype.card R \\u2264 nat_degree p * (univ.image (\\u03bb x, eval x p)).card :=\\nfinset.card_le_mul_card_image _ _\\n (\\u03bb a _, calc _ = (p - C a).roots.to_finset.card : congr_arg card\\n (by simp [finset.ext_iff, mem_roots_sub_C hp])\\n ... \\u2264 (p - C a).roots.card : multiset.to_finset_card_le _\\n ... \\u2264 _ : card_roots_sub_C' hp)\\n\\n/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\\nlemma exists_root_sum_quadratic [fintype R] {f g : polynomial R} (hf2 : degree f = 2)\\n (hg2 : degree g = 2) (hR : fintype.card R % 2 = 1) : \\u2203 a b, f.eval a + g.eval b = 0 :=\\nby letI := classical.dec_eq R; exact\\nsuffices \\u00ac disjoint (univ.image (\\u03bb x : R, eval x f)) (univ.image (\\u03bb x : R, eval x (-g))),\\nbegin\\n simp only [disjoint_left, mem_image] at this,\\n push_neg at this,\\n rcases this with \\u27e8x, \\u27e8a, _, ha\\u27e9, \\u27e8b, _, hb\\u27e9\\u27e9,\\n exact \\u27e8a, b, by rw [ha, \\u2190 hb, eval_neg, neg_add_self]\\u27e9\\nend,\\nassume hd : disjoint _ _,\\nlt_irrefl (2 * ((univ.image (\\u03bb x : R, eval x f)) \\u222a (univ.image (\\u03bb x : R, eval x (-g)))).card) $\\ncalc 2 * ((univ.image (\\u03bb x : R, eval x f)) \\u222a (univ.image (\\u03bb x : R, eval x (-g)))).card\\n \\u2264 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _)\\n... = fintype.card R + fintype.card R : two_mul _\\n... < nat_degree f * (univ.image (\\u03bb x : R, eval x f)).card +\\n nat_degree (-g) * (univ.image (\\u03bb x : R, eval x (-g))).card :\\n add_lt_add_of_lt_of_le\\n (lt_of_le_of_ne\\n (card_image_polynomial_eval (by rw hf2; exact dec_trivial))\\n (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR])))\\n (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial))\\n... = 2 * (univ.image (\\u03bb x : R, eval x f) \\u222a univ.image (\\u03bb x : R, eval x (-g))).card :\\n by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2,\\n nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]\\n\\nend polynomial\\n\\nlemma card_units : fintype.card (units K) = fintype.card K - 1 :=\\nbegin\\n classical,\\n rw [eq_comm, nat.sub_eq_iff_eq_add (fintype.card_pos_iff.2 \\u27e8(0 : K)\\u27e9)],\\n haveI := set_fintype {a : K | a \\u2260 0},\\n haveI := set_fintype (@set.univ K),\\n rw [fintype.card_congr (equiv.units_equiv_ne_zero _),\\n \\u2190 @set.card_insert _ _ {a : K | a \\u2260 0} _ (not_not.2 (eq.refl (0 : K)))\\n (set.fintype_insert _ _), fintype.card_congr (equiv.set.univ K).symm],\\n congr; simp [set.ext_iff, classical.em]\\nend\\n\\nlemma prod_univ_units_id_eq_neg_one :\\n (\\u220f x : units K, x) = (-1 : units K) :=\\nbegin\\n classical,\\n have : (\\u220f x in (@univ (units K) _).erase (-1), x) = 1,\\n from prod_involution (\\u03bb x _, x\\u207b\\u00b9) (by simp)\\n (\\u03bb a, by simp [units.inv_eq_self_iff] {contextual := tt})\\n (\\u03bb a, by simp [@inv_eq_iff_inv_eq _ _ a, eq_comm] {contextual := tt})\\n (by simp),\\n rw [\\u2190 insert_erase (mem_univ (-1 : units K)), prod_insert (not_mem_erase _ _),\\n this, mul_one]\\nend\\n\\nlemma pow_card_sub_one_eq_one (a : K) (ha : a \\u2260 0) : a ^ (q - 1) = 1 :=\\ncalc a ^ (fintype.card K - 1) = (units.mk0 a ha ^ (fintype.card K - 1) : units K) :\\n by rw [units.coe_pow, units.coe_mk0]\\n ... = 1 : by { classical, rw [\\u2190 card_units, pow_card_eq_one], refl }\\n\\nlemma pow_card (a : K) : a ^ q = a :=\\nbegin\\n have hp : fintype.card K > 0 := fintype.card_pos_iff.2 (by apply_instance),\\n by_cases h : a = 0, { rw h, apply zero_pow hp },\\n rw [\\u2190 nat.succ_pred_eq_of_pos hp, pow_succ, nat.pred_eq_sub_one,\\n pow_card_sub_one_eq_one a h, mul_one],\\nend\\n\\nvariable (K)\\n\\ntheorem card (p : \\u2115) [char_p K p] : \\u2203 (n : \\u2115+), nat.prime p \\u2227 q = p^(n : \\u2115) :=\\nbegin\\n haveI hp : fact p.prime := \\u27e8char_p.char_is_prime K p\\u27e9,\\n letI : module (zmod p) K := { .. (zmod.cast_hom (dvd_refl _) K).to_module },\\n obtain \\u27e8n, h\\u27e9 := vector_space.card_fintype (zmod p) K,\\n rw zmod.card at h,\\n refine \\u27e8\\u27e8n, _\\u27e9, hp.1, h\\u27e9,\\n apply or.resolve_left (nat.eq_zero_or_pos n),\\n rintro rfl,\\n rw pow_zero at h,\\n have : (0 : K) = 1, { apply fintype.card_le_one_iff.mp (le_of_eq h) },\\n exact absurd this zero_ne_one,\\nend\\n\\ntheorem card' : \\u2203 (p : \\u2115) (n : \\u2115+), nat.prime p \\u2227 q = p^(n : \\u2115) :=\\nlet \\u27e8p, hc\\u27e9 := char_p.exists K in \\u27e8p, @finite_field.card K _ _ p hc\\u27e9\\n\\n@[simp] lemma cast_card_eq_zero : (q : K) = 0 :=\\nbegin\\n rcases char_p.exists K with \\u27e8p, _char_p\\u27e9, resetI,\\n rcases card K p with \\u27e8n, hp, hn\\u27e9,\\n simp only [char_p.cast_eq_zero_iff K p, hn],\\n conv { congr, rw [\\u2190 pow_one p] },\\n exact pow_dvd_pow _ n.2,\\nend\\n\\nlemma forall_pow_eq_one_iff (i : \\u2115) :\\n (\\u2200 x : units K, x ^ i = 1) \\u2194 q - 1 \\u2223 i :=\\nbegin\\n obtain \\u27e8x, hx\\u27e9 := is_cyclic.exists_generator (units K),\\n classical,\\n rw [\\u2190 card_units, \\u2190 order_of_eq_card_of_forall_mem_gpowers hx, order_of_dvd_iff_pow_eq_one],\\n split,\\n { intro h, apply h },\\n { intros h y,\\n simp_rw \\u2190 mem_powers_iff_mem_gpowers at hx,\\n rcases hx y with \\u27e8j, rfl\\u27e9,\\n rw [\\u2190 pow_mul, mul_comm, pow_mul, h, one_pow], }\\nend\\n\\n/-- The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\\nis equal to `0` unless `(q - 1) \\u2223 i`, in which case the sum is `q - 1`. -/\\nlemma sum_pow_units (i : \\u2115) :\\n \\u2211 x : units K, (x ^ i : K) = if (q - 1) \\u2223 i then -1 else 0 :=\\nbegin\\n let \\u03c6 : units K \\u2192* K :=\\n { to_fun := \\u03bb x, x ^ i,\\n map_one' := by rw [units.coe_one, one_pow],\\n map_mul' := by { intros, rw [units.coe_mul, mul_pow] } },\\n haveI : decidable (\\u03c6 = 1) := by { classical, apply_instance },\\n calc \\u2211 x : units K, \\u03c6 x = if \\u03c6 = 1 then fintype.card (units K) else 0 : sum_hom_units \\u03c6\\n ... = if (q - 1) \\u2223 i then -1 else 0 : _,\\n suffices : (q - 1) \\u2223 i \\u2194 \\u03c6 = 1,\\n { simp only [this],\\n split_ifs with h h, swap, refl,\\n rw [card_units, nat.cast_sub, cast_card_eq_zero, nat.cast_one, zero_sub],\\n show 1 \\u2264 q, from fintype.card_pos_iff.mpr \\u27e80\\u27e9 },\\n rw [\\u2190 forall_pow_eq_one_iff, monoid_hom.ext_iff],\\n apply forall_congr, intro x,\\n rw [units.ext_iff, units.coe_pow, units.coe_one, monoid_hom.one_apply],\\n refl,\\nend\\n\\n/-- The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\\nis equal to `0` if `i < q - 1`. -/\\nlemma sum_pow_lt_card_sub_one (i : \\u2115) (h : i < q - 1) :\\n \\u2211 x : K, x ^ i = 0 :=\\nbegin\\n by_cases hi : i = 0,\\n { simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero], },\\n classical,\\n have hiq : \\u00ac (q - 1) \\u2223 i, { contrapose! h, exact nat.le_of_dvd (nat.pos_of_ne_zero hi) h },\\n let \\u03c6 : units K \\u21aa K := \\u27e8coe, units.ext\\u27e9,\\n have : univ.map \\u03c6 = univ \\\\ {0},\\n { ext x,\\n simp only [true_and, embedding.coe_fn_mk, mem_sdiff, units.exists_iff_ne_zero,\\n mem_univ, mem_map, exists_prop_of_true, mem_singleton] },\\n calc \\u2211 x : K, x ^ i = \\u2211 x in univ \\\\ {(0 : K)}, x ^ i :\\n by rw [\\u2190 sum_sdiff ({0} : finset K).subset_univ, sum_singleton,\\n zero_pow (nat.pos_of_ne_zero hi), add_zero]\\n ... = \\u2211 x : units K, x ^ i : by { rw [\\u2190 this, univ.sum_map \\u03c6], refl }\\n ... = 0 : by { rw [sum_pow_units K i, if_neg], exact hiq, }\\nend\\n\\nvariables {K}\\n\\ntheorem frobenius_pow {p : \\u2115} [fact p.prime] [char_p K p] {n : \\u2115} (hcard : q = p^n) :\\n (frobenius K p) ^ n = 1 :=\\nbegin\\n ext, conv_rhs { rw [ring_hom.one_def, ring_hom.id_apply, \\u2190 pow_card x, hcard], }, clear hcard,\\n induction n, {simp},\\n rw [pow_succ, pow_succ', pow_mul, ring_hom.mul_def, ring_hom.comp_apply, frobenius_def, n_ih]\\nend\\n\\nopen polynomial\\n\\nlemma expand_card (f : polynomial K) :\\n expand K q f = f ^ q :=\\nbegin\\n cases char_p.exists K with p hp, letI := hp,\\n rcases finite_field.card K p with \\u27e8\\u27e8n, npos\\u27e9, \\u27e8hp, hn\\u27e9\\u27e9, haveI : fact p.prime := \\u27e8hp\\u27e9,\\n dsimp at hn, rw hn at *,\\n rw \\u2190 map_expand_pow_char,\\n rw [frobenius_pow hn, ring_hom.one_def, map_id],\\nend\\n\\nend finite_field\\n\\nnamespace zmod\\n\\nopen finite_field polynomial\\n\\nlemma sq_add_sq (p : \\u2115) [hp : fact p.prime] (x : zmod p) :\\n \\u2203 a b : zmod p, a^2 + b^2 = x :=\\nbegin\\n cases hp.1.eq_two_or_odd with hp2 hp_odd,\\n { substI p, change fin 2 at x, fin_cases x, { use 0, simp }, { use [0, 1], simp } },\\n let f : polynomial (zmod p) := X^2,\\n let g : polynomial (zmod p) := X^2 - C x,\\n obtain \\u27e8a, b, hab\\u27e9 : \\u2203 a b, f.eval a + g.eval b = 0 :=\\n @exists_root_sum_quadratic _ _ _ f g\\n (degree_X_pow 2) (degree_X_pow_sub_C dec_trivial _) (by rw [zmod.card, hp_odd]),\\n refine \\u27e8a, b, _\\u27e9,\\n rw \\u2190 sub_eq_zero,\\n simpa only [eval_C, eval_X, eval_pow, eval_sub, \\u2190 add_sub_assoc] using hab,\\nend\\n\\nend zmod\\n\\nnamespace char_p\\n\\nlemma sq_add_sq (R : Type*) [integral_domain R] (p : \\u2115) [fact (0 < p)] [char_p R p] (x : \\u2124) :\\n \\u2203 a b : \\u2115, (a^2 + b^2 : R) = x :=\\nbegin\\n haveI := char_is_prime_of_pos R p,\\n obtain \\u27e8a, b, hab\\u27e9 := zmod.sq_add_sq p x,\\n refine \\u27e8a.val, b.val, _\\u27e9,\\n simpa using congr_arg (zmod.cast_hom (dvd_refl _) R) hab\\nend\\n\\nend char_p\\n\\nopen_locale nat\\nopen zmod\\n\\n/-- The Fermat-Euler totient theorem. `nat.modeq.pow_totient` is an alternative statement\\n of the same theorem. -/\\n@[simp] lemma zmod.pow_totient {n : \\u2115} [fact (0 < n)] (x : units (zmod n)) : x ^ \\u03c6 n = 1 :=\\nby rw [\\u2190 card_units_eq_totient, pow_card_eq_one]\\n\\n/-- The Fermat-Euler totient theorem. `zmod.pow_totient` is an alternative statement\\n of the same theorem. -/\\nlemma nat.modeq.pow_totient {x n : \\u2115} (h : nat.coprime x n) : x ^ \\u03c6 n \\u2261 1 [MOD n] :=\\nbegin\\n cases n, {simp},\\n rw \\u2190 zmod.eq_iff_modeq_nat,\\n let x' : units (zmod (n+1)) := zmod.unit_of_coprime _ h,\\n have := zmod.pow_totient x',\\n apply_fun (coe : units (zmod (n+1)) \\u2192 zmod (n+1)) at this,\\n simpa only [-zmod.pow_totient, nat.succ_eq_add_one, nat.cast_pow, units.coe_one,\\n nat.cast_one, coe_unit_of_coprime, units.coe_pow],\\nend\\n\\nopen finite_field\\nnamespace zmod\\n\\n/-- A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one` -/\\n@[simp] lemma pow_card {p : \\u2115} [fact p.prime] (x : zmod p) : x ^ p = x :=\\nby { have h := finite_field.pow_card x, rwa zmod.card p at h }\\n\\n@[simp] lemma frobenius_zmod (p : \\u2115) [fact p.prime] :\\n frobenius (zmod p) p = ring_hom.id _ :=\\nby { ext a, rw [frobenius_def, zmod.pow_card, ring_hom.id_apply] }\\n\\n@[simp] lemma card_units (p : \\u2115) [fact p.prime] : fintype.card (units (zmod p)) = p - 1 :=\\nby rw [card_units, card]\\n\\n/-- Fermat's Little Theorem: for every unit `a` of `zmod p`, we have `a ^ (p - 1) = 1`. -/\\ntheorem units_pow_card_sub_one_eq_one (p : \\u2115) [fact p.prime] (a : units (zmod p)) :\\n a ^ (p - 1) = 1 :=\\nby rw [\\u2190 card_units p, pow_card_eq_one]\\n\\n/-- Fermat's Little Theorem: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`. -/\\ntheorem pow_card_sub_one_eq_one {p : \\u2115} [fact p.prime] {a : zmod p} (ha : a \\u2260 0) :\\n a ^ (p - 1) = 1 :=\\nby { have h := pow_card_sub_one_eq_one a ha, rwa zmod.card p at h }\\n\\nopen polynomial\\n\\nlemma expand_card {p : \\u2115} [fact p.prime] (f : polynomial (zmod p)) :\\n expand (zmod p) p f = f ^ p :=\\nby { have h := finite_field.expand_card f, rwa zmod.card p at h }\\n\\nend zmod\\n\"} {\"text\": \"/-\\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Jireh Loreaux\\n-/\\nimport analysis.normed_space.star.basic\\nimport analysis.normed_space.spectrum\\nimport analysis.normed_space.star.exponential\\nimport analysis.special_functions.exponential\\nimport algebra.star.star_alg_hom\\n\\n/-! # Spectral properties in C\\u22c6-algebras\\nIn this file, we establish various properties related to the spectrum of elements in C\\u22c6-algebras.\\n-/\\n\\nlocal postfix `\\u22c6`:std.prec.max_plus := star\\n\\nsection\\n\\nopen_locale topology ennreal\\nopen filter ennreal spectrum cstar_ring\\n\\nsection unitary_spectrum\\n\\nvariables\\n{\\ud835\\udd5c : Type*} [normed_field \\ud835\\udd5c]\\n{E : Type*} [normed_ring E] [star_ring E] [cstar_ring E]\\n[normed_algebra \\ud835\\udd5c E] [complete_space E]\\n\\nlemma unitary.spectrum_subset_circle (u : unitary E) :\\n spectrum \\ud835\\udd5c (u : E) \\u2286 metric.sphere 0 1 :=\\nbegin\\n nontriviality E,\\n refine \\u03bb k hk, mem_sphere_zero_iff_norm.mpr (le_antisymm _ _),\\n { simpa only [cstar_ring.norm_coe_unitary u] using norm_le_norm_of_mem hk },\\n { rw \\u2190unitary.coe_to_units_apply u at hk,\\n have hnk := ne_zero_of_mem_of_unit hk,\\n rw [\\u2190inv_inv (unitary.to_units u), \\u2190spectrum.map_inv, set.mem_inv] at hk,\\n have : \\u2016k\\u2016\\u207b\\u00b9 \\u2264 \\u2016\\u2191((unitary.to_units u)\\u207b\\u00b9)\\u2016, simpa only [norm_inv] using norm_le_norm_of_mem hk,\\n simpa using inv_le_of_inv_le (norm_pos_iff.mpr hnk) this }\\nend\\n\\nlemma spectrum.subset_circle_of_unitary {u : E} (h : u \\u2208 unitary E) :\\n spectrum \\ud835\\udd5c u \\u2286 metric.sphere 0 1 :=\\nunitary.spectrum_subset_circle \\u27e8u, h\\u27e9\\n\\nend unitary_spectrum\\n\\nsection complex_scalars\\n\\nopen complex\\n\\nvariables {A : Type*}\\n[normed_ring A] [normed_algebra \\u2102 A] [complete_space A] [star_ring A] [cstar_ring A]\\n\\nlocal notation `\\u2191\\u2090` := algebra_map \\u2102 A\\n\\nlemma is_self_adjoint.spectral_radius_eq_nnnorm {a : A}\\n (ha : is_self_adjoint a) :\\n spectral_radius \\u2102 a = \\u2016a\\u2016\\u208a :=\\nbegin\\n have hconst : tendsto (\\u03bb n : \\u2115, (\\u2016a\\u2016\\u208a : \\u211d\\u22650\\u221e)) at_top _ := tendsto_const_nhds,\\n refine tendsto_nhds_unique _ hconst,\\n convert (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a : A)).comp\\n (nat.tendsto_pow_at_top_at_top_of_one_lt one_lt_two),\\n refine funext (\\u03bb n, _),\\n rw [function.comp_app, ha.nnnorm_pow_two_pow, ennreal.coe_pow, \\u2190rpow_nat_cast,\\n \\u2190rpow_mul],\\n simp,\\nend\\n\\nlemma is_star_normal.spectral_radius_eq_nnnorm (a : A) [is_star_normal a] :\\n spectral_radius \\u2102 a = \\u2016a\\u2016\\u208a :=\\nbegin\\n refine (ennreal.pow_strict_mono two_ne_zero).injective _,\\n have heq : (\\u03bb n : \\u2115, ((\\u2016(a\\u22c6 * a) ^ n\\u2016\\u208a ^ (1 / n : \\u211d)) : \\u211d\\u22650\\u221e))\\n = (\\u03bb x, x ^ 2) \\u2218 (\\u03bb n : \\u2115, ((\\u2016a ^ n\\u2016\\u208a ^ (1 / n : \\u211d)) : \\u211d\\u22650\\u221e)),\\n { funext,\\n rw [function.comp_apply, \\u2190rpow_nat_cast, \\u2190rpow_mul, mul_comm, rpow_mul, rpow_nat_cast,\\n \\u2190coe_pow, sq, \\u2190nnnorm_star_mul_self, commute.mul_pow (star_comm_self' a), star_pow], },\\n have h\\u2082 := ((ennreal.continuous_pow 2).tendsto (spectral_radius \\u2102 a)).comp\\n (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius a),\\n rw \\u2190heq at h\\u2082,\\n convert tendsto_nhds_unique h\\u2082 (pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a\\u22c6 * a)),\\n rw [(is_self_adjoint.star_mul_self a).spectral_radius_eq_nnnorm, sq, nnnorm_star_mul_self,\\n coe_mul],\\nend\\n\\n/-- Any element of the spectrum of a selfadjoint is real. -/\\ntheorem is_self_adjoint.mem_spectrum_eq_re [star_module \\u2102 A] {a : A}\\n (ha : is_self_adjoint a) {z : \\u2102} (hz : z \\u2208 spectrum \\u2102 a) : z = z.re :=\\nbegin\\n have hu := exp_mem_unitary_of_mem_skew_adjoint \\u2102 (ha.smul_mem_skew_adjoint conj_I),\\n let Iu := units.mk0 I I_ne_zero,\\n have : exp \\u2102 (I \\u2022 z) \\u2208 spectrum \\u2102 (exp \\u2102 (I \\u2022 a)),\\n by simpa only [units.smul_def, units.coe_mk0]\\n using spectrum.exp_mem_exp (Iu \\u2022 a) (smul_mem_smul_iff.mpr hz),\\n exact complex.ext (of_real_re _)\\n (by simpa only [\\u2190complex.exp_eq_exp_\\u2102, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,\\n real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero]\\n using spectrum.subset_circle_of_unitary hu this),\\nend\\n\\n/-- Any element of the spectrum of a selfadjoint is real. -/\\ntheorem self_adjoint.mem_spectrum_eq_re [star_module \\u2102 A]\\n (a : self_adjoint A) {z : \\u2102} (hz : z \\u2208 spectrum \\u2102 (a : A)) : z = z.re :=\\na.prop.mem_spectrum_eq_re hz\\n\\n/-- The spectrum of a selfadjoint is real -/\\ntheorem is_self_adjoint.coe_re_map_spectrum [star_module \\u2102 A] {a : A}\\n (ha : is_self_adjoint a) : spectrum \\u2102 a = (coe \\u2218 re '' (spectrum \\u2102 a) : set \\u2102) :=\\nle_antisymm (\\u03bb z hz, \\u27e8z, hz, (ha.mem_spectrum_eq_re hz).symm\\u27e9) (\\u03bb z, by\\n { rintros \\u27e8z, hz, rfl\\u27e9,\\n simpa only [(ha.mem_spectrum_eq_re hz).symm, function.comp_app] using hz })\\n\\n/-- The spectrum of a selfadjoint is real -/\\ntheorem self_adjoint.coe_re_map_spectrum [star_module \\u2102 A] (a : self_adjoint A) :\\n spectrum \\u2102 (a : A) = (coe \\u2218 re '' (spectrum \\u2102 (a : A)) : set \\u2102) :=\\na.property.coe_re_map_spectrum\\n\\nend complex_scalars\\n\\nnamespace star_alg_hom\\n\\nvariables {F A B : Type*}\\n[normed_ring A] [normed_algebra \\u2102 A] [complete_space A] [star_ring A] [cstar_ring A]\\n[normed_ring B] [normed_algebra \\u2102 B] [complete_space B] [star_ring B] [cstar_ring B]\\n[hF : star_alg_hom_class F \\u2102 A B] (\\u03c6 : F)\\ninclude hF\\n\\n/-- A star algebra homomorphism of complex C\\u22c6-algebras is norm contractive. -/\\nlemma nnnorm_apply_le (a : A) : \\u2016(\\u03c6 a : B)\\u2016\\u208a \\u2264 \\u2016a\\u2016\\u208a :=\\nbegin\\n suffices : \\u2200 s : A, is_self_adjoint s \\u2192 \\u2016\\u03c6 s\\u2016\\u208a \\u2264 \\u2016s\\u2016\\u208a,\\n { exact nonneg_le_nonneg_of_sq_le_sq zero_le'\\n (by simpa only [nnnorm_star_mul_self, map_star, map_mul]\\n using this _ (is_self_adjoint.star_mul_self a)) },\\n { intros s hs,\\n simpa only [hs.spectral_radius_eq_nnnorm, (hs.star_hom_apply \\u03c6).spectral_radius_eq_nnnorm,\\n coe_le_coe] using (show spectral_radius \\u2102 (\\u03c6 s) \\u2264 spectral_radius \\u2102 s,\\n from supr_le_supr_of_subset (alg_hom.spectrum_apply_subset \\u03c6 s)) }\\nend\\n\\n/-- A star algebra homomorphism of complex C\\u22c6-algebras is norm contractive. -/\\nlemma norm_apply_le (a : A) : \\u2016(\\u03c6 a : B)\\u2016 \\u2264 \\u2016a\\u2016 := nnnorm_apply_le \\u03c6 a\\n\\n/-- Star algebra homomorphisms between C\\u22c6-algebras are continuous linear maps.\\nSee note [lower instance priority] -/\\n@[priority 100]\\nnoncomputable instance : continuous_linear_map_class F \\u2102 A B :=\\n{ map_continuous := \\u03bb \\u03c6, add_monoid_hom_class.continuous_of_bound \\u03c6 1\\n (by simpa only [one_mul] using nnnorm_apply_le \\u03c6),\\n .. alg_hom_class.linear_map_class }\\n\\nend star_alg_hom\\n\\nend\\n\\nnamespace weak_dual\\n\\nopen continuous_map complex\\nopen_locale complex_star_module\\n\\nvariables {F A : Type*} [normed_ring A] [normed_algebra \\u2102 A] [complete_space A]\\n [star_ring A] [cstar_ring A] [star_module \\u2102 A] [hF : alg_hom_class F \\u2102 A \\u2102]\\n\\ninclude hF\\n\\n/-- This instance is provided instead of `star_alg_hom_class` to avoid type class inference loops.\\nSee note [lower instance priority] -/\\n@[priority 100]\\nnoncomputable instance : star_hom_class F A \\u2102 :=\\n{ coe := \\u03bb \\u03c6, \\u03c6,\\n coe_injective' := fun_like.coe_injective',\\n map_star := \\u03bb \\u03c6 a,\\n begin\\n suffices hsa : \\u2200 s : self_adjoint A, (\\u03c6 s)\\u22c6 = \\u03c6 s,\\n { rw \\u2190real_part_add_I_smul_imaginary_part a,\\n simp only [map_add, map_smul, star_add, star_smul, hsa, self_adjoint.star_coe_eq] },\\n { intros s,\\n have := alg_hom.apply_mem_spectrum \\u03c6 (s : A),\\n rw self_adjoint.coe_re_map_spectrum s at this,\\n rcases this with \\u27e8\\u27e8_, _\\u27e9, _, heq\\u27e9,\\n rw [\\u2190heq, is_R_or_C.star_def, is_R_or_C.conj_of_real] }\\n end }\\n\\n/-- This is not an instance to avoid type class inference loops. See\\n`weak_dual.complex.star_hom_class`. -/\\nnoncomputable def _root_.alg_hom_class.star_alg_hom_class : star_alg_hom_class F \\u2102 A \\u2102 :=\\n{ coe := \\u03bb f, f,\\n .. weak_dual.complex.star_hom_class,\\n .. hF }\\n\\nomit hF\\n\\nnamespace character_space\\n\\nnoncomputable instance : star_alg_hom_class (character_space \\u2102 A) \\u2102 A \\u2102 :=\\n{ coe := \\u03bb f, f,\\n .. alg_hom_class.star_alg_hom_class }\\n\\nend character_space\\n\\nend weak_dual\\n\"} {\"text\": \"import data.list.basic\\nopen list\\nuniverse u\\nvariables {\\u03b1 : Type} (x y z : \\u03b1) (xs ys zs : list \\u03b1)\\n\\ndef mk_symm (xs : list \\u03b1) := xs ++ reverse xs\\n\\ntheorem reverse_mk_symm (xs : list \\u03b1) :\\n reverse (mk_symm xs) = mk_symm xs :=\\n by simp [mk_symm]\\n\"} {\"text\": \"in",
    "formal_statement": "Let $X$ be a compact Hausdorff space. Let $\\\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\\\bigcap_{A \\\\in \\\\mathcal{A}} A$ is connected.formal statement theorem exercise_27_4\\n {X : Type*} [metric_space X] [connected_space X] (hX : \\u2203 x y : X, x \\u2260 y) :\\n \\u00ac countable (univ : set X)"
  },
  {
    "informal_statement": "is: The number 2 is prime.\"} {\"text\": \"{- This example goes through now that we allow instantiation of\\n blocked terms #-}\\nmodule Issue439 where\\n\\nrecord \\u03a3 (A : Set) (B : A \\u2192 Set) : Set where\\n constructor _,_\\n field\\n p\\u2081 : A\\n p\\u2082 : B p\\u2081\\n\\nopen \\u03a3\\n\\nrecord \\u22a4 : Set where\\n\\ndata Tree : Set where\\n leaf : Tree\\n node : Tree \\u2192 Tree \\u2192 Tree\\n\\nmutual\\n\\n U : Tree \\u2192 Set\\n U leaf = \\u22a4\\n U (node tr\\u2081 tr\\u2082) = \\u03a3 (U tr\\u2081) \\u03bb a \\u2192 El a \\u2192 U tr\\u2082\\n\\n El : \\u2200 {tr} \\u2192 U tr \\u2192 Set\\n El {leaf} _ = \\u22a4\\n El {node tr\\u2081 tr\\u2082} (a , b) = (x : El a) \\u2192 El (b x)\\n\\nmutual\\n\\n data C : Set where\\n c : (\\u0393 : C) \\u2192 T \\u0393 \\u2192 C\\n\\n T : C \\u2192 Set\\n T \\u0393 = \\u03a3 Tree (\\u03bb tr \\u2192 E \\u0393 \\u2192 U tr)\\n\\n E : C \\u2192 Set\\n E (c \\u0393 \\u03c3) = \\u03a3 (E \\u0393) \\u03bb \\u03b3 \\u2192 El (p\\u2082 \\u03c3 \\u03b3)\\n\\npostulate\\n e : C\\n M : (\\u0393 : C) \\u2192 T \\u0393 \\u2192 Set\\n z : \\u2200 {\\u0393 \\u03c3} \\u2192 M (c \\u0393 \\u03c3) (p\\u2081 \\u03c3 , \\u03bb \\u03b3 \\u2192 p\\u2082 \\u03c3 (p\\u2081 \\u03b3))\\n l : \\u2200 {\\u0393} \\u03c3 {\\u03c4} \\u2192 M (c \\u0393 \\u03c3) \\u03c4 \\u2192\\n M \\u0393 (_ , \\u03bb \\u03b3 \\u2192 p\\u2082 \\u03c3 \\u03b3 , \\u03bb v \\u2192 p\\u2082 \\u03c4 (\\u03b3 , v))\\n a : \\u2200 {\\u0393 tr\\u2081 tr\\u2082 \\u03c3} \\u2192\\n M \\u0393 (node tr\\u2081 tr\\u2082 , \\u03c3) \\u2192 M \\u0393 (tr\\u2081 , \\u03bb \\u03b3 \\u2192 p\\u2081 (\\u03c3 \\u03b3)) \\u2192\\n M \\u0393 (leaf , _)\\n s : \\u2200 {\\u0393} \\u2192 M \\u0393 (leaf , _)\\n\\nt : \\u2200 {\\u0393 \\u03c3} \\u2192 M \\u0393 \\u03c3 \\u2192 T \\u0393\\nt {\\u03c3 = \\u03c3} _ = \\u03c3\\n\\nfoo : M (c e (leaf , _)) (leaf , _)\\nfoo = a (l (t s) z) z\\n\"} {\"text\": \"def p (x : Nat := 0) : Nat \\u00d7 Nat :=\\n(x, x)\\n\\ntheorem ex1 : p.1 = 0 :=\\nrfl\\n\\ntheorem ex2 : (p (x := 1) |>.2) = 1 :=\\nrfl\\n\\ndef c {\\u03b1 : Type} [Inhabited \\u03b1] : \\u03b1 \\u00d7 \\u03b1 :=\\n(default, default)\\n\\ntheorem ex3 {\\u03b1} [Inhabited \\u03b1] : c.1 = default (\\u03b1 := \\u03b1) :=\\nrfl\\n\\ntheorem ex4 {\\u03b1} [Inhabited \\u03b1] : c.2 = default (\\u03b1 := \\u03b1) :=\\nrfl\\n\"} {\"text\": \"[STATEMENT]\\nlemma orthogonal_complement_antimono_iff[simp]:\\n fixes A B :: \\\\<open>('a::chilbert_space) set\\\\<close>\\n assumes \\\\<open>closed_csubspace A\\\\<close> and \\\\<open>closed_csubspace B\\\\<close>\\n shows \\\\<open>orthogonal_complement A \\\\<subseteq> orthogonal_complement B \\\\<longleftrightarrow> A \\\\<supseteq> B\\\\<close>\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. (orthogonal_complement A \\\\<subseteq> orthogonal_complement B) = (B \\\\<subseteq> A)\\n[PROOF STEP]\\nproof (rule iffI)\\n[PROOF STATE]\\nproof (state)\\ngoal (2 subgoals):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B \\\\<Longrightarrow> B \\\\<subseteq> A\\n 2. B \\\\<subseteq> A \\\\<Longrightarrow> orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\n[PROOF STEP]\\nshow \\\\<open>orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\\\<close> if \\\\<open>A \\\\<supseteq> B\\\\<close>\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\n[PROOF STEP]\\nusing that\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nB \\\\<subseteq> A\\n\\ngoal (1 subgoal):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\n[PROOF STEP]\\nby auto\\n[PROOF STATE]\\nproof (state)\\nthis:\\nB \\\\<subseteq> A \\\\<Longrightarrow> orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\n\\ngoal (1 subgoal):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B \\\\<Longrightarrow> B \\\\<subseteq> A\\n[PROOF STEP]\\nassume \\\\<open>orthogonal_complement A \\\\<subseteq> orthogonal_complement B\\\\<close>\\n[PROOF STATE]\\nproof (state)\\nthis:\\northogonal_complement A \\\\<subseteq> orthogonal_complement B\\n\\ngoal (1 subgoal):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B \\\\<Longrightarrow> B \\\\<subseteq> A\\n[PROOF STEP]\\nthen\\n[PROOF STATE]\\nproof (chain)\\npicking this:\\northogonal_complement A \\\\<subseteq> orthogonal_complement B\\n[PROOF STEP]\\nhave \\\\<open>orthogonal_complement (orthogonal_complement A) \\\\<supseteq> orthogonal_complement (orthogonal_complement B)\\\\<close>\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\northogonal_complement A \\\\<subseteq> orthogonal_complement B\\n\\ngoal (1 subgoal):\\n 1. orthogonal_complement (orthogonal_complement B) \\\\<subseteq> orthogonal_complement (orthogonal_complement A)\\n[PROOF STEP]\\nby simp\\n[PROOF STATE]\\nproof (state)\\nthis:\\northogonal_complement (orthogonal_complement B) \\\\<subseteq> orthogonal_complement (orthogonal_complement A)\\n\\ngoal (1 subgoal):\\n 1. orthogonal_complement A \\\\<subseteq> orthogonal_complement B \\\\<Longrightarrow> B \\\\<subseteq> A\\n[PROOF STEP]\\nthen\\n[PROOF STATE]\\nproof (chain)\\npicking this:\\northogonal_complement (orthogonal_complement B) \\\\<subseteq> orthogonal_complement (orthogonal_complement A)\\n[PROOF STEP]\\nshow \\\\<open>A \\\\<supseteq> B\\\\<close>\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\northogonal_complement (orthogonal_complement B) \\\\<subseteq> orthogonal_complement (orthogonal_complement A)\\n\\ngoal (1 subgoal):\\n 1. B \\\\<subseteq> A\\n[PROOF STEP]\\nusing assms\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\northogonal_complement (orthogonal_complement B) \\\\<subseteq> orthogonal_complement (orthogonal_complement A)\\nclosed_csubspace A\\nclosed_csubspace B\\n\\ngoal (1 subgoal):\\n 1. B \\\\<subseteq> A\\n[PROOF STEP]\\nby auto\\n[PROOF STATE]\\nproof (state)\\nthis:\\nB \\\\<subseteq> A\\n\\ngoal:\\nNo subgoals!\\n[PROOF STEP]\\nqed\"} {\"text\": \"State Before: \\u22a2 ord \\u2218 aleph = enumOrd {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} State After: \\u22a2 StrictMono (ord \\u2218 aleph) \\u2227 range (ord \\u2218 aleph) = {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} Tactic: rw [\\u2190 eq_enumOrd _ ord_card_unbounded'] State Before: \\u22a2 StrictMono (ord \\u2218 aleph) \\u2227 range (ord \\u2218 aleph) = {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} State After: \\u22a2 range (ord \\u2218 aleph) = {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} Tactic: use aleph_isNormal.strictMono State Before: \\u22a2 range (ord \\u2218 aleph) = {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} State After: \\u22a2 (\\u2200 (a : Ordinal), (ord \\u2218 aleph) a \\u2208 {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b}) \\u2227\\n \\u2200 (b : Ordinal), b \\u2208 {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} \\u2192 \\u2203 a, (ord \\u2218 aleph) a = b Tactic: rw [range_eq_iff] State Before: \\u22a2 (\\u2200 (a : Ordinal), (ord \\u2218 aleph) a \\u2208 {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b}) \\u2227\\n \\u2200 (b : Ordinal), b \\u2208 {b | ord (card b) = b \\u2227 \\u03c9 \\u2264 b} \\u2192 \\u2203 a, (ord \\u2218 aleph) a = b State After: case refine'_1\\na : Ordinal\\n\\u22a2 ord (card ((ord \\u2218 aleph) a)) = (ord \\u2218 aleph) a\\n\\ncase refine'_2\\na : Ordinal\\n\\u22a2 \\u03c9 \\u2264 (ord \\u2218 aleph) a Tactic: refine' \\u27e8fun a => \\u27e8_, _\\u27e9, fun b hb => eq_aleph_of_eq_card_ord hb.1 hb.2\\u27e9 State Before: case refine'_1\\na : Ordinal\\n\\u22a2 ord (card ((ord \\u2218 aleph) a)) = (ord \\u2218 aleph) a State After: no goals Tactic: rw [Function.comp_apply, card_ord] State Before: case refine'_2\\na : Ordinal\\n\\u22a2 \\u03c9 \\u2264 (ord \\u2218 aleph) a State After: case refine'_2\\na : Ordinal\\n\\u22a2 \\u2135\\u2080 \\u2264 aleph a Tactic: rw [\\u2190 ord_aleph0, Function.comp_apply, ord_le_ord] State Before: case refine'_2\\na : Ordinal\\n\\u22a2 \\u2135\\u2080 \\u2264 aleph a State After: no goals Tactic: exact aleph0_le_aleph _\"} {\"text\": \"[STATEMENT]\\nlemma currentLevelPrefixToLevel_aux: \\n assumes \\\"l \\\\<ge> i\\\"\\n shows \\\"currentLevel (prefixToLevel_aux M l i) <= l - i\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i\\n[PROOF STEP]\\nusing assms\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i\\n[PROOF STEP]\\nproof (induct M arbitrary: i)\\n[PROOF STATE]\\nproof (state)\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\ncase (Cons m M')\\n[PROOF STATE]\\nproof (state)\\nthis:\\n?i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\\\<le> l - ?i\\ni \\\\<le> l\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n{\\n[PROOF STATE]\\nproof (state)\\nthis:\\n?i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\\\<le> l - ?i\\ni \\\\<le> l\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nassume \\\"marked m\\\" \\\"i = l\\\"\\n[PROOF STATE]\\nproof (state)\\nthis:\\nmarked m\\ni = l\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nhence ?case\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nmarked m\\ni = l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nunfolding currentLevel_def\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nmarked m\\ni = l\\n\\ngoal (1 subgoal):\\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\\\<le> l - i\\n[PROOF STEP]\\nby simp\\n[PROOF STATE]\\nproof (state)\\nthis:\\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n}\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nmoreover\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n{\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nassume \\\"marked m\\\" \\\"i < l\\\"\\n[PROOF STATE]\\nproof (state)\\nthis:\\nmarked m\\ni < l\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nhence ?case\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nmarked m\\ni < l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nusing Cons(1) [of \\\"i+1\\\"]\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nmarked m\\ni < l\\ni + 1 \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M' l (i + 1)) \\\\<le> l - (i + 1)\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nunfolding currentLevel_def\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\nmarked m\\ni < l\\ni + 1 \\\\<le> l \\\\<Longrightarrow> length (markedElements (prefixToLevel_aux M' l (i + 1))) \\\\<le> l - (i + 1)\\n\\ngoal (1 subgoal):\\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\\\<le> l - i\\n[PROOF STEP]\\nby simp\\n[PROOF STATE]\\nproof (state)\\nthis:\\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n}\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nmoreover\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n{\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nassume \\\"\\\\<not> marked m\\\"\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<not> marked m\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nhence ?case\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\n\\\\<not> marked m\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nusing Cons\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\n\\\\<not> marked m\\n?i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\\\<le> l - ?i\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nunfolding currentLevel_def\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\n\\\\<not> marked m\\n?i \\\\<le> l \\\\<Longrightarrow> length (markedElements (prefixToLevel_aux M' l ?i)) \\\\<le> l - ?i\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\\\<le> l - i\\n[PROOF STEP]\\nby simp\\n[PROOF STATE]\\nproof (state)\\nthis:\\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\n}\\n[PROOF STATE]\\nproof (state)\\nthis:\\n\\\\<not> marked m \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (2 subgoals):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n 2. \\\\<And>a M i. \\\\<lbrakk>\\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\\\<le> l - i; i \\\\<le> l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\\\<le> l - i\\n[PROOF STEP]\\nultimately\\n[PROOF STATE]\\nproof (chain)\\npicking this:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<not> marked m \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nshow ?case\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<not> marked m \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nusing \\\\<open>i <= l\\\\<close>\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\n\\\\<lbrakk>marked m; i = l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<lbrakk>marked m; i < l\\\\<rbrakk> \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\\\<not> marked m \\\\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n[PROOF STEP]\\nby auto\\n[PROOF STATE]\\nproof (state)\\nthis:\\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\\\<le> l - i\\n\\ngoal (1 subgoal):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n[PROOF STEP]\\nnext\\n[PROOF STATE]\\nproof (state)\\ngoal (1 subgoal):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n[PROOF STEP]\\ncase Nil\\n[PROOF STATE]\\nproof (state)\\nthis:\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. \\\\<And>i. i \\\\<le> l \\\\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n[PROOF STEP]\\nthus ?case\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. currentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n[PROOF STEP]\\nunfolding currentLevel_def\\n[PROOF STATE]\\nproof (prove)\\nusing this:\\ni \\\\<le> l\\n\\ngoal (1 subgoal):\\n 1. length (markedElements (prefixToLevel_aux [] l i)) \\\\<le> l - i\\n[PROOF STEP]\\nby simp\\n[PROOF STATE]\\nproof (state)\\nthis:\\ncurrentLevel (prefixToLevel_aux [] l i) \\\\<le> l - i\\n\\ngoal:\\nNo subgoals!\\n[PROOF STEP]\\nqed\"} {\"text\": \"[GOAL]\\nx y : Path PUnit.unit PUnit.unit\\n\\u22a2 x = y\\n[PROOFSTEP]\\next\\n[GOAL]\\nx y : FundamentalGroupoid PUnit\\n\\u22a2 Subsingleton (x \\u27f6 y)\\n[PROOFSTEP]\\nconvert_to Subsingleton (Path.Homotopic.Quotient PUnit.unit PUnit.unit)\\n[GOAL]\\nx y : FundamentalGroupoid PUnit\\n\\u22a2 Subsingleton (Path.Homotopic.Quotient PUnit.unit PUnit.unit)\\n[PROOFSTEP]\\napply Quotient.instSubsingletonQuotient\\n[GOAL]\\nx\\u271d : FundamentalGroupoid PUnit\\n\\u22a2 (\\ud835\\udfed (FundamentalGroupoid PUnit)).obj x\\u271d =\\n (Functor.star (FundamentalGroupoid PUnit) \\u22d9 (Functor.const (Discrete PUnit)).obj PUnit.unit).obj x\\u271d\\n[PROOFSTEP]\\nsimp\\n\"} {\"text\": \"corollary fps_coeff_residues_bigo': fixes f :: \\\"complex \\\\<Rightarrow> complex\\\" and r :: real assumes exp: \\\"f has_fps_expansion F\\\" assumes \\\"open A\\\" \\\"connected A\\\" \\\"cball 0 r \\\\<subseteq> A\\\" \\\"r > 0\\\" assumes \\\"f holomorphic_on A - S\\\" \\\"S \\\\<subseteq> ball 0 r\\\" \\\"finite S\\\" \\\"0 \\\\<notin> S\\\" assumes \\\"eventually (\\\\<lambda>n. g n = -(\\\\<Sum>z\\\\<in>S. residue (\\\\<lambda>z. f z / z ^ Suc n) z)) sequentially\\\" (is \\\"eventually (\\\\<lambda>n. _ = -?g' n) _\\\") shows \\\"(\\\\<lambda>n. fps_nth F n - g n) \\\\<in> O(\\\\<lambda>n. 1 / r ^ n)\\\" (is \\\"(\\\\<lambda>n. ?c n - _) \\\\<in> O(_)\\\")\"} {\"text\": \"State Before: m : Type u_1 \\u2192 Type u_2\\n\\u03b1 : Type u_3\\n\\u03b2 : Type u_1\\ninst\\u271d\\u00b9 : Monad m\\ninst\\u271d : LawfulMonad m\\nf : \\u03b1 \\u2192 m \\u03b2\\nl : List \\u03b1\\n\\u22a2 mapM' f l = mapM f l State After: no goals Tactic: simp [go, mapM] State Before: m : Type u_1 \\u2192 Type u_2\\n\\u03b1 : Type u_3\\n\\u03b2 : Type u_1\\ninst\\u271d\\u00b9 : Monad m\\ninst\\u271d : LawfulMonad m\\nf : \\u03b1 \\u2192 m \\u03b2\\nl : List \\u03b1\\nacc : List \\u03b2\\n\\u22a2 mapM.loop f [] acc = do\\n let __do_lift \\u2190 mapM' f []\\n pure (reverse acc ++ __do_lift) State After: no goals Tactic: simp State Before: m : Type u_1 \\u2192 Type u_2\\n\\u03b1 : Type u_3\\n\\u03b2 : Type u_1\\ninst\\u271d\\u00b9 : Monad m\\ninst\\u271d : LawfulMonad m\\nf : \\u03b1 \\u2192 m \\u03b2\\nl\\u271d : List \\u03b1\\na : \\u03b1\\nl : List \\u03b1\\nacc : List \\u03b2\\n\\u22a2 mapM.loop f (a :: l) acc = do\\n let __do_lift \\u2190 mapM' f (a :: l)\\n pure (reverse acc ++ __do_lift) State After: no goals Tactic: simp [go l]\"} {\"text\": \"\\n/--\\nFrom Sets to Relations\\n\\nTake-away message. Whereas we represent a set\\nas a one-place predicate, we will represent a\\nbinary relation as a two-place predicate. Just\\nas a set is a collection of individual objects\\nthat satisfy a predicate, a relation is a set\\nof *pairs* of objects, each of which satisfies\\nthe pair membership predicate for the relation. \\n--/\\n\\n/-\\nExample: negation_as_a_binary_relation on bool.\\n-/\\n\\ndef negation : bool \\u2192 bool \\u2192 Prop\\n| tt ff := true\\n| ff tt := true\\n| _ _ := false\\n\\n/-\\nThis predicate specifies the binary \\nrelation, {(tt, ff), (ff, tt)}. Each\\nmember of the relation is an ordered\\npair of Boolean values. The relation\\ncomprises the set of all of the pairs \\nthat satisfy the predicate: make the\\nresulting proposition true. Other pairs \\nof Booleans do not satisfy the predicate\\nand so are not in the relation that it\\nspecifies. \\n-/\\n\\n/-\\n\\nNote that unlike with the Boolean\\nnegation function, bnot, we cannot\\n\\\"compute\\\" with predicates; we can\\nonly try to prove that a pair of \\nvalues (in this case) satisfy them.\\n-/\\n\\n-- functions compute\\n#eval bnot tt -- (tt, ff)\\n#eval bnot ff -- (ff, tt)\\n-- takes a single bool, returns a bool\\n\\nexample : negation tt ff := \\nbegin\\nunfold negation,\\nend \\n\\nexample : negation ff tt := by unfold negation -- Lean syntax\\n\\n-- takes two bools, returns a proposition\\n-- that proposition then has to be proved \\n-- can use \\\"by\\\" when script is a single tactic\\n\\nexample : \\u00ac negation tt tt :=\\nbegin\\nassume h,\\ncases h,\\nend \\n\\n/-\\nExercise: Formally state and prove the proposition\\nthat for all Boolean values, b1 and b2, negation b1 \\nb2 \\u2194 bnot b1 = b2. This proposition claims that the\\nbnot function applied to a Boolean value, b1, equals\\nb2, if and only if the pair, (b1,b2), is \\\"in\\\" the\\nnegation relation. \\n-/\\n\\n\\nexample : \\u2200 (b1 b2), negation b1 b2 \\u2194 bnot b1 = b2 :=\\nbegin\\nassume b1 b2,\\nsplit,\\n\\n-- forwards\\nintro h,\\n\\ncases b1,\\ncases b2,\\n\\n-- ff ff\\ncases h,\\n\\n-- tt ff\\nexact rfl,\\n\\ncases b2,\\n\\n-- tt ff\\nexact rfl,\\n\\n-- tt tt\\ncases h,\\n\\n-- backwards\\n\\nassume h,\\n\\n-- again by case analysis on b1 b2\\n\\ncases b1,\\ncases b2,\\n\\ncases h,\\nunfold negation,\\n\\ncases b2,\\nunfold negation,\\n\\ncases h,\\n\\n\\nend\\n\\n\\n\\nexample: \\u2200 (b1 b2), negation b1 b2 \\u2194 bnot b1 = b2 :=\\nbegin\\nassume b1 b2,\\nsplit,\\n-- What should be our proof strategy from here?\\n-- Exercise: complete this proof.\\nend \\n\\n\\n/-\\nNext idea: A binary relation can relate objects of \\ndifferent types types. The last example was of a\\nbinary relation relating bools to bools. Not let's\\nintroduce a new data type, call it bit, with values\\nbit.zero and bit.one, and the consider a relation\\n\\\"between\\\" bools and bits, where a bool is either\\ntt or ff and a bit is either zero or one. \\n-/\\n\\ninductive bit \\n| zero \\n| one \\n\\n/-\\nHere for fun is a function that takes a bit\\nand returns the other bit. It's like bnot but\\nfor bits.\\n-/\\n\\ndef bit_flip : bit \\u2192 bit \\n| bit.zero := bit.one\\n| bit.one := bit.zero\\n\\n/-\\nNow let's define a relation from bool to bit\\nthat associates tt with one and ff with zero.\\n-/\\n\\ndef bool_to_bit_relation : bool \\u2192 bit \\u2192 Prop\\n| tt bit.one := true\\n| ff bit.zero := true\\n| _ _ := false\\n\\n/-\\nExercise: Draw a picture of this relation.\\nExercise: Draw an adjacency matrix for this relation\\n-/\\n\\n/-\\nAs another concrete example, let's define the relation\\nbetween natural numbers and their squares. We'll start\\nby defining the square function. Then we'll define the\\ncorresponding relation. They represent the same set of\\nordered pairs, but the first computes and the second is\\n\\\"declarative\\\" (computational vs. logical).\\n-/\\n\\ndef square (n : \\u2115) := n * n\\n#eval square 25\\n\\n/-\\nNow we specific the relevant set of pairs.\\n-/\\ndef squares (n m : \\u2115) : Prop := square n = m \\n\\n/-\\nWe can prove pairs that bear this relationship and\\nnot ones that don't.\\n-/\\n\\nexample : squares 0 0 := rfl\\nexample : squares 1 1 := rfl\\nexample : squares 2 3 := rfl -- no can, dude\\nexample : squares 2 4 := rfl\\nexample : squares 25 625 := rfl\\n\\n/-\\nExercise: define a predicate, call it \\nstring2len,on strings and nats, such \\nthat (s, n) \\u2208 string2len iff length \\nof s is n.\\n-/\\n\\ndef string2len : string \\u2192 nat \\u2192 Prop := \\n \\u03bb s n, -- arguments\\n s.length = n -- result (here a proposition)\\n\\n/-\\nExercise: prove the proposition that the pair of\\narguments, \\\"Lean!\\\" and 5, taken together, satisfy\\nthe string2len predicate, and are thus considered\\nto be a pair that in (a member of) the string2len\\nrelation. \\n-/\\nexample : string2len \\\"Lean!\\\" 5 := \\nbegin\\nunfold string2len,\\nexact rfl,\\nend\\n/-\\nThese ideas are prominent in database theory and\\npractice. For example, the SELECT statement in a\\nSQL database, e.g., mySQL, MariaDB, or PostgreSQL,\\nselects the subset of records from a database with\\nfield values that satisfy such a selection predicate.\\n-/\\n\"} {\"text\": \"import tactic\\n\\n-- True or false? n = 3 \\u2194 n^2-2n-3=0. If you think it's false\\n-- then you'll have to modify the statement by putting it in brackets\\n-- and adding a \\u00ac in front of it. \\nlemma part_a : \\u2200 n : \\u2124, n = 3 \\u2192 n ^ 2 - 2 * n - 3 = 0 :=\\nbegin\\n norm_num,\\nend\\n\\nlemma part_b : \\u00ac (\\u2200 n : \\u2124, n ^ 2 - 2 * n - 3 = 0 \\u2192 n = 3) := \\nbegin\\n intro h,\\n specialize h(-1),\\n norm_num at h,\\nend\\n\\nlemma part_c : \\u00ac (\\u2200 n : \\u2124, n ^ 2 - 2 * n - 3 = 0 \\u2192 n = 3) :=\\nbegin\\n intro h,\\n specialize h(-1),\\n norm_num at h,\\nend\\n\\n\\nlemma part_d : \\u00ac (\\u2200 a b : \\u2124, is_square (a * b) \\u2192 is_square a \\u2227 is_square b) :=\\nbegin\\n intro h,\\n specialize h (-1) (-1),\\n norm_num at h,\\n unfold is_square at h,\\n cases h with m hm,\\n nlinarith,\\nend\\n\\nlemma part_e : \\u2200 a b : \\u2124, (is_square a \\u2227 is_square b) \\u2192 is_square (a * b) :=\\nbegin\\n intros a b h,\\n unfold is_square at h,\\n rcases h with \\u27e8\\u27e8x, hx\\u27e9,\\u27e8y, hy\\u27e9\\u27e9,\\n unfold is_square,\\n use x*y,\\n rw hx,\\n rw hy,\\n ring,\\nend\\n\\n\\n\"} {\"text\": \"(*\\n\\n Benedikt Ahrens and R\\u00e9gis Spadotti\\n\\n Terminal semantics for codata types in intensional Martin-L\\u00f6f type theory\\n\\n http://arxiv.org/abs/1401.1053\\n\\n*)\\n\\n(*\\n\\n Content of this file:\\n\\n - definition of pushforward of comodules along a comonad morphism\\n - definition of comodule morphism induced by a comonad morphism\\n - commutativity of pushforward with precomposition w. product\\n\\n*)\\n\\nRequire Import Category.RComonad.\\nRequire Import Category.RComod.\\nRequire Import Category.RComonadWithCut.\\nRequire Import Theory.Category.\\nRequire Import Theory.Isomorphism.\\nRequire Import Theory.Functor.\\nRequire Import Theory.RelativeComonad.\\nRequire Import Theory.RelativeComonadWithCut.\\nRequire Import Theory.Comodule.\\nRequire Import Theory.Product.\\nRequire Import Theory.ProductPreservingFunctor.\\nRequire Import Theory.PrecompositionWithProduct.\\n\\nGeneralizable All Variables.\\n\\n(*------------------------------------------------------------------------------\\n -- \\uff30\\uff35\\uff33\\uff28\\uff26\\uff2f\\uff32\\uff37\\uff21\\uff32\\uff24 \\uff23\\uff2f\\uff2d\\uff2f\\uff24\\uff35\\uff2c\\uff25\\n ----------------------------------------------------------------------------*)\\n(** * Pushforward comodule **)\\n\\n(** ** Definition **)\\nSection Pushforward_construction.\\n\\n Context `{F : Functor \\ud835\\udc9e \\ud835\\udc9f} {T S : RelativeComonad F}\\n (\\u03c4 : T \\u21d2 S) `(M : Comodule T \\u2130).\\n\\n Program Definition pushforward : Comodule S \\u2130 :=\\n Comodule.make \\u2983 M \\u2254 M\\n ; mcobind \\u2254 \\u03bb C D \\u2219 \\u03bb f \\u21a6 M\\u22c5mcobind (f \\u2218 \\u03c4(C)) \\u2984.\\n Next Obligation. (* mcobind_cong *)\\n solve_proper.\\n Qed.\\n Next Obligation. (* mcobind_counit *)\\n rewrite <- \\u03c4_counit. now rewrite mcobind_counit.\\n Qed.\\n Next Obligation. (* mcobind_mcobind *)\\n now rewrite compose_assoc,\\n <- \\u03c4_commutes,\\n mcobind_mcobind,\\n <- compose_assoc.\\n Qed.\\n\\nEnd Pushforward_construction.\\n\\n(*------------------------------------------------------------------------------\\n -- \\uff26\\uff35N\\uff23\\uff34\\uff2f\\uff32\\uff29\\uff21\\uff2c\\uff29\\uff34\\uff39\\n ----------------------------------------------------------------------------*)\\n(** ** Functoriality of pushforward **)\\n\\nSection Functoriality.\\n\\n Context `{F : Functor \\ud835\\udc9e \\ud835\\udc9f} {T S : RelativeComonad F} {\\u2130 : Category} {M N : Comodule S \\u2130}\\n (\\u03c4 : S \\u21d2 T) (\\u03b1 : M \\u21d2 N).\\n\\n Infix \\\"\\u204e\\\" := pushforward (at level 0).\\n\\n Program Definition pushforward_mor : \\u2035 \\u03c4\\u204eM \\u21d2 \\u03c4\\u204eN \\u2032 :=\\n Comodule.make \\u2983 \\u03b1 \\u2254 \\u03b1 \\u2984.\\n Next Obligation. (* \\u03b1_commutes *)\\n now rewrite \\u03b1_commutes.\\n Qed.\\n\\nEnd Functoriality.\\n\\nProgram Definition Pushforward\\n `{F : Functor \\ud835\\udc9e \\ud835\\udc9f} {T S : RelativeComonad F} (\\u03c4 : T \\u21d2 S) {\\u2130} : Functor (\\ud835\\udc79\\ud835\\udc6a\\ud835\\udc90\\ud835\\udc8e\\ud835\\udc90\\ud835\\udc85 T \\u2130) (\\ud835\\udc79\\ud835\\udc6a\\ud835\\udc90\\ud835\\udc8e\\ud835\\udc90\\ud835\\udc85 S \\u2130) :=\\n Functor.make \\u2983 F \\u2254 pushforward \\u03c4\\n ; map \\u2254 \\u03bb A B \\u2219 \\u03bb f \\u21a6 pushforward_mor \\u03c4 f \\u2984.\\nNext Obligation.\\n intros f g eq_fg x. simpl. now apply eq_fg.\\nQed.\\nNext Obligation.\\n reflexivity.\\nQed.\\nNext Obligation.\\n reflexivity.\\nQed.\\n\\nNotation \\\"\\u03c4 \\u204e\\\" := (Pushforward \\u03c4) (at level 0).\\n\\n(** ** Tautological comodule **)\\nSection tautological_comodule.\\n\\n Context `{F : Functor \\ud835\\udc9e \\ud835\\udc9f} (T : RelativeComonad F).\\n\\n Program Definition tcomod : Comodule T \\ud835\\udc9f :=\\n Comodule.make \\u2983 M \\u2254 T\\n ; mcobind \\u2254 \\u03bb C D \\u2219 T\\u22c5cobind \\u2984.\\n (** mcobind-counit *)\\n Next Obligation.\\n now rewrite cobind_counit.\\n Qed.\\n (** mcobind-mcobind *)\\n Next Obligation.\\n now rewrite cobind_cobind.\\n Qed.\\n\\nEnd tautological_comodule.\\n\\nLocal Coercion tcomod : RelativeComonad >-> Comodule.\\nNotation \\\"[ T ]\\\" := (tcomod T) (only parsing).\\n\\n(** ** Induced morphism **)\\n\\nSection induced_morphism.\\n\\n Context `{F : Functor \\ud835\\udc9e \\ud835\\udc9f} {T S : RelativeComonad F}\\n (\\u03c4 : T \\u21d2 S).\\n\\n Program Definition induced_morphism : \\u2035 \\u03c4\\u204eT \\u21d2 S \\u2032 :=\\n Comodule.make \\u2983 \\u03b1 \\u2254 \\u03bb C \\u2219 \\u03c4(C) \\u2984.\\n (** \\u03b1-commutes **)\\n Next Obligation.\\n now rewrite \\u03c4_commutes.\\n Qed.\\n\\nEnd induced_morphism.\\n\\nNotation \\\"\\u27e8 \\u03c4 \\u27e9\\\" := (induced_morphism \\u03c4) (at level 0).\\n\\nSection Commutes.\\n\\n Context `{BinaryProduct \\ud835\\udc9e} `{BinaryProduct \\ud835\\udc9f} {F : Functor \\ud835\\udc9e \\ud835\\udc9f}\\n {E : \\ud835\\udc9e} `{!ProductPreservingFunctor F} {T S : RelativeComonadWithCut F E}\\n {\\u03c4 : T \\u21d2 S} `{M : Comodule T \\u2130}.\\n\\n Program Definition \\u03a6 : \\u2035 \\u03c4\\u204e(M[E\\u00d7\\u2500]) \\u21d2 (\\u03c4\\u204eM)[E\\u00d7\\u2500] \\u2032 :=\\n Comodule.make \\u2983 \\u03b1 \\u2254 \\u03bb X \\u2219 id[M (E \\u00d7 X)] \\u2984.\\n Next Obligation.\\n rewrite left_id, right_id.\\n apply \\u03a0.cong.\\n repeat rewrite compose_assoc.\\n apply \\u03a0\\u2082.cong; [ reflexivity |].\\n rewrite \\u2218-\\u00d7; apply \\u03a0\\u2082.cong.\\n rewrite compose_assoc; apply \\u03a0\\u2082.cong; [ reflexivity |].\\n apply \\u03c4_counit.\\n rewrite compose_assoc. apply \\u03a0\\u2082.cong; [ reflexivity |].\\n symmetry. apply \\u03c4_cut.\\n Qed.\\n\\nEnd Commutes.\\n\"} {\"text\": \"State Before: p : \\u2115\\nq : \\u211a\\nhq : q = 0\\n\\u22a2 padicNorm p (-q) = padicNorm p q State After: no goals Tactic: simp [hq] State Before: p : \\u2115\\nq : \\u211a\\nhq : \\u00acq = 0\\n\\u22a2 padicNorm p (-q) = padicNorm p q State After: no goals Tactic: simp [padicNorm, hq]\"} {\"text\": \"/-\\nCopyright (c) 2021 OpenAI. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\\n-/\\nimport mathzoo.imports.miniF2F\\n\\nopen_locale nat rat real big_operators topological_space\\n\\ntheorem mathd_algebra_142\\n (m b : \\u211d)\\n (h\\u2080 : m * 7 + b = -1)\\n (h\\u2081 : m * (-1) + b = 7) :\\n m + b = 5 :=\\nbegin\\n linarith,\\nend\"} {\"text\": \"[STATEMENT]\\nlemma defined_Integer_simps [simp]:\\n \\\"defined (MkI\\\\<cdot>i)\\\"\\n \\\"defined (0::Integer)\\\"\\n \\\"defined (1::Integer)\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. defined (MkI\\\\<cdot>i) &&& defined 0 &&& defined 1\\n[PROOF STEP]\\nby (simp_all add: defined_def)\"} {\"text\": \"lemma is_unit_content_iff [simp]: \\\"is_unit (content p) \\\\<longleftrightarrow> content p = 1\\\"\"} {\"text\": \"/-\\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Jeremy Avigad, Leonardo de Moura\\n\\nDefinitions and properties of gcd, lcm, and coprime.\\n-/\\nimport .div data.nat.gcd\\nopen eq.ops\\n\\nnamespace int\\n\\n/- gcd -/\\n\\ndefinition gcd (a b : \\u2124) : \\u2124 := of_nat (nat.gcd (nat_abs a) (nat_abs b))\\n\\ntheorem gcd_nonneg (a b : \\u2124) : gcd a b \\u2265 0 :=\\nof_nat_nonneg (nat.gcd (nat_abs a) (nat_abs b))\\n\\ntheorem gcd.comm (a b : \\u2124) : gcd a b = gcd b a :=\\nby rewrite [\\u2191gcd, nat.gcd.comm]\\n\\ntheorem gcd_zero_right (a : \\u2124) : gcd a 0 = abs a :=\\nby rewrite [\\u2191gcd, nat_abs_zero, nat.gcd_zero_right, of_nat_nat_abs]\\n\\ntheorem gcd_zero_left (a : \\u2124) : gcd 0 a = abs a :=\\nby rewrite [gcd.comm, gcd_zero_right]\\n\\ntheorem gcd_one_right (a : \\u2124) : gcd a 1 = 1 :=\\nby rewrite [\\u2191gcd, nat_abs_one, nat.gcd_one_right]\\n\\ntheorem gcd_one_left (a : \\u2124) : gcd 1 a = 1 :=\\nby rewrite [gcd.comm, gcd_one_right]\\n\\ntheorem gcd_abs_left (a b : \\u2124) : gcd (abs a) b = gcd a b :=\\nby rewrite [\\u2191gcd, *nat_abs_abs]\\n\\ntheorem gcd_abs_right (a b : \\u2124) : gcd (abs a) b = gcd a b :=\\nby rewrite [\\u2191gcd, *nat_abs_abs]\\n\\ntheorem gcd_abs_abs (a b : \\u2124) : gcd (abs a) (abs b) = gcd a b :=\\nby rewrite [\\u2191gcd, *nat_abs_abs]\\n\\nsection\\nopen nat\\ntheorem gcd_of_ne_zero (a : \\u2124) {b : \\u2124} (H : b \\u2260 0) : gcd a b = gcd b (abs a % abs b) :=\\nhave nat_abs b \\u2260 0, from assume H', H (eq_zero_of_nat_abs_eq_zero H'),\\nhave nat_abs b > 0, from pos_of_ne_zero this,\\nhave nat.gcd (nat_abs a) (nat_abs b) = (nat.gcd (nat_abs b) (nat_abs a % nat_abs b)),\\n from @nat.gcd_of_pos (nat_abs a) (nat_abs b) this,\\ncalc\\n gcd a b = nat.gcd (nat_abs b) (nat_abs a % nat_abs b) : by rewrite [\\u2191gcd, this]\\n ... = gcd (abs b) (abs a % abs b) : by rewrite [\\u2191gcd, -*of_nat_nat_abs, of_nat_mod]\\n ... = gcd b (abs a % abs b) : by rewrite [\\u2191gcd, *nat_abs_abs]\\nend\\n\\ntheorem gcd_of_pos (a : \\u2124) {b : \\u2124} (H : b > 0) : gcd a b = gcd b (abs a % b) :=\\nby rewrite [!gcd_of_ne_zero (ne_of_gt H), abs_of_pos H]\\n\\ntheorem gcd_of_nonneg_of_pos {a b : \\u2124} (H1 : a \\u2265 0) (H2 : b > 0) : gcd a b = gcd b (a % b) :=\\nby rewrite [!gcd_of_pos H2, abs_of_nonneg H1]\\n\\ntheorem gcd_self (a : \\u2124) : gcd a a = abs a :=\\nby rewrite [\\u2191gcd, nat.gcd_self, of_nat_nat_abs]\\n\\ntheorem gcd_dvd_left (a b : \\u2124) : gcd a b \\u2223 a :=\\nhave gcd a b \\u2223 abs a,\\n by rewrite [\\u2191gcd, -of_nat_nat_abs, of_nat_dvd_of_nat_iff]; apply nat.gcd_dvd_left,\\niff.mp !dvd_abs_iff this\\n\\ntheorem gcd_dvd_right (a b : \\u2124) : gcd a b \\u2223 b :=\\nby rewrite gcd.comm; apply gcd_dvd_left\\n\\ntheorem dvd_gcd {a b c : \\u2124} : a \\u2223 b \\u2192 a \\u2223 c \\u2192 a \\u2223 gcd b c :=\\nbegin\\n rewrite [\\u2191gcd, -*(abs_dvd_iff a), -(dvd_abs_iff _ b), -(dvd_abs_iff _ c), -*of_nat_nat_abs],\\n rewrite [*of_nat_dvd_of_nat_iff] ,\\n apply nat.dvd_gcd\\nend\\n\\ntheorem gcd.assoc (a b c : \\u2124) : gcd (gcd a b) c = gcd a (gcd b c) :=\\ndvd.antisymm !gcd_nonneg !gcd_nonneg\\n (dvd_gcd\\n (dvd.trans !gcd_dvd_left !gcd_dvd_left)\\n (dvd_gcd (dvd.trans !gcd_dvd_left !gcd_dvd_right) !gcd_dvd_right))\\n (dvd_gcd\\n (dvd_gcd !gcd_dvd_left (dvd.trans !gcd_dvd_right !gcd_dvd_left))\\n (dvd.trans !gcd_dvd_right !gcd_dvd_right))\\n\\ntheorem gcd_mul_left (a b c : \\u2124) : gcd (a * b) (a * c) = abs a * gcd b c :=\\nby rewrite [\\u2191gcd, *nat_abs_mul, nat.gcd_mul_left, of_nat_mul, of_nat_nat_abs]\\n\\ntheorem gcd_mul_right (a b c : \\u2124) : gcd (a * b) (c * b) = gcd a c * abs b :=\\nby rewrite [mul.comm a, mul.comm c, mul.comm (gcd a c), gcd_mul_left]\\n\\ntheorem gcd_pos_of_ne_zero_left {a : \\u2124} (b : \\u2124) (H : a \\u2260 0) : gcd a b > 0 :=\\nhave gcd a b \\u2260 0, from\\n suppose gcd a b = 0,\\n have 0 \\u2223 a, from this \\u25b8 gcd_dvd_left a b,\\n show false, from H (eq_zero_of_zero_dvd this),\\nlt_of_le_of_ne (gcd_nonneg a b) (ne.symm this)\\n\\ntheorem gcd_pos_of_ne_zero_right (a : \\u2124) {b : \\u2124} (H : b \\u2260 0) : gcd a b > 0 :=\\nby rewrite gcd.comm; apply !gcd_pos_of_ne_zero_left H\\n\\ntheorem eq_zero_of_gcd_eq_zero_left {a b : \\u2124} (H : gcd a b = 0) : a = 0 :=\\ndecidable.by_contradiction\\n (suppose a \\u2260 0,\\n have gcd a b > 0, from !gcd_pos_of_ne_zero_left this,\\n ne_of_lt this H\\u207b\\u00b9)\\n\\ntheorem eq_zero_of_gcd_eq_zero_right {a b : \\u2124} (H : gcd a b = 0) : b = 0 :=\\nby rewrite gcd.comm at H; apply !eq_zero_of_gcd_eq_zero_left H\\n\\ntheorem gcd_div {a b c : \\u2124} (H1 : c \\u2223 a) (H2 : c \\u2223 b) :\\n gcd (a / c) (b / c) = gcd a b / (abs c) :=\\ndecidable.by_cases\\n (suppose c = 0,\\n calc\\n gcd (a / c) (b / c) = gcd 0 0 : by subst c; rewrite *int.div_zero\\n ... = 0 : gcd_zero_left\\n ... = gcd a b / 0 : int.div_zero\\n ... = gcd a b / (abs c) : by subst c)\\n (suppose c \\u2260 0,\\n have abs c \\u2260 0, from assume H', this (eq_zero_of_abs_eq_zero H'),\\n eq.symm (int.div_eq_of_eq_mul_left this\\n (eq.symm (calc\\n gcd (a / c) (b / c) * abs c = gcd (a / c * c) (b / c * c) : gcd_mul_right\\n ... = gcd a (b / c * c) : int.div_mul_cancel H1\\n ... = gcd a b : int.div_mul_cancel H2))))\\n\\ntheorem gcd_dvd_gcd_mul_left (a b c : \\u2124) : gcd a b \\u2223 gcd (c * a) b :=\\ndvd_gcd (dvd.trans !gcd_dvd_left !dvd_mul_left) !gcd_dvd_right\\n\\ntheorem gcd_dvd_gcd_mul_right (a b c : \\u2124) : gcd a b \\u2223 gcd (a * c) b :=\\n!mul.comm \\u25b8 !gcd_dvd_gcd_mul_left\\n\\ntheorem div_gcd_eq_div_gcd_of_nonneg {a\\u2081 b\\u2081 a\\u2082 b\\u2082 : \\u2124} (H : a\\u2081 * b\\u2082 = a\\u2082 * b\\u2081)\\n (H1 : b\\u2081 \\u2260 0) (H2 : b\\u2082 \\u2260 0) (H3 : a\\u2081 \\u2265 0) (H4 : a\\u2082 \\u2265 0) :\\n a\\u2081 / (gcd a\\u2081 b\\u2081) = a\\u2082 / (gcd a\\u2082 b\\u2082) :=\\nbegin\\n apply div_eq_div_of_dvd_of_dvd,\\n repeat (apply gcd_dvd_left),\\n intro H', apply H1, apply eq_zero_of_gcd_eq_zero_right H',\\n intro H', apply H2, apply eq_zero_of_gcd_eq_zero_right H',\\n rewrite [-abs_of_nonneg H3 at {1}, -abs_of_nonneg H4 at {2}],\\n rewrite [-gcd_mul_left, -gcd_mul_right, H, mul.comm b\\u2081]\\nend\\n\\ntheorem div_gcd_eq_div_gcd {a\\u2081 b\\u2081 a\\u2082 b\\u2082 : \\u2124} (H : a\\u2081 * b\\u2082 = a\\u2082 * b\\u2081) (H1 : b\\u2081 > 0) (H2 : b\\u2082 > 0) :\\n a\\u2081 / (gcd a\\u2081 b\\u2081) = a\\u2082 / (gcd a\\u2082 b\\u2082) :=\\nor.elim (le_or_gt 0 a\\u2081)\\n (assume H3 : a\\u2081 \\u2265 0,\\n have H4 : a\\u2082 * b\\u2081 \\u2265 0, by rewrite -H; apply mul_nonneg H3 (le_of_lt H2),\\n have H5 : a\\u2082 \\u2265 0, from nonneg_of_mul_nonneg_right H4 H1,\\n div_gcd_eq_div_gcd_of_nonneg H (ne_of_gt H1) (ne_of_gt H2) H3 H5)\\n (assume H3 : a\\u2081 < 0,\\n have H4 : a\\u2082 * b\\u2081 < 0, by rewrite -H; apply mul_neg_of_neg_of_pos H3 H2,\\n have H5 : a\\u2082 < 0, from neg_of_mul_neg_right H4 (le_of_lt H1),\\n have H6 : abs a\\u2081 / (gcd (abs a\\u2081) (abs b\\u2081)) = abs a\\u2082 / (gcd (abs a\\u2082) (abs b\\u2082)),\\n begin\\n apply div_gcd_eq_div_gcd_of_nonneg,\\n rewrite [abs_of_pos H1, abs_of_pos H2, abs_of_neg H3, abs_of_neg H5],\\n rewrite [-*neg_mul_eq_neg_mul, H],\\n apply ne_of_gt (abs_pos_of_pos H1),\\n apply ne_of_gt (abs_pos_of_pos H2),\\n repeat (apply abs_nonneg)\\n end,\\n have H7 : -a\\u2081 / (gcd a\\u2081 b\\u2081) = -a\\u2082 / (gcd a\\u2082 b\\u2082),\\n begin\\n rewrite [-abs_of_neg H3, -abs_of_neg H5, -gcd_abs_abs a\\u2081],\\n rewrite [-gcd_abs_abs a\\u2082 b\\u2082],\\n exact H6\\n end,\\n calc\\n a\\u2081 / (gcd a\\u2081 b\\u2081) = -(-a\\u2081 / (gcd a\\u2081 b\\u2081)) :\\n by rewrite [neg_div_of_dvd !gcd_dvd_left, neg_neg]\\n ... = -(-a\\u2082 / (gcd a\\u2082 b\\u2082)) : H7\\n ... = a\\u2082 / (gcd a\\u2082 b\\u2082) :\\n by rewrite [neg_div_of_dvd !gcd_dvd_left, neg_neg])\\n\\n/- lcm -/\\n\\ndefinition lcm (a b : \\u2124) : \\u2124 := of_nat (nat.lcm (nat_abs a) (nat_abs b))\\n\\ntheorem lcm_nonneg (a b : \\u2124) : lcm a b \\u2265 0 :=\\nof_nat_nonneg (nat.lcm (nat_abs a) (nat_abs b))\\n\\ntheorem lcm.comm (a b : \\u2124) : lcm a b = lcm b a :=\\nby rewrite [\\u2191lcm, nat.lcm.comm]\\n\\ntheorem lcm_zero_left (a : \\u2124) : lcm 0 a = 0 :=\\nby rewrite [\\u2191lcm, nat_abs_zero, nat.lcm_zero_left]\\n\\ntheorem lcm_zero_right (a : \\u2124) : lcm a 0 = 0 :=\\n!lcm.comm \\u25b8 !lcm_zero_left\\n\\ntheorem lcm_one_left (a : \\u2124) : lcm 1 a = abs a :=\\nby rewrite [\\u2191lcm, nat_abs_one, nat.lcm_one_left, of_nat_nat_abs]\\n\\ntheorem lcm_one_right (a : \\u2124) : lcm a 1 = abs a :=\\n!lcm.comm \\u25b8 !lcm_one_left\\n\\ntheorem lcm_abs_left (a b : \\u2124) : lcm (abs a) b = lcm a b :=\\nby rewrite [\\u2191lcm, *nat_abs_abs]\\n\\ntheorem lcm_abs_right (a b : \\u2124) : lcm (abs a) b = lcm a b :=\\nby rewrite [\\u2191lcm, *nat_abs_abs]\\n\\ntheorem lcm_abs_abs (a b : \\u2124) : lcm (abs a) (abs b) = lcm a b :=\\nby rewrite [\\u2191lcm, *nat_abs_abs]\\n\\ntheorem lcm_self (a : \\u2124) : lcm a a = abs a :=\\nby rewrite [\\u2191lcm, nat.lcm_self, of_nat_nat_abs]\\n\\ntheorem dvd_lcm_left (a b : \\u2124) : a \\u2223 lcm a b :=\\nby rewrite [\\u2191lcm, -abs_dvd_iff, -of_nat_nat_abs, of_nat_dvd_of_nat_iff]; apply nat.dvd_lcm_left\\n\\ntheorem dvd_lcm_right (a b : \\u2124) : b \\u2223 lcm a b :=\\n!lcm.comm \\u25b8 !dvd_lcm_left\\n\\ntheorem gcd_mul_lcm (a b : \\u2124) : gcd a b * lcm a b = abs (a * b) :=\\nbegin\\n rewrite [\\u2191gcd, \\u2191lcm, -of_nat_nat_abs, -of_nat_mul, of_nat_eq_of_nat_iff, nat_abs_mul],\\n apply nat.gcd_mul_lcm\\nend\\n\\ntheorem lcm_dvd {a b c : \\u2124} : a \\u2223 c \\u2192 b \\u2223 c \\u2192 lcm a b \\u2223 c :=\\nbegin\\n rewrite [\\u2191lcm, -(abs_dvd_iff a), -(abs_dvd_iff b), -*(dvd_abs_iff _ c), -*of_nat_nat_abs],\\n rewrite [*of_nat_dvd_of_nat_iff] ,\\n apply nat.lcm_dvd\\nend\\n\\ntheorem lcm_assoc (a b c : \\u2124) : lcm (lcm a b) c = lcm a (lcm b c) :=\\ndvd.antisymm !lcm_nonneg !lcm_nonneg\\n (lcm_dvd\\n (lcm_dvd !dvd_lcm_left (dvd.trans !dvd_lcm_left !dvd_lcm_right))\\n (dvd.trans !dvd_lcm_right !dvd_lcm_right))\\n (lcm_dvd\\n (dvd.trans !dvd_lcm_left !dvd_lcm_left)\\n (lcm_dvd (dvd.trans !dvd_lcm_right !dvd_lcm_left) !dvd_lcm_right))\\n\\n/- coprime -/\\n\\nabbreviation coprime (a b : \\u2124) : Prop := gcd a b = 1\\n\\ntheorem coprime_swap {a b : \\u2124} (H : coprime b a) : coprime a b :=\\n!gcd.comm \\u25b8 H\\n\\ntheorem dvd_of_coprime_of_dvd_mul_right {a b c : \\u2124} (H1 : coprime c b) (H2 : c \\u2223 a * b) : c \\u2223 a :=\\nhave H3 : gcd (a * c) (a * b) = abs a, from\\n calc\\n gcd (a * c) (a * b) = abs a * gcd c b : gcd_mul_left\\n ... = abs a * 1 : H1\\n ... = abs a : mul_one,\\nhave H4 : (c \\u2223 gcd (a * c) (a * b)), from dvd_gcd !dvd_mul_left H2,\\nby rewrite [-dvd_abs_iff, -H3]; apply H4\\n\\ntheorem dvd_of_coprime_of_dvd_mul_left {a b c : \\u2124} (H1 : coprime c a) (H2 : c \\u2223 a * b) : c \\u2223 b :=\\ndvd_of_coprime_of_dvd_mul_right H1 (!mul.comm \\u25b8 H2)\\n\\ntheorem gcd_mul_left_cancel_of_coprime {c : \\u2124} (a : \\u2124) {b : \\u2124} (H : coprime c b) :\\n gcd (c * a) b = gcd a b :=\\nbegin\\n revert H, unfold [coprime, gcd],\\n rewrite [-of_nat_one],\\n rewrite [+of_nat_eq_of_nat_iff, nat_abs_mul],\\n apply nat.gcd_mul_left_cancel_of_coprime,\\nend\\n\\ntheorem gcd_mul_right_cancel_of_coprime (a : \\u2124) {c b : \\u2124} (H : coprime c b) :\\n gcd (a * c) b = gcd a b :=\\n!mul.comm \\u25b8 !gcd_mul_left_cancel_of_coprime H\\n\\ntheorem gcd_mul_left_cancel_of_coprime_right {c a : \\u2124} (b : \\u2124) (H : coprime c a) :\\n gcd a (c * b) = gcd a b :=\\n!gcd.comm \\u25b8 !gcd.comm \\u25b8 !gcd_mul_left_cancel_of_coprime H\\n\\ntheorem gcd_mul_right_cancel_of_coprime_right {c a : \\u2124} (b : \\u2124) (H : coprime c a) :\\n gcd a (b * c) = gcd a b :=\\n!gcd.comm \\u25b8 !gcd.comm \\u25b8 !gcd_mul_right_cancel_of_coprime H\\n\\ntheorem coprime_div_gcd_div_gcd {a b : \\u2124} (H : gcd a b \\u2260 0) :\\n coprime (a / gcd a b) (b / gcd a b) :=\\ncalc\\n gcd (a / gcd a b) (b / gcd a b)\\n = gcd a b / abs (gcd a b) : gcd_div !gcd_dvd_left !gcd_dvd_right\\n ... = 1 : by rewrite [abs_of_nonneg !gcd_nonneg, int.div_self H]\\n\\ntheorem not_coprime_of_dvd_of_dvd {m n d : \\u2124} (dgt1 : d > 1) (Hm : d \\u2223 m) (Hn : d \\u2223 n) :\\n \\u00ac coprime m n :=\\nassume co : coprime m n,\\nhave d \\u2223 gcd m n, from dvd_gcd Hm Hn,\\nhave d \\u2223 1, by rewrite [\\u2191coprime at co, co at this]; apply this,\\nhave d \\u2264 1, from le_of_dvd dec_trivial this,\\nshow false, from not_lt_of_ge `d \\u2264 1` `d > 1`\\n\\ntheorem exists_coprime {a b : \\u2124} (H : gcd a b \\u2260 0) :\\n exists a' b', coprime a' b' \\u2227 a = a' * gcd a b \\u2227 b = b' * gcd a b :=\\nhave H1 : a = (a / gcd a b) * gcd a b, from (int.div_mul_cancel !gcd_dvd_left)\\u207b\\u00b9,\\nhave H2 : b = (b / gcd a b) * gcd a b, from (int.div_mul_cancel !gcd_dvd_right)\\u207b\\u00b9,\\nexists.intro _ (exists.intro _ (and.intro (coprime_div_gcd_div_gcd H) (and.intro H1 H2)))\\n\\ntheorem coprime_mul {a b c : \\u2124} (H1 : coprime a c) (H2 : coprime b c) : coprime (a * b) c :=\\ncalc\\n gcd (a * b) c = gcd b c : !gcd_mul_left_cancel_of_coprime H1\\n ... = 1 : H2\\n\\ntheorem coprime_mul_right {c a b : \\u2124} (H1 : coprime c a) (H2 : coprime c b) : coprime c (a * b) :=\\ncoprime_swap (coprime_mul (coprime_swap H1) (coprime_swap H2))\\n\\ntheorem coprime_of_coprime_mul_left {c a b : \\u2124} (H : coprime (c * a) b) : coprime a b :=\\nhave H1 : (gcd a b \\u2223 gcd (c * a) b), from !gcd_dvd_gcd_mul_left,\\neq_one_of_dvd_one !gcd_nonneg (H \\u25b8 H1)\\n\\ntheorem coprime_of_coprime_mul_right {c a b : \\u2124} (H : coprime (a * c) b) : coprime a b :=\\ncoprime_of_coprime_mul_left (!mul.comm \\u25b8 H)\\n\\ntheorem coprime_of_coprime_mul_left_right {c a b : \\u2124} (H : coprime a (c * b)) : coprime a b :=\\ncoprime_swap (coprime_of_coprime_mul_left (coprime_swap H))\\n\\ntheorem coprime_of_coprime_mul_right_right {c a b : \\u2124} (H : coprime a (b * c)) : coprime a b :=\\ncoprime_of_coprime_mul_left_right (!mul.comm \\u25b8 H)\\n\\ntheorem exists_eq_prod_and_dvd_and_dvd {a b c : \\u2124} (H : c \\u2223 a * b) :\\n \\u2203 a' b', c = a' * b' \\u2227 a' \\u2223 a \\u2227 b' \\u2223 b :=\\ndecidable.by_cases\\n (suppose gcd c a = 0,\\n have c = 0, from eq_zero_of_gcd_eq_zero_left `gcd c a = 0`,\\n have a = 0, from eq_zero_of_gcd_eq_zero_right `gcd c a = 0`,\\n have c = 0 * b, from `c = 0` \\u2b1d !zero_mul\\u207b\\u00b9,\\n have 0 \\u2223 a, from `a = 0`\\u207b\\u00b9 \\u25b8 !dvd.refl,\\n have b \\u2223 b, from !dvd.refl,\\n exists.intro _ (exists.intro _ (and.intro `c = 0 * b` (and.intro `0 \\u2223 a` `b \\u2223 b`))))\\n (suppose gcd c a \\u2260 0,\\n have gcd c a \\u2223 c, from !gcd_dvd_left,\\n have H3 : c / gcd c a \\u2223 (a * b) / gcd c a, from div_dvd_div this H,\\n have H4 : (a * b) / gcd c a = (a / gcd c a) * b, from\\n calc\\n a * b / gcd c a = b * a / gcd c a : mul.comm\\n ... = b * (a / gcd c a) : !int.mul_div_assoc !gcd_dvd_right\\n ... = a / gcd c a * b : mul.comm,\\n have H5 : c / gcd c a \\u2223 (a / gcd c a) * b, from H4 \\u25b8 H3,\\n have H6 : coprime (c / gcd c a) (a / gcd c a), from coprime_div_gcd_div_gcd `gcd c a \\u2260 0`,\\n have H7 : c / gcd c a \\u2223 b, from dvd_of_coprime_of_dvd_mul_left H6 H5,\\n have H8 : c = gcd c a * (c / gcd c a), from (int.mul_div_cancel' `gcd c a \\u2223 c`)\\u207b\\u00b9,\\n exists.intro _ (exists.intro _ (and.intro H8 (and.intro !gcd_dvd_right H7))))\\n\\nend int\\n\"} {\"text\": \"import algebra.big_operators.basic\\nimport data.int.gcd\\nimport data.real.basic\\nimport data.finset.basic\\nimport number_theory.divisors\\n\\n#check int.lcm 42 47\\nopen_locale big_operators\\n\\ntheorem AIME_2021_I_14 (n1:\\u2115)(sigma:\\u2115 \\u2192 \\u2115 )(hs:\\u2200(n:pnat), sigma n = \\u2211 i in nat.divisors n, i)\\n(h:\\u2200 (a:pnat),2021\\u2208 nat.divisors (sigma (a^n1) -1) ):\\nn1\\u2265 2*3*7*23*43*47:=\\nbegin\\n sorry\\nend\"} {\"text\": \"(** * Facts about Static Expressions *)\\n\\nRequire Import hvhdl.Environment.\\nRequire Import hvhdl.StaticExpressions.\\nRequire Import hvhdl.AbstractSyntax.\\nRequire Import hvhdl.SemanticalDomains.\\n\\nRequire Import hvhdl.proofs.EnvironmentFacts.\\n\\n(** ** Facts about Locally Static Expressions *)\\n\\nSection LStatic.\\n\\nEnd LStatic.\\n\\n(** ** Facts about Globally Static Expressions *)\\n\\nSection GStatic.\\n\\n Lemma IGStaticExpr_eq_iff_eq_gens :\\n forall {\\u03941 \\u03942 e},\\n EqGens \\u03941 \\u03942 ->\\n IGStaticExpr \\u03941 e <->\\n IGStaticExpr \\u03942 e.\\n Proof.\\n split.\\n (* CASE A -> B *)\\n - induction 1; eauto with hvhdl.\\n eapply IsGStaticGeneric with (t := t) (v := v);\\n rewrite <- H; assumption.\\n (* CASE B -> A *)\\n - induction 1; eauto with hvhdl.\\n eapply IsGStaticGeneric with (t := t) (v := v);\\n rewrite H; assumption.\\n Qed.\\n \\nEnd GStatic.\\n\"} {\"text\": \"function [fit] = compare_new(varargin)\\n\\n% Determine list of inputs.\\ninpn = cell(1, length(varargin));\\nfor kn = 1:length(varargin);\\n inpn{kn} = inputname(kn);\\nend\\n\\nv = {varargin{:} inpn};\\nth = idss(v{2});\\nth = th('y1', cell(0));\\n\\nz = v{1};\\nz = iddata(z(:, 1), z(:, 2:end), 1);\\ny = pvget(z, 'OutputData');\\nz1 = z(:, 'y1', cell(0));\\n\\n[yh, x01] = predict(th, z1, 1, 'e');\\nyhh = pvget(yh, 'OutputData');\\n\\n%Compute fit.\\nerr = norm(yhh{1} - y{1});\\nmeanerr = norm(y{1} - mean(y{1}));\\nfit = 100*(1-err/meanerr);\\n\"} {\"text\": \"import data.list.basic\\n\\nopen list\\n\\nvariables {\\u03b1 : Type*} (x y z : \\u03b1) (xs ys zs : list \\u03b1)\\n\\ndef mk_symm (xs : list \\u03b1) := xs ++ reverse xs\\n\\ntheorem reverse_mk_symm (xs : list \\u03b1) :\\n reverse (mk_symm xs) = mk_symm xs :=\\nby simp [mk_symm]\\n\\nsection\\nlocal attribute [simp] reverse_mk_symm\\n\\nexample (xs ys : list \\u2115) :\\n reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\\nby simp\\n\\nexample (xs ys : list \\u2115) (p : list \\u2115 \\u2192 Prop)\\n (h : p (reverse (xs ++ (mk_symm ys)))) :\\n p (mk_symm ys ++ reverse xs) :=\\nby simp at h; assumption\\n\\nend\\n\\nrun_cmd mk_simp_attr `my_simps\\n\\nattribute [my_simps] reverse_mk_symm\\n\\nexample (xs ys : list \\u2115) :\\n reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\\nby {simp with my_simps}\\n\\nexample (xs ys : list \\u2115) (p : list \\u2115 \\u2192 Prop)\\n (h : p (reverse (xs ++ (mk_symm ys)))) :\\n p (mk_symm ys ++ reverse xs) :=\\nby simp with my_simps at h; assumption\\n\"} {\"text\": \"import data.real.basic\\nimport game.functions.bothInjective game.functions.bothSurjective\\nopen function\\n\\n/-\\n# Chapter 6 : Functions\\n\\n## Level 3\\n\\nBe sure to make use of the results in the previous two levels.\\n-/\\n\\n/- Lemma\\nIf $f : X \\\\to Y$ and $g : Y \\\\to Z$ are both bijective functions, then\\nthe function resulting from their composition is also bijective.\\n-/\\ntheorem both_bijective\\n (X Y Z : set \\u211d) (f : X \\u2192 Y) (g : Y \\u2192 Z) : \\n bijective f \\u2227 bijective g \\u2192 bijective (g \\u2218 f) :=\\nbegin\\n -- Since $f$ and $g$ are bijective, they are also both injective and surjective.\\n rintro \\u27e8\\u27e8hfi, hfs\\u27e9, hgi, hgs\\u27e9,\\n split,\\n -- Since $f$ and $g$ are injective, $g \\u2218 f$ is injective by a previous result.\\n apply both_injective,\\n split,\\n repeat {assumption},\\n -- Similarly, since $f$ and $g$ are surjective, $g \\u2218 f$ is surjective.\\n apply both_surjective,\\n split,\\n -- Hence, since $g \\u2218 f$ is injective and surjective, $g \\u2218 f$ is bijective.\\n repeat {assumption}, done\\nend\\n\\n\"} {\"text\": \"theory Exercise2\\n imports Main\\nbegin\\n\\ninductive palindrome :: \\\"'a list \\\\<Rightarrow> bool\\\" where\\npdrmNil: \\\"palindrome []\\\" |\\npdrmSing: \\\"palindrome [x]\\\" |\\npdrmRec: \\\"palindrome xs \\\\<Longrightarrow> palindrome (x # xs @ [x])\\\"\\n\\ntheorem \\\"(palindrome xs) \\\\<Longrightarrow> (rev xs = xs)\\\"\\n apply (induction rule: palindrome.induct)\\n by simp_all\\n\\nend\"} {\"text\": \"[STATEMENT]\\nlemma list_of_lazy_sequence_append [simp]:\\n \\\"list_of_lazy_sequence (append xq yq) = list_of_lazy_sequence xq @ list_of_lazy_sequence yq\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. list_of_lazy_sequence (Lazy_Sequence.append xq yq) = list_of_lazy_sequence xq @ list_of_lazy_sequence yq\\n[PROOF STEP]\\nby (simp add: append_def)\"} {\"text\": \"[STATEMENT]\\nlemma assert_gpv_simps [simp]:\\n \\\"assert_gpv True = Done ()\\\"\\n \\\"assert_gpv False = Fail\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. assert_gpv True = Generative_Probabilistic_Value.Done () &&& assert_gpv False = Fail\\n[PROOF STEP]\\nby(simp_all add: assert_gpv_def)\"} {\"text\": \"From Coq Require Import\\n List\\n ssreflect\\n.\\n\\nFrom ExtensibleCompiler.Theory Require Import\\n Algebra\\n Environment\\n Eval\\n Functor\\n ProgramAlgebra\\n SubFunctor\\n Sum1\\n Types\\n UniversalProperty\\n.\\n\\nLocal Open Scope SubFunctor.\\n\\nInductive Closure\\n L\\n `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n E\\n : Set :=\\n| MkClosure (closure : WellFormedValue (L nat)) (environment : Environment E)\\n.\\nArguments MkClosure {L F FL E}.\\n\\nGlobal Instance Functor__Closure\\n {L} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n : Functor (Closure L).\\nProof.\\n refine {| fmap := fun A B f '(MkClosure c e) => MkClosure c (map f e) |}.\\n - move => ? [] c e.\\n rewrite map_id //.\\n - move => ????? [] c e.\\n rewrite map_map //.\\nDefined.\\n\\nDefinition closure\\n {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n `{(L V) supports (Closure L)}\\n c e\\n : WellFormedValue (L V)\\n := injectUP' (MkClosure c e).\\n\\nDefinition closureF\\n {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n `{(L V) supports (Closure L)}\\n c e\\n : Fix (L V)\\n := proj1_sig (closure c e).\\n\\nGlobal Instance FoldUP'__closure\\n {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n `{(L V) supports (Closure L)}\\n c e\\n : FoldUP' (closureF c e)\\n := proj2_sig (closure c e).\\n\\nDefinition isClosure\\n {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\\n `{(L V) supports (Closure L)}\\n : Fix (L V) -> option _\\n := fun v =>\\n match projectUP' (F := Closure L) v with\\n | Some (MkClosure f e) => Some (f, e)\\n | None => None\\n end.\\n\"} {\"text\": \"subsection \\\\<open>Implementation of Division on Multivariate Polynomials\\\\<close>\\n\\ntheory MPoly_Divide_Code\\n imports \\n MPoly_Divide \\n Polynomials.MPoly_Type_Class_FMap\\n Polynomials.MPoly_Type_Univariate\\nbegin\\n\\ntext \\\\<open>\\n We now set up code equations for some of the operations that we will need, such as division,\\n \\\\<^const>\\\\<open>mpoly_to_poly\\\\<close>, and \\\\<^const>\\\\<open>mpoly_to_mpoly_poly\\\\<close>.\\n\\\\<close>\\n\\nlemma mapping_of_MPoly[code]: \\\"mapping_of (MPoly p) = p\\\"\\n by (simp add: MPoly_inverse)\\n\\nlift_definition filter_pm :: \\\"('a \\\\<Rightarrow> bool) \\\\<Rightarrow> ('a \\\\<Rightarrow>\\\\<^sub>0 'b :: zero) \\\\<Rightarrow> ('a \\\\<Rightarrow>\\\\<^sub>0 'b)\\\" is\\n \\\"\\\\<lambda>P f x. if P x then f x else 0\\\"\\n by (erule finite_subset[rotated]) auto\\n\\nlemma lookup_filter_pm: \\\"lookup (filter_pm P f) x = (if P x then lookup f x else 0)\\\"\\n by transfer auto\\n\\n\\nlemma filter_pm_code [code]: \\\"filter_pm P (Pm_fmap m) = Pm_fmap (fmfilter P m)\\\"\\n by (auto intro!: poly_mapping_eqI simp: fmlookup_default_def lookup_filter_pm)\\n\\nlemma remove_key_conv_filter_pm [code]: \\\"remove_key x m = filter_pm (\\\\<lambda>y. y \\\\<noteq> x) m\\\"\\n by transfer auto\\n\\nlemma finite_poly_coeff_nonzero: \\\"finite {n. poly.coeff p n \\\\<noteq> 0}\\\"\\n by (metis MOST_coeff_eq_0 eventually_cofinite)\\n\\nlemma poly_degree_conv_Max:\\n assumes \\\"p \\\\<noteq> 0\\\"\\n shows \\\"Polynomial.degree p = Max {n. poly.coeff p n \\\\<noteq> 0}\\\"\\n using assms\\nproof (intro antisym degree_le Max.boundedI)\\n fix n assume \\\"n \\\\<in> {n. poly.coeff p n \\\\<noteq> 0}\\\"\\n thus \\\"n \\\\<le> Polynomial.degree p\\\"\\n by (simp add: le_degree)\\nqed (auto simp: poly_eq_iff finite_poly_coeff_nonzero)\\n\\nlemma mpoly_to_poly_code_aux:\\n fixes p :: \\\"'a :: comm_monoid_add mpoly\\\" and x :: nat\\n defines \\\"I \\\\<equiv> (\\\\<lambda>m. lookup m x) ` Set.filter (\\\\<lambda>m. \\\\<forall>y\\\\<in>keys m. y = x) (keys (mapping_of p))\\\"\\n shows \\\"I = {n. poly.coeff (mpoly_to_poly x p) n \\\\<noteq> 0}\\\"\\n and \\\"mpoly_to_poly x p = 0 \\\\<longleftrightarrow> I = {}\\\"\\n and \\\"I \\\\<noteq> {} \\\\<Longrightarrow> Polynomial.degree (mpoly_to_poly x p) = Max I\\\"\\nproof -\\n have \\\"n \\\\<in> I \\\\<longleftrightarrow> poly.coeff (mpoly_to_poly x p) n \\\\<noteq> 0\\\" for n\\n proof -\\n have \\\"I = (\\\\<lambda>m. lookup m x) ` (keys (mapping_of p) \\\\<inter> {m. \\\\<forall>y\\\\<in>keys m. y = x})\\\"\\n by (auto simp: I_def Set.filter_def)\\n also have \\\"{m. \\\\<forall>y\\\\<in>keys m. y = x} = range (\\\\<lambda>n. monomial n x)\\\" (is \\\"?lhs = ?rhs\\\")\\n proof (intro equalityI subsetI)\\n fix m assume \\\"m \\\\<in> ?lhs\\\"\\n hence \\\"m = monomial (lookup m x) x\\\"\\n by transfer (auto simp: fun_eq_iff when_def)\\n thus \\\"m \\\\<in> ?rhs\\\" by auto\\n qed (auto split: if_splits)\\n also have \\\"n \\\\<in> (\\\\<lambda>m. lookup m x) ` (keys (mapping_of p) \\\\<inter> \\\\<dots>) \\\\<longleftrightarrow>\\n monomial n x \\\\<in> keys (mapping_of p)\\\" by force\\n also have \\\"\\\\<dots> \\\\<longleftrightarrow> poly.coeff (mpoly_to_poly x p) n \\\\<noteq> 0\\\"\\n by (simp add: coeff_def in_keys_iff)\\n finally show ?thesis .\\n qed\\n thus I: \\\"I = {n. poly.coeff (mpoly_to_poly x p) n \\\\<noteq> 0}\\\"\\n by blast\\n show eq_0_iff: \\\"mpoly_to_poly x p = 0 \\\\<longleftrightarrow> I = {}\\\"\\n unfolding I by (auto simp: poly_eq_iff)\\n show \\\"I \\\\<noteq> {} \\\\<Longrightarrow> Polynomial.degree (mpoly_to_poly x p) = Max I\\\"\\n by (subst poly_degree_conv_Max) (use eq_0_iff I in auto)\\nqed\\n\\n\\nlemma mpoly_to_poly_code [code]:\\n \\\"Polynomial.coeffs (mpoly_to_poly x p) =\\n (let I = (\\\\<lambda>m. lookup m x) ` Set.filter (\\\\<lambda>m. \\\\<forall>y\\\\<in>keys m. y = x) (keys (mapping_of p))\\n in if I = {} then [] else map (\\\\<lambda>n. MPoly_Type.coeff p (Poly_Mapping.single x n)) [0..<Max I + 1])\\\"\\n (is \\\"?lhs = ?rhs\\\")\\nproof -\\n define I where \\\"I = (\\\\<lambda>m. lookup m x) ` Set.filter (\\\\<lambda>m. \\\\<forall>y\\\\<in>keys m. y = x) (keys (mapping_of p))\\\"\\n show ?thesis\\n proof (cases \\\"I = {}\\\")\\n case True\\n thus ?thesis using mpoly_to_poly_code_aux(2)[of x p]\\n by (simp add: I_def)\\n next\\n case False\\n have [simp]: \\\"mpoly_to_poly x p \\\\<noteq> 0\\\"\\n using mpoly_to_poly_code_aux(2)[of x p] False by (simp add: I_def)\\n from False have \\\"?rhs = map (\\\\<lambda>n. MPoly_Type.coeff p (Poly_Mapping.single x n)) [0..<Max I + 1]\\\"\\n (is \\\"_ = ?rhs'\\\")\\n by (simp add: I_def Let_def)\\n also have \\\"\\\\<dots> = ?lhs\\\"\\n proof (rule nth_equalityI)\\n show \\\"length ?rhs' = length ?lhs\\\"\\n using mpoly_to_poly_code_aux(3)[of x p] False\\n by (simp add: I_def length_coeffs_degree)\\n thus \\\"?rhs' ! n = ?lhs ! n\\\" if \\\"n < length ?rhs'\\\" for n using that\\n by (auto simp del: upt_Suc simp: nth_coeffs_coeff)\\n qed\\n finally show ?thesis ..\\n qed\\nqed\\n\\n\\nfun mpoly_to_mpoly_poly_impl_aux1 :: \\\"nat \\\\<Rightarrow> ((nat \\\\<Rightarrow>\\\\<^sub>0 nat) \\\\<times> 'a) list \\\\<Rightarrow> nat \\\\<Rightarrow> ((nat \\\\<Rightarrow>\\\\<^sub>0 nat) \\\\<times> 'a) list\\\" where\\n \\\"mpoly_to_mpoly_poly_impl_aux1 i [] j = []\\\"\\n| \\\"mpoly_to_mpoly_poly_impl_aux1 i ((mon', c) # xs) j =\\n (if lookup mon' i = j then [(remove_key i mon', c)] else []) @ mpoly_to_mpoly_poly_impl_aux1 i xs j\\\"\\n\\nlemma mpoly_to_mpoly_poly_impl_aux1_altdef:\\n \\\"mpoly_to_mpoly_poly_impl_aux1 i xs j =\\n map (\\\\<lambda>(mon, c). (remove_key i mon, c)) (filter (\\\\<lambda>(mon, c). lookup mon i = j) xs)\\\"\\n by (induction xs) auto\\n\\nlemma map_of_mpoly_to_mpoly_poly_impl_aux1:\\n \\\"map_of (mpoly_to_mpoly_poly_impl_aux1 i xs j) = (\\\\<lambda>mon.\\n (if lookup mon i > 0 then None\\n else map_of xs (mon + Poly_Mapping.single i j)))\\\"\\n apply (rule ext)\\n apply (induction i xs j rule: mpoly_to_mpoly_poly_impl_aux1.induct)\\n apply (auto simp: remove_key_lookup)\\n apply (meson remove_key_sum)\\n apply (metis add_left_cancel lookup_single_eq remove_key_sum)\\n apply (metis remove_key_add remove_key_single remove_key_sum single_zero)\\n done\\n\\nlemma lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1:\\n \\\"lookup0 (fmap_of_list (mpoly_to_mpoly_poly_impl_aux1 i xs j)) = (\\\\<lambda>mon.\\n lookup0 (fmap_of_list xs) (mon + Poly_Mapping.single i j) when lookup mon i = 0)\\\"\\n by (auto simp add: fmlookup_default_def fmlookup_of_list map_of_mpoly_to_mpoly_poly_impl_aux1)\\n\\ndefinition mpoly_to_mpoly_poly_impl_aux2 where\\n \\\"mpoly_to_mpoly_poly_impl_aux2 i p j = poly.coeff (mpoly_to_mpoly_poly i p) j\\\"\\n\\nlemma coeff_MPoly: \\\"MPoly_Type.coeff (MPoly f) m = lookup f m\\\"\\n by (simp add: coeff_def mpoly.MPoly_inverse)\\n\\nlemma mpoly_to_mpoly_poly_impl_aux2_code [code]:\\n \\\"mpoly_to_mpoly_poly_impl_aux2 i (MPoly (Pm_fmap (fmap_of_list xs))) j =\\n MPoly (Pm_fmap (fmap_of_list (mpoly_to_mpoly_poly_impl_aux1 i xs j)))\\\"\\n unfolding mpoly_to_mpoly_poly_impl_aux2_def\\n by (rule mpoly_eqI)\\n (simp add: coeff_coeff_mpoly_to_mpoly_poly coeff_MPoly\\n lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1)\\n\\ndefinition mpoly_to_mpoly_poly_impl :: \\\"nat \\\\<Rightarrow> 'a :: comm_ring_1 mpoly \\\\<Rightarrow> 'a mpoly list\\\" where\\n \\\"mpoly_to_mpoly_poly_impl x p = (if p = 0 then [] else\\n map (mpoly_to_mpoly_poly_impl_aux2 x p) [0..<Suc (MPoly_Type.degree p x)])\\\"\\n\\nlemma mpoly_to_mpoly_poly_eq_0_iff [simp]: \\\"mpoly_to_mpoly_poly x p = 0 \\\\<longleftrightarrow> p = 0\\\"\\nproof -\\n interpret transfer_mpoly_to_mpoly_poly x .\\n define p' where \\\"p' = mpoly_to_mpoly_poly x p\\\"\\n have [transfer_rule]: \\\"R p' p\\\"\\n by (auto simp: R_def p'_def)\\n show ?thesis\\n unfolding p'_def [symmetric] by transfer_prover\\nqed\\n\\nlemma mpoly_to_mpoly_poly_code [code]:\\n \\\"Polynomial.coeffs (mpoly_to_mpoly_poly x p) = mpoly_to_mpoly_poly_impl x p\\\"\\n by (intro nth_equalityI)\\n (auto simp: mpoly_to_mpoly_poly_impl_def length_coeffs_degree\\n mpoly_to_mpoly_poly_impl_aux2_def coeffs_nth simp del: upt_Suc)\\n\\nvalue \\\"mpoly_to_mpoly_poly 0 (Var 0 ^ 2 + Var 0 * Var 1 + Var 1 ^ 2 :: int mpoly)\\\"\\n\\nvalue \\\"Rings.divide (Var 0 ^ 2 * Var 1 + Var 0 * Var 1 ^ 2 :: int mpoly) (Var 1)\\\"\\n\\nend\"} {\"text\": \"lemma succ_le_succ (a b : mynat) (h : a \\u2264 b) : succ a \\u2264 succ b :=\\nbegin\\ncases h with c hc,\\nuse c,\\nrwa [hc, succ_add],\\nend\\n\"} {\"text\": \"import linear_algebra.finite_dimensional\\nimport missing_mathlib.linear_algebra.dimension\\n\\nuniverses u v v' w\\nopen_locale classical\\n\\nopen vector_space cardinal submodule module function\\n\\nvariables {K : Type u} {V : Type v} [field K] [add_comm_group V] [vector_space K V]\\n{V\\u2082 : Type v'} [add_comm_group V\\u2082] [vector_space K V\\u2082]\\n\\nnamespace finite_dimensional\\n\\nlemma findim_bot [finite_dimensional K V] : \\n findim K (\\u22a5 : submodule K V) = 0 :=\\nbegin\\n apply cardinal.nat_cast_inj.1,\\n rw findim_eq_dim,\\n rw dim_bot,\\n refl,\\nend\\n\\nlemma bot_of_findim_zero [finite_dimensional K V]\\n (s : submodule K V) (h : findim K s = 0) : s = \\u22a5 :=\\nbegin\\n apply submodule.bot_of_dim_zero,\\n rw \\u2190findim_eq_dim,\\n apply cardinal.nat_cast_inj.2 h,\\nend\\n\\n@[simp] lemma findim_top [finite_dimensional K V] : \\n findim K (\\u22a4 : submodule K V) = findim K V :=\\nbegin\\n apply cardinal.nat_cast_inj.1,\\n rw [findim_eq_dim, findim_eq_dim, dim_top]\\nend\\n\\nlemma exists_mem_ne_zero_of_findim_pos\\n [finite_dimensional K V] (h_dim : 0 < findim K V) : \\u2203 x : V, x \\u2260 0 :=\\nbegin\\n apply @exists_mem_ne_zero_of_dim_pos' K V (by apply_instance),\\n rw \\u2190findim_eq_dim,\\n rw \\u2190cardinal.nat_cast_lt at h_dim,\\n apply h_dim\\nend\\n\\nlemma findim_sup_add_findim_inf_eq [finite_dimensional K V] (s t : submodule K V) :\\n findim K (s \\u2294 t : submodule K V) + findim K (s \\u2293 t : submodule K V) \\n = findim K s + findim K t :=\\nbegin\\n have := s.dim_sup_add_dim_inf_eq t,\\n repeat { rw \\u2190findim_eq_dim at this },\\n exact this,\\nend\\n\\nlemma eq_top_of_disjoint [finite_dimensional K V] (s t : submodule K V) \\n (hdim : findim K s + findim K t = findim K V)\\n (hdisjoint : disjoint s t) : s \\u2294 t = \\u22a4 :=\\nbegin\\n have h_findim_inf : findim K \\u21a5(s \\u2293 t) = 0,\\n { rw [disjoint, le_bot_iff] at hdisjoint,\\n rw [hdisjoint, findim_bot] },\\n apply eq_top_of_findim_eq,\\n rw \\u2190hdim,\\n convert findim_sup_add_findim_inf_eq s t,\\n rw h_findim_inf,\\n refl,\\nend\\n\\nlemma lt_omega_of_linear_independent {\\u03b9 : Type w} [finite_dimensional K V]\\n {v : \\u03b9 \\u2192 V} (h : linear_independent K v) : \\n cardinal.mk \\u03b9 < cardinal.omega :=\\nbegin\\n apply cardinal.lift_lt.1,\\n apply lt_of_le_of_lt,\\n apply linear_independent_le_dim h,\\n rw [\\u2190findim_eq_dim, cardinal.lift_omega, cardinal.lift_nat_cast],\\n apply cardinal.nat_lt_omega,\\nend\\n\\nend finite_dimensional\"} {\"text\": \"",
    "formal_statement": "is: lemma emeasure_lfp'[consumes 1, case_names cont measurable]: assumes \\\"P M\\\" assumes cont: \\\"sup_continuous F\\\" assumes *: \\\"\\\\<And>M A. P M \\\\<Longrightarrow> (\\\\<And>N. P N \\\\<Longrightarrow> Measurable.pred N A) \\\\<Longrightarrow> Measurable.pred M (F A)\\\" shows \\\"emeasure M {x\\\\<in>space M. lfp F x} = (SUP i. emeasure M {x\\\\<in>space M. (F ^^ i) (\\\\<lambda>x. False) x})\\\" Informal statement is: If $F$ is a sup-continuous operator on the set of measurable predicates on a measure space $M$, then the measure of the set of points $x$ such that the least fixed point of $F$ at $x$ is true is equal to the supremum of the measures of the sets of points $x$ such that the $i$th iterate of $F$ at $x$ is true.\"} {\"text\": \" write (*,*)\\n! !\\\"AA\\\"\\n end\"} {\"text\": \"variables p q : Prop\\n\\ntheorem t1 : p \\u2192 q \\u2192 p"
  },
  {
    "informal_statement": "Show that 2 is divisible by $(1+i)^{2}$ in $\\\\mathbb{Z}[i]$.",
    "formal_statement": "theorem exercise_1_31 : (\\u27e81, 1\\u27e9 : gaussian_int) ^ 2 \\u2223 2"
  },
  {
    "informal_statement": "Prove that the multiplicative groups $\\\\mathbb{R}-\\\\{0\\\\}$ and $\\\\mathbb{C}-\\\\{0\\\\}$ are not isomorphic.",
    "formal_statement": "theorem exercise_1_6_4 : \\n is_empty (multiplicative \\u211d \\u2243* multiplicative \\u2102)"
  },
  {
    "informal_statement": "is: The coefficients of the polynomial obtained by applying a function to the coefficients of a polynomial are the coefficients of the original polynomial with zeros stripped off and the function applied to each coefficient.\"} {\"text\": \"open import Relation.Binary.Core\\n\\nmodule TreeSort.Impl2.Correctness.Permutation {A : Set}\\n (_\\u2264_ : A \\u2192 A \\u2192 Set)\\n (tot\\u2264 : Total _\\u2264_) where\\n\\nopen import BBSTree _\\u2264_ \\nopen import Bound.Total A\\nopen import Bound.Total.Order _\\u2264_\\nopen import Data.List\\nopen import Data.Sum\\nopen import List.Permutation.Base A\\nopen import List.Permutation.Base.Concatenation A\\nopen import TreeSort.Impl2 _\\u2264_ tot\\u2264\\n\\nlemma-insert-/ : {a b : Bound}{x : A}(a\\u2264x : LeB a (val x))(x\\u2264b : LeB (val x) b)(t : BBSTree a b) \\u2192 (flatten (insert a\\u2264x x\\u2264b t)) / x \\u27f6 (flatten t) \\nlemma-insert-/ a\\u2264x x\\u2264b (bslf _) = /head\\nlemma-insert-/ {x = x} b\\u2264x x\\u2264t (bsnd {x = y} b\\u2264y y\\u2264t l r) \\n with tot\\u2264 x y\\n... | inj\\u2081 x\\u2264y = lemma++/r (lemma-insert-/ b\\u2264x (lexy x\\u2264y) l)\\n... | inj\\u2082 y\\u2264x = lemma++/l {xs = flatten l} (/tail (lemma-insert-/ (lexy y\\u2264x) x\\u2264t r))\\n\\ntheorem-treeSort\\u223c : (xs : List A) \\u2192 xs \\u223c (flatten (treeSort xs))\\ntheorem-treeSort\\u223c [] = \\u223c[]\\ntheorem-treeSort\\u223c (x \\u2237 xs) = \\u223cx /head (lemma-insert-/ lebx lext (treeSort xs)) (theorem-treeSort\\u223c xs)\\n\\n\\n\\n\\n\"} {\"text\": \"/-\\nCopyright (c) 2023 Eric Wieser. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Eric Wieser\\n\\n! This file was ported from Lean 3 source module ring_theory.complex\\n! leanprover-community/mathlib commit 9015c511549dc77a0f8d6eba021d8ac4bba20c82\\n! Please do not edit these lines, except to modify the commit id\\n! if you have ported upstream changes.\\n-/\\nimport Mathbin.Data.Complex.Module\\nimport Mathbin.RingTheory.Norm\\nimport Mathbin.RingTheory.Trace\\n\\n/-! # Lemmas about `algebra.trace` and `algebra.norm` on `\\u2102` -/\\n\\n\\nopen Complex\\n\\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `\\u00abexpr!![ \\u00bb -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:387:14: unsupported user notation matrix.notation -/\\ntheorem Algebra.leftMulMatrix_complex (z : \\u2102) :\\n Algebra.leftMulMatrix Complex.basisOneI z =\\n \\u00abexpr!![ \\u00bb\\n \\\"./././Mathport/Syntax/Translate/Expr.lean:387:14: unsupported user notation matrix.notation\\\" :=\\n by\\n ext (i j)\\n rw [Algebra.leftMulMatrix_eq_repr_mul, Complex.coe_basisOneI_repr, Complex.coe_basisOneI, mul_re,\\n mul_im, Matrix.of_apply]\\n fin_cases j\\n \\u00b7 simp_rw [Matrix.cons_val_zero, one_re, one_im, MulZeroClass.mul_zero, mul_one, sub_zero,\\n zero_add]\\n fin_cases i <;> rfl\\n \\u00b7 simp_rw [Matrix.cons_val_one, Matrix.head_cons, I_re, I_im, MulZeroClass.mul_zero, mul_one,\\n zero_sub, add_zero]\\n fin_cases i <;> rfl\\n#align algebra.left_mul_matrix_complex Algebra.leftMulMatrix_complex\\n\\ntheorem Algebra.trace_complex_apply (z : \\u2102) : Algebra.trace \\u211d \\u2102 z = 2 * z.re :=\\n by\\n rw [Algebra.trace_eq_matrix_trace Complex.basisOneI, Algebra.leftMulMatrix_complex,\\n Matrix.trace_fin_two]\\n exact (two_mul _).symm\\n#align algebra.trace_complex_apply Algebra.trace_complex_apply\\n\\ntheorem Algebra.norm_complex_apply (z : \\u2102) : Algebra.norm \\u211d z = z.normSq :=\\n by\\n rw [Algebra.norm_eq_matrix_det Complex.basisOneI, Algebra.leftMulMatrix_complex,\\n Matrix.det_fin_two, norm_sq_apply]\\n simp\\n#align algebra.norm_complex_apply Algebra.norm_complex_apply\\n\\ntheorem Algebra.norm_complex_eq : Algebra.norm \\u211d = normSq.toMonoidHom :=\\n MonoidHom.ext Algebra.norm_complex_apply\\n#align algebra.norm_complex_eq Algebra.norm_complex_eq\\n\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 OpenAI. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\\n-/\\nimport mathzoo.imports.miniF2F\\n\\nopen_locale nat rat real big_operators topological_space\\n\\ntheorem amc12b_2002_p6\\n (a b : \\u211d)\\n (h\\u2080 : a \\u2260 0 \\u2227 b \\u2260 0)\\n (h\\u2081 : \\u2200 x, x^2 + a * x + b = (x - a) * (x - b)) :\\n a = 1 \\u2227 b = -2 :=\\nbegin\\n have h\\u2082 := h\\u2081 a,\\n have h\\u2083 := h\\u2081 b,\\n have h\\u2084 := h\\u2081 0,\\n simp at *,\\n have h\\u2085 : b * (1 - a) = 0, linarith,\\n simp at h\\u2085,\\n cases h\\u2085 with h\\u2085 h\\u2086,\\n exfalso,\\n exact absurd h\\u2085 h\\u2080.2,\\n have h\\u2086 : a = 1, linarith,\\n split,\\n exact h\\u2086,\\n rw h\\u2086 at h\\u2082,\\n linarith,\\nend\"} {\"text\": \"(* This file is generated by Why3's Coq driver *)\\n(* Beware! Only edit allowed sections below *)\\nRequire Import ZArith.\\nRequire Import Rbase.\\nAxiom Max_is_ge : forall (x:Z) (y:Z), (x <= (Zmax x y))%Z /\\\\\\n (y <= (Zmax x y))%Z.\\n\\nAxiom Max_is_some : forall (x:Z) (y:Z), ((Zmax x y) = x) \\\\/ ((Zmax x y) = y).\\n\\nAxiom Min_is_le : forall (x:Z) (y:Z), ((Zmin x y) <= x)%Z /\\\\\\n ((Zmin x y) <= y)%Z.\\n\\nAxiom Min_is_some : forall (x:Z) (y:Z), ((Zmin x y) = x) \\\\/ ((Zmin x y) = y).\\n\\nAxiom Max_x : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmax x y) = x).\\n\\nAxiom Max_y : forall (x:Z) (y:Z), (x <= y)%Z -> ((Zmax x y) = y).\\n\\nAxiom Min_x : forall (x:Z) (y:Z), (x <= y)%Z -> ((Zmin x y) = x).\\n\\nAxiom Min_y : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmin x y) = y).\\n\\nAxiom Max_sym : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmax x y) = (Zmax y x)).\\n\\nAxiom Min_sym : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmin x y) = (Zmin y x)).\\n\\nInductive list (a:Type) :=\\n | Nil : list a\\n | Cons : a -> (list a) -> list a.\\nSet Contextual Implicit.\\nImplicit Arguments Nil.\\nUnset Contextual Implicit.\\nImplicit Arguments Cons.\\n\\nSet Implicit Arguments.\\nFixpoint length (a:Type)(l:(list a)) {struct l}: Z :=\\n match l with\\n | Nil => 0%Z\\n | Cons _ r => (1%Z + (length r))%Z\\n end.\\nUnset Implicit Arguments.\\n\\nAxiom Length_nonnegative : forall (a:Type), forall (l:(list a)),\\n (0%Z <= (length l))%Z.\\n\\nAxiom Length_nil : forall (a:Type), forall (l:(list a)),\\n ((length l) = 0%Z) <-> (l = (Nil:(list a))).\\n\\nParameter char : Type.\\n\\nDefinition word := (list char).\\n\\nInductive dist : (list char) -> (list char) -> Z -> Prop :=\\n | dist_eps : (dist (Nil:(list char)) (Nil:(list char)) 0%Z)\\n | dist_add_left : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\\n w2 n) -> forall (a:char), (dist (Cons a w1) w2 (n + 1%Z)%Z)\\n | dist_add_right : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\\n w2 n) -> forall (a:char), (dist w1 (Cons a w2) (n + 1%Z)%Z)\\n | dist_context : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\\n w2 n) -> forall (a:char), (dist (Cons a w1) (Cons a w2) n).\\n\\nDefinition min_dist(w1:(list char)) (w2:(list char)) (n:Z): Prop := (dist w1\\n w2 n) /\\\\ forall (m:Z), (dist w1 w2 m) -> (n <= m)%Z.\\n\\nSet Implicit Arguments.\\nFixpoint infix_plpl (a:Type)(l1:(list a)) (l2:(list a)) {struct l1}: (list\\n a) :=\\n match l1 with\\n | Nil => l2\\n | Cons x1 r1 => (Cons x1 (infix_plpl r1 l2))\\n end.\\nUnset Implicit Arguments.\\n\\nAxiom Append_assoc : forall (a:Type), forall (l1:(list a)) (l2:(list a))\\n (l3:(list a)), ((infix_plpl l1 (infix_plpl l2\\n l3)) = (infix_plpl (infix_plpl l1 l2) l3)).\\n\\nAxiom Append_l_nil : forall (a:Type), forall (l:(list a)), ((infix_plpl l\\n (Nil:(list a))) = l).\\n\\nAxiom Append_length : forall (a:Type), forall (l1:(list a)) (l2:(list a)),\\n ((length (infix_plpl l1 l2)) = ((length l1) + (length l2))%Z).\\n\\nSet Implicit Arguments.\\nFixpoint mem (a:Type)(x:a) (l:(list a)) {struct l}: Prop :=\\n match l with\\n | Nil => False\\n | Cons y r => (x = y) \\\\/ (mem x r)\\n end.\\nUnset Implicit Arguments.\\n\\nAxiom mem_append : forall (a:Type), forall (x:a) (l1:(list a)) (l2:(list a)),\\n (mem x (infix_plpl l1 l2)) <-> ((mem x l1) \\\\/ (mem x l2)).\\n\\nAxiom mem_decomp : forall (a:Type), forall (x:a) (l:(list a)), (mem x l) ->\\n exists l1:(list a), exists l2:(list a), (l = (infix_plpl l1 (Cons x l2))).\\n\\nSet Implicit Arguments.\\nFixpoint last_char(a:char) (u:(list char)) {struct u}: char :=\\n match u with\\n | Nil => a\\n | Cons c uqt => (last_char c uqt)\\n end.\\nUnset Implicit Arguments.\\n\\nSet Implicit Arguments.\\nFixpoint but_last(a:char) (u:(list char)) {struct u}: (list char) :=\\n match u with\\n | Nil => (Nil:(list char))\\n | Cons c uqt => (Cons a (but_last c uqt))\\n end.\\nUnset Implicit Arguments.\\n\\n(* YOU MAY EDIT THE CONTEXT BELOW *)\\n\\n(* DO NOT EDIT BELOW *)\\n\\nTheorem first_last_explicit : forall (u:(list char)) (a:char),\\n ((infix_plpl (but_last a u) (Cons (last_char a u) (Nil:(list\\n char)))) = (Cons a u)).\\n(* YOU MAY EDIT THE PROOF BELOW *)\\nsimple induction u; simpl.\\nreflexivity.\\nintros.\\nrewrite (H a).\\nreflexivity.\\nQed.\\n(* DO NOT EDIT BELOW *)\\n\\n\\n\"} {\"text\": \"A set is locally $P$ if and only if it is $P$.\"} {\"text\": \"theorem ex1 (x : Nat) : 0 + x = x := by\\n cases x with\\n | zero => skip -- Error: unsolved goals\\n | succ y => skip -- Error: unsolved goals\\n\\ntheorem ex2 (x : Nat) : 0 + x = x := by\\n induction x with\\n | zero => skip -- Error: unsolved goals\\n | succ y ih => skip -- Error: unsolved goals\\n\\ntheorem ex3 (x : Nat) : 0 + x = x := by\\n cases x with\\n | zero => rfl\\n | succ y => skip -- Error: unsolved goals\\n\\ntheorem ex4 (x : Nat) {y : Nat} (h : y > 0) : x % y < y := by\\n induction x, y using Nat.mod.inductionOn with\\n | ind x y h\\u2081 ih => skip -- Error: unsolved goals\\n | base x y h\\u2081 => skip -- Error: unsolved goals\\n\\ntheorem ex5 (x : Nat) {y : Nat} (h : y > 0) : x % y < y := by\\n cases x, y using Nat.mod.inductionOn with\\n | ind x y h\\u2081 ih => skip -- Error: unsolved goals\\n | base x y h\\u2081 => skip -- Error: unsolved goals\\n\"} {\"text\": \"import data.complex.basic\\nvariable z : \\u2102 \\ntheorem Q7 (H : z^2=-1) : z=complex.I \\u2228 z = -complex.I := sorry\\n\"} {\"text\": \"[STATEMENT]\\nlemma fromEnumTrue [simp]: \\\"fromEnum True = 1\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. fromEnum True = 1\\n[PROOF STEP]\\nby (simp add: fromEnum_def enum_bool)\"} {\"text\": \"in",
    "formal_statement": "Prove that for all $n>1$ that $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is not a group under multiplication of residue classes.formal statement theorem exercise_1_1_16 {G : Type*} [group G] \\n (x : G) (hx : x ^ 2 = 1) :\\n order_of x = 1 \\u2228 order_of x = 2"
  },
  {
    "informal_statement": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\\\in A$. Prove that $\\\\inf A=-\\\\sup (-A)$.",
    "formal_statement": "theorem exercise_1_5 (A minus_A : set \\u211d) (hA : A.nonempty) \\n (hA_bdd_below : bdd_below A) (hminus_A : minus_A = {x | -x \\u2208 A}) :\\n Inf A = Sup minus_A"
  },
  {
    "informal_statement": "is: The frontier of the empty set is the empty set.\"} {\"text\": \"{-# LANGUAGE Trustworthy, CPP, MagicHash, UnboxedTuples, BangPatterns #-}\\n{-# LANGUAGE FlexibleInstances, FlexibleContexts, TypeOperators #-}\\n\\n{- |\\n Module : SDP.Unboxed\\n Copyright : (c) Andrey Mulik 2019-2021\\n License : BSD-style\\n Maintainer : work.a.mulik@gmail.com\\n Portability : non-portable (GHC extensions)\\n \\n \\\"SDP.Unboxed\\\" provide service class 'Unboxed', that needed for\\n \\\"SDP.Prim.SBytes\\\"-based structures.\\n-}\\nmodule SDP.Unboxed\\n(\\n -- * Unboxed\\n Unboxed (..), cloneUnboxed#, cloneUnboxedM#, thawUnboxed#, freezeUnboxed#,\\n \\n -- ** Kind @(Type -> Type)@ proxies\\n fromProxy, psizeof#, psizeof, pnewUnboxed, pcopyUnboxed, pcopyUnboxedM,\\n pcloneUnboxed, pcloneUnboxedM, pthawUnboxed, pfreezeUnboxed,\\n \\n -- ** Kind @(Type -> Type -> Type)@ proxies\\n fromProxy1, pnewUnboxed1, pcloneUnboxed1, pcopyUnboxed1, pcopyUnboxedM1,\\n cloneUnboxed1#, pcloneUnboxedM1,\\n \\n -- Wrap helper\\n Wrap (..), lzero#, single#, fromList#, fromFoldable#, fromListN#,\\n newLinear#, newLinearN#, fromFoldableM#, concat#, pconcat\\n)\\nwhere\\n\\nimport Prelude ()\\nimport SDP.SafePrelude\\nimport SDP.Nullable\\nimport SDP.Finite\\nimport SDP.Shape\\nimport SDP.Ratio\\n\\nimport GHC.Stable\\nimport GHC.Base hiding ( (.), foldr )\\nimport GHC.Word\\nimport GHC.Int\\nimport GHC.Ptr\\nimport GHC.ST\\n\\nimport Data.Complex\\n\\nimport Foreign.C.Types\\n\\n#include \\\"MachDeps.h\\\"\\n\\ndefault ()\\n\\n--------------------------------------------------------------------------------\\n\\n{- |\\n 'Unboxed' is a layer between untyped raw data and parameterized unboxed data\\n structures. Also it prevents direct interaction with primitives.\\n-}\\nclass (Eq e) => Unboxed e\\n where\\n {-# MINIMAL (sizeof#|sizeof), (!#), (!>#), writeByteArray#, newUnboxed #-}\\n \\n {- |\\n @sizeof e n@ returns the length (in bytes) of primitive, where @n@ - count\\n of elements, @e@ - type parameter.\\n -}\\n {-# INLINE sizeof #-}\\n sizeof :: e -> Int -> Int\\n sizeof e (I# c#) = I# (sizeof# e c#)\\n \\n -- | 'sizeof#' is unboxed 'sizeof'.\\n {-# INLINE sizeof# #-}\\n sizeof# :: e -> Int# -> Int#\\n sizeof# e c# = case sizeof e (I# c#) of I# n# -> n#\\n \\n -- | Unsafe 'ByteArray#' reader with overloaded result type.\\n (!#) :: ByteArray# -> Int# -> e\\n \\n -- | Unsafe 'MutableByteArray#' reader with overloaded result type.\\n (!>#) :: MutableByteArray# s -> Int# -> State# s -> (# State# s, e #)\\n \\n -- | Unsafe 'MutableByteArray#' writer.\\n writeByteArray# :: MutableByteArray# s -> Int# -> e -> State# s -> State# s\\n \\n {-# INLINE fillByteArray# #-}\\n -- | Procedure for filling the array with the default value (like calloc).\\n fillByteArray# :: MutableByteArray# s -> Int# -> e -> State# s -> State# s\\n fillByteArray# mbytes# n# e = I# n# > 0 ? go (n# -# 1#) $ \\\\ s1# -> s1#\\n where\\n go 0# s2# = writeByteArray# mbytes# 0# e s2#\\n go c# s2# = go (c# -# 1#) (writeByteArray# mbytes# c# e s2#)\\n \\n {- |\\n 'newUnboxed' creates new 'MutableByteArray#' of given count of elements.\\n First argument used as type variable.\\n -}\\n newUnboxed :: e -> Int# -> State# s -> (# State# s, MutableByteArray# s #)\\n \\n {-# INLINE newUnboxed' #-}\\n {- |\\n 'newUnboxed'' is version of 'newUnboxed', that use first argument as\\n initial value. May fail when trying to write 'error' or 'undefined'.\\n -}\\n newUnboxed' :: e -> Int# -> State# s -> (# State# s, MutableByteArray# s #)\\n newUnboxed' e n# = \\\\ s1# -> case newByteArray# (sizeof# e n#) s1# of\\n (# s2#, mbytes# #) -> case fillByteArray# mbytes# n# e s2# of\\n s3# -> (# s3#, mbytes# #)\\n \\n {- |\\n @'copyUnboxed#' e bytes\\\\# o1\\\\# mbytes\\\\# o2\\\\# n\\\\#@ unsafely writes elements\\n from @bytes\\\\#@ to @mbytes\\\\#@, where o1\\\\# and o2\\\\# - offsets (element\\n count), @n\\\\#@ - count of elements to copy.\\n -}\\n copyUnboxed# :: e -> ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\n copyUnboxed# e bytes# o1# mbytes# o2# n# = copyByteArray# bytes# (sizeof# e o1#) mbytes# (sizeof# e o2#) (sizeof# e n#)\\n \\n {- |\\n @'copyUnboxedM#' e msrc\\\\# o1\\\\# mbytes\\\\# o2\\\\# n\\\\#@ unsafely writes elements\\n from @msrc\\\\#@ to @mbytes\\\\#@, where o1\\\\# and o2\\\\# - offsets (element\\n count), @n\\\\#@ - count of elements to copy.\\n -}\\n copyUnboxedM# :: e -> MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\n copyUnboxedM# e msrc# o1# mbytes# o2# n# = copyMutableByteArray# msrc# (sizeof# e o1#) mbytes# (sizeof# e o2#) (sizeof# e n#)\\n \\n {- |\\n @'hashUnboxedWith' e len# off# bytes# salt@ returns @bytes#@ @FNV-1@ hash,\\n where @off#@ and @len#@ is offset and length (in elements).\\n \\n Note: the standard definition of this function is written in Haskell using\\n low-level functions, but this implementation mayn't be as efficient as the\\n foreign procedure in the @hashable@ package.\\n -}\\n hashUnboxedWith :: e -> Int# -> Int# -> ByteArray# -> Int# -> Int#\\n hashUnboxedWith e len# off# bytes# = go (sizeof# e off#) (sizeof# e len#)\\n where\\n go _ 0# salt# = salt#\\n go o# n# salt# = go (o# +# 1#) (n# -# 1#) (word2Int# hash#)\\n where\\n prod# = int2Word# (salt# *# 16777619#)\\n elem# = indexWord8Array# bytes# o#\\n hash# = prod# `xor#` elem#\\n\\n--------------------------------------------------------------------------------\\n\\n{- Unboxed helpers. -}\\n\\n{- |\\n @since 0.2\\n @cloneUnboxed# e bytes# o# c#@ creates new @c#@-element length immutable slice\\n of @bytes#@ beginning from @o#@-th element.\\n-}\\ncloneUnboxed# :: (Unboxed e) => e -> ByteArray# -> Int# -> Int# -> ByteArray#\\ncloneUnboxed# e bytes# o# c# = unwrap $ runST $ ST $\\n \\\\ s1# -> case newUnboxed e c# s1# of\\n (# s2#, mbytes# #) -> case copyUnboxed# e bytes# o# mbytes# 0# c# s2# of\\n s3# -> case unsafeFreezeByteArray# mbytes# s3# of\\n (# s4#, bytes'# #) -> (# s4#, (Wrap bytes'#) #)\\n\\n{- |\\n @since 0.2.1\\n @cloneUnboxedM# e mbytes# o# c#@ creates new @c#@-element length mutable slice\\n of @bytes#@ beginning from @o#@-th element.\\n-}\\ncloneUnboxedM# :: (Unboxed e) => e -> MutableByteArray# s -> Int# -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\ncloneUnboxedM# e mbytes# o# n# = \\\\ s1# -> case newByteArray# (sizeof# e n#) s1# of\\n (# s2#, copy# #) -> case copyUnboxedM# e mbytes# o# copy# 0# n# s2# of\\n s3# -> (# s3#, copy# #)\\n\\n{- |\\n @since 0.2.1\\n @'thawUnboxed#' e bytes# c#@ creates new @sizeof# e c#@ bytes length\\n 'MutableByteArray#' and copy @bytes#@ to it.\\n-}\\nthawUnboxed# :: (Unboxed e) => e -> ByteArray# -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\nthawUnboxed# e bytes# c# = \\\\ s1# -> case newByteArray# n# s1# of\\n (# s2#, mbytes# #) -> case copyByteArray# bytes# 0# mbytes# 0# n# s2# of\\n s3# -> (# s3#, mbytes# #)\\n where\\n n# = sizeof# e c#\\n\\n{- |\\n @since 0.2.1\\n @'freezeUnboxed#' e mbytes# c#@ creates new @sizeof# e c#@ bytes length\\n 'ByteArray#' and copy @mbytes#@ to it.\\n-}\\nfreezeUnboxed# :: (Unboxed e) => e -> MutableByteArray# s -> Int# ->\\n State# s -> (# State# s, ByteArray# #)\\nfreezeUnboxed# e mbytes# n# = \\\\ s1# -> case cloneUnboxedM# e mbytes# 0# n# s1# of\\n (# s2#, copy# #) -> unsafeFreezeByteArray# copy# s2#\\n\\n--------------------------------------------------------------------------------\\n\\n{- Rank 1 Unboxed proxies. -}\\n\\n-- | Returns 'undefined' of suitable type.\\nfromProxy :: proxy e -> e\\nfromProxy = const undefined\\n\\n{- |\\n @since 0.2.1\\n 'psizeof#' is proxy version of 'sizeof#'.\\n-}\\npsizeof# :: (Unboxed e) => proxy e -> Int# -> Int#\\npsizeof# = sizeof# . fromProxy\\n\\n{- |\\n @since 0.2\\n 'psizeof' is proxy version of 'sizeof'.\\n-}\\npsizeof :: (Unboxed e) => proxy e -> Int -> Int\\npsizeof = sizeof . fromProxy\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type)@ proxy version of 'newUnboxed'.\\n-}\\npnewUnboxed :: (Unboxed e) => proxy e -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\npnewUnboxed = newUnboxed . fromProxy\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type)@ proxy version if 'copyUnboxed#'.\\n-}\\npcopyUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# ->\\n MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\npcopyUnboxed = copyUnboxed# . fromProxy\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type)@ proxy version if 'copyUnboxedM#'.\\n-}\\npcopyUnboxedM :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# ->\\n MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\npcopyUnboxedM = copyUnboxedM# . fromProxy\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type)@ proxy version of 'cloneUnboxed#'.\\n-}\\ncloneUnboxed1# :: (Unboxed e) => proxy e -> ByteArray# -> Int# -> Int# -> ByteArray#\\ncloneUnboxed1# = cloneUnboxed# . fromProxy\\n\\n{- |\\n @since 0.2.1\\n Same as @sdp-0.2@ 'cloneUnboxed1#'. Use only if you don't need @sdp-0.2@\\n compatibility.\\n-}\\npcloneUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# -> Int# -> ByteArray#\\npcloneUnboxed = cloneUnboxed1#\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type)@ proxy version of 'cloneUnboxed#'.\\n-}\\npcloneUnboxedM :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\npcloneUnboxedM = cloneUnboxedM# . fromProxy\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type)@ proxy version of 'thawUnboxed#'.\\n-}\\npthawUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\npthawUnboxed = thawUnboxed# . fromProxy\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type)@ proxy version of 'pfreezeUnboxed'.\\n-}\\npfreezeUnboxed :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# ->\\n State# s -> (# State# s, ByteArray# #)\\npfreezeUnboxed = freezeUnboxed# . fromProxy\\n\\n--------------------------------------------------------------------------------\\n\\n{- (Type -> Type -> Type)-kind Unboxed proxies. -}\\n\\n-- | Returns 'undefined' of suitable type.\\nfromProxy1 :: m (proxy e) -> e\\nfromProxy1 = const undefined\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type -> Type)@ proxy version of 'newUnboxed'.\\n-}\\npnewUnboxed1 :: (Unboxed e) => p (proxy e) -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\npnewUnboxed1 = newUnboxed . fromProxy1\\n\\n{- |\\n @since 0.2\\n Kind @(Type -> Type -> Type)@ proxy version of 'copyUnboxed#'.\\n-}\\npcopyUnboxed1 :: (Unboxed e) => p (proxy e) -> ByteArray# -> Int# ->\\n MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\npcopyUnboxed1 = copyUnboxed# . fromProxy1\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type -> Type)@ proxy version of 'copyUnboxedM#'.\\n-}\\npcopyUnboxedM1 :: (Unboxed e) => p (proxy e) -> MutableByteArray# s -> Int# ->\\n MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\\npcopyUnboxedM1 = copyUnboxedM# . fromProxy1\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type -> Type)@ proxy version of 'cloneUnboxed#'.\\n-}\\npcloneUnboxed1 :: (Unboxed e) => p (proxy e) -> ByteArray# -> Int# -> Int# -> ByteArray#\\npcloneUnboxed1 = cloneUnboxed# . fromProxy1\\n\\n{- |\\n @since 0.2.1\\n Kind @(Type -> Type -> Type)@ proxy version of 'cloneUnboxed#'.\\n-}\\npcloneUnboxedM1 :: (Unboxed e) => p (proxy e) -> MutableByteArray# s -> Int# -> Int# ->\\n State# s -> (# State# s, MutableByteArray# s #)\\npcloneUnboxedM1 = cloneUnboxedM# . fromProxy1\\n\\n--------------------------------------------------------------------------------\\n\\n{- Numeric instances. -}\\n\\ninstance Unboxed Int\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSWORD\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = I# (indexIntArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readIntArray# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, I# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (I# e#) = writeIntArray# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Int)\\n\\ninstance Unboxed Int8\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = I8# (indexInt8Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readInt8Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, I8# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (I8# e#) = writeInt8Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Int8)\\n\\ninstance Unboxed Int16\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 2\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = I16# (indexInt16Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readInt16Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, I16# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (I16# e#) = writeInt16Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Int16)\\n\\ninstance Unboxed Int32\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 4\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = I32# (indexInt32Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readInt32Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, I32# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (I32# e#) = writeInt32Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Int32)\\n\\ninstance Unboxed Int64\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 8\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = I64# (indexInt64Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readInt64Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, I64# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (I64# e#) = writeInt64Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Int64)\\n\\ninstance Unboxed Word\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSWORD\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = W# (indexWordArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWordArray# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, W# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (W# e#) = writeWordArray# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Word)\\n\\ninstance Unboxed Word8\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = W8# (indexWord8Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWord8Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, W8# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (W8# e#) = writeWord8Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Word8)\\n\\ninstance Unboxed Word16\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 2\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = W16# (indexWord16Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWord16Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, W16# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (W16# e#) = writeWord16Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Word16)\\n\\ninstance Unboxed Word32\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 4\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = W32# (indexWord32Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWord32Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, W32# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (W32# e#) = writeWord32Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Word32)\\n\\ninstance Unboxed Word64\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 8\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = W64# (indexWord64Array# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWord64Array# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, W64# e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (W64# e#) = writeWord64Array# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Word64)\\n\\ninstance Unboxed Float\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSFLOAT\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = F# (indexFloatArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readFloatArray# mbytes# i# s1# of\\n (# s2#, f# #) -> (# s2#, F# f# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (F# e#) = writeFloatArray# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Float)\\n\\ninstance Unboxed Double\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSDOUBLE\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = D# (indexDoubleArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readDoubleArray# mbytes# i# s1# of\\n (# s2#, d# #) -> (# s2#, D# d# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (D# e#) = writeDoubleArray# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' (0 :: Double)\\n\\ninstance (Unboxed a, Integral a) => Unboxed (Ratio a)\\n where\\n sizeof e n = 2 * psizeof e n\\n \\n bytes# !# i# = bytes# !# i2# :% (bytes# !# (i2# +# 1#)) where i2# = 2# *# i#\\n \\n mbytes# !># i# = let i2# = 2# *# i# in \\\\ s1# -> case (!>#) mbytes# i2# s1# of\\n (# s2#, n #) -> case (!>#) mbytes# (i2# +# 1#) s2# of\\n (# s3#, d #) -> (# s3#, n :% d #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# i# (n :% d) = let i2# = 2# *# i# in\\n \\\\ s1# -> case writeByteArray# mbytes# i2# n s1# of\\n s2# -> writeByteArray# mbytes# (i2# +# 1#) d s2#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed e n# = pnewUnboxed e (2# *# n#)\\n\\ninstance (Unboxed a, Num a) => Unboxed (Complex a)\\n where\\n sizeof e n = 2 * psizeof e n\\n \\n bytes# !# i# = bytes# !# i2# :+ (bytes# !# (i2# +# 1#)) where i2# = 2# *# i#\\n mbytes# !># i# = let i2# = 2# *# i# in \\\\ s1# -> case (!>#) mbytes# i2# s1# of\\n (# s2#, n #) -> case (!>#) mbytes# (i2# +# 1#) s2# of\\n (# s3#, d #) -> (# s3#, n :+ d #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# i# (n :+ d) = let i2# = 2# *# i# in\\n \\\\ s1# -> case writeByteArray# mbytes# i2# n s1# of\\n s2# -> writeByteArray# mbytes# (i2# +# 1#) d s2#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed e n# = pnewUnboxed e (2# *# n#)\\n\\n--------------------------------------------------------------------------------\\n\\n{- Pointer instances. -}\\n\\ninstance Unboxed (Ptr a)\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSWORD\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = Ptr (indexAddrArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readAddrArray# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, Ptr e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (Ptr e) = writeAddrArray# mbytes# n# e\\n\\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' nullPtr\\n\\ninstance Unboxed (FunPtr a)\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSWORD\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = FunPtr (indexAddrArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readAddrArray# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, FunPtr e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (FunPtr e) = writeAddrArray# mbytes# n# e\\n\\n {-# INLINE newUnboxed #-}\\n newUnboxed e = newUnboxed' (NULL `asTypeOf` e)\\n\\ninstance Unboxed (StablePtr a)\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * SIZEOF_HSWORD\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = StablePtr (indexStablePtrArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readStablePtrArray# mbytes# i# s1# of\\n (# s2#, e# #) -> (# s2#, StablePtr e# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (StablePtr e) = writeStablePtrArray# mbytes# n# e\\n\\n {-# INLINE newUnboxed #-}\\n newUnboxed e = newUnboxed' (NULL `asTypeOf` e)\\n\\n--------------------------------------------------------------------------------\\n\\n{- Foreign C instances. -}\\n\\n#define deriving_instance_Unboxed(Type)\\\\\\ninstance Unboxed Type where\\\\\\n{\\\\\\n sizeof e = sizeof (consSizeof Type e);\\\\\\n arr# !# i# = Type ( arr# !# i# );\\\\\\n marr# !># i# = \\\\ s1# -> case (!>#) marr# i# s1# of {(# s2#, e #) -> (# s2#, Type e #)};\\\\\\n writeByteArray# marr# i# (Type e) = writeByteArray# marr# i# e;\\\\\\n fillByteArray# marr# i# (Type e) = fillByteArray# marr# i# e;\\\\\\n newUnboxed (Type e) = newUnboxed e;\\\\\\n newUnboxed' (Type e) = newUnboxed' e;\\\\\\n}\\n\\nderiving_instance_Unboxed(CChar)\\nderiving_instance_Unboxed(CSChar)\\nderiving_instance_Unboxed(CWchar)\\nderiving_instance_Unboxed(CShort)\\nderiving_instance_Unboxed(CUShort)\\n\\nderiving_instance_Unboxed(CInt)\\nderiving_instance_Unboxed(CUInt)\\nderiving_instance_Unboxed(CLong)\\nderiving_instance_Unboxed(CULong)\\nderiving_instance_Unboxed(CLLong)\\nderiving_instance_Unboxed(CULLong)\\nderiving_instance_Unboxed(CIntPtr)\\nderiving_instance_Unboxed(CUIntPtr)\\nderiving_instance_Unboxed(CIntMax)\\nderiving_instance_Unboxed(CUIntMax)\\nderiving_instance_Unboxed(CPtrdiff)\\n\\nderiving_instance_Unboxed(CTime)\\nderiving_instance_Unboxed(CClock)\\nderiving_instance_Unboxed(CUSeconds)\\nderiving_instance_Unboxed(CSUSeconds)\\n\\nderiving_instance_Unboxed(CSize)\\n\\n#if MIN_VERSION_base(4,10,0)\\n-- | @since base-4.10.0.0\\nderiving_instance_Unboxed(CBool)\\n#endif\\n\\nderiving_instance_Unboxed(CFloat)\\nderiving_instance_Unboxed(CDouble)\\nderiving_instance_Unboxed(CSigAtomic)\\n\\n#undef deriving_instance_Unboxed\\n\\n--------------------------------------------------------------------------------\\n\\n{- Other instances. -}\\n\\ninstance Unboxed Bool\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ c = d == 0 ? n $ n + 1 where (n, d) = max 0 c `divMod` 8\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = isTrue# ((indexWordArray# bytes# (bool_index i#) `and#` bool_bit i#) `neWord#` int2Word# 0#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWordArray# mbytes# (bool_index i#) s1# of\\n (# s2#, e# #) -> (# s2#, isTrue# ((e# `and#` bool_bit i#) `neWord#` int2Word# 0#) #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# e = \\\\ s1# -> case readWordArray# mbytes# i# s1# of\\n (# s2#, old_byte# #) -> writeWordArray# mbytes# i# (bitWrite old_byte#) s2#\\n where\\n bitWrite old_byte# = if e then old_byte# `or#` bool_bit n# else old_byte# `and#` bool_not_bit n#\\n i# = bool_index n#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed _ = newUnboxed' False\\n \\n fillByteArray# mbytes# n# e =\\n setByteArray# mbytes# 0# (bool_scale n#) (if e then 0xff# else 0#)\\n \\n copyUnboxed# e bytes# o1# mbytes# o2# c# = isTrue# (c# <# 1#) ? (\\\\ s1# -> s1#) $\\n \\\\ s1# -> case writeByteArray# mbytes# o2# ((bytes# !# o1#) `asTypeOf` e) s1# of\\n s2# -> copyUnboxed# e bytes# (o1# +# 1#) mbytes# (o2# +# 1#) (c# -# 1#) s2#\\n \\n copyUnboxedM# e src# o1# mbytes# o2# n# = \\\\ s1# -> case (!>#) src# o1# s1# of\\n (# s2#, x #) -> case writeByteArray# mbytes# o2# (x `asTypeOf` e) s2# of\\n s3# -> copyUnboxedM# e src# (o1# +# 1#) mbytes# (o2# +# 1#) (n# -# 1#) s3#\\n \\n hashUnboxedWith e len# off# bytes#\\n | isTrue# (len# <# 1#) = \\\\ salt# -> salt#\\n | isTrue# (off# <# 0#) = hashUnboxedWith e len# 0# bytes#\\n | isTrue# (bit_off# ==# 0#) = go0 byte_cnt# byte_off#\\n | True = goo byte_cnt# (byte_off# +# 1#) (indexWord8Array# bytes# byte_off#)\\n where\\n go0 0# _ salt# = salt#\\n go0 1# o# salt# = hash# salt# (indexWord8Array# bytes# o# `and#` mask#)\\n go0 n# o# salt# = go0 (n# -# 1#) (o# +# 1#) (salt# `hash#` indexWord8Array# bytes# o#)\\n \\n goo 0# _ _ salt# = salt#\\n goo 1# _ temp# salt# = hash# salt# (shiftRL# temp# bit_off# `and#` mask#)\\n goo n# o# temp# salt# = goo (n# -# 1#) (o# +# 1#) byte# (hash# salt# curr#)\\n where\\n curr# = shiftRL# temp# bit_off# `or#` shiftL# byte# (8# -# bit_off#)\\n byte# = indexWord8Array# bytes# o#\\n \\n hash# = \\\\ s# v# -> word2Int# (int2Word# (s# *# 16777619#) `xor#` v#)\\n mask# = int2Word# 0xff# `shiftRL#` bit_rest#\\n \\n !(I# byte_off#, I# bit_off#) = I# off# `divMod` 8\\n !(I# bit_len#) = I# len# `mod` 8\\n \\n bit_rest# = if isTrue# (bit_len# ==# 0#) then 0# else 8# -# bit_len#\\n byte_cnt# = sizeof# e len#\\n\\ninstance Unboxed Char\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ n = max 0 n * 4\\n \\n {-# INLINE (!#) #-}\\n bytes# !# i# = C# (indexWideCharArray# bytes# i#)\\n \\n {-# INLINE (!>#) #-}\\n mbytes# !># i# = \\\\ s1# -> case readWideCharArray# mbytes# i# s1# of\\n (# s2#, c# #) -> (# s2#, C# c# #)\\n \\n {-# INLINE writeByteArray# #-}\\n writeByteArray# mbytes# n# (C# e#) = writeWideCharArray# mbytes# n# e#\\n \\n {-# INLINE newUnboxed #-}\\n newUnboxed e n# = \\\\ s1# -> case newByteArray# (sizeof# e n#) s1# of\\n (# s2#, mbytes# #) -> case fillByteArray# mbytes# n# '\\\\0' s2# of\\n s3# -> (# s3#, mbytes# #)\\n\\ninstance Unboxed E\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ _ = 0\\n \\n {-# INLINE (!#) #-}\\n (!>#) = \\\\ _ _ s# -> (# s#, E #)\\n (!#) = \\\\ _ _ -> E\\n \\n newUnboxed _ _ = newByteArray# 0#\\n newUnboxed' _ _ = newByteArray# 0#\\n \\n writeByteArray# _ _ = \\\\ _ s# -> s#\\n fillByteArray# _ _ = \\\\ _ s# -> s#\\n\\ninstance (Unboxed e) => Unboxed (I1 e)\\n where\\n sizeof# = psizeof#\\n sizeof = psizeof\\n \\n bytes# !# i# = E :& (bytes# !# i#)\\n bytes# !># i# = \\\\ s1# -> case (!>#) bytes# i# s1# of\\n (# s2#, e #) -> (# s2#, E :& e #)\\n \\n writeByteArray# bytes# n# (E :& e) = writeByteArray# bytes# n# e\\n fillByteArray# bytes# n# (E :& e) = fillByteArray# bytes# n# e\\n \\n newUnboxed' = \\\\ (E :& i) -> newUnboxed i\\n newUnboxed = pnewUnboxed\\n\\ninstance (Enum e, Shape e, Bounded e, Unboxed e, Shape (e' :& e), Unboxed (e' :& e)) => Unboxed (e' :& e :& e)\\n where\\n sizeof# e n# = psizeof# e (rank# e *# n#)\\n sizeof e n = psizeof e (rank e * n)\\n \\n bytes# !# i# = go undefined\\n where\\n go t =\\n let r# = rank# t; o# = i#*#r# +# i#\\n in ((bytes# !# o#) `asTypeOf` t) :& (bytes# !# (o# +# r#))\\n \\n bytes# !># i# = go undefined\\n where\\n go t = let r# = rank# t; o# = i#*#r# +# i# in\\n \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, es #) -> case (!>#) bytes# (o# +# r#) s2# of\\n (# s3#, e #) -> (# s3#, (es `asTypeOf` t) :& e #)\\n \\n writeByteArray# bytes# i# (es :& e) = let r# = rank# es; o# = i#*#r# +# i# in\\n \\\\ s1# -> case writeByteArray# bytes# o# es s1# of\\n s2# -> writeByteArray# bytes# (o# +# r#) e s2#\\n \\n newUnboxed e n# = pnewUnboxed e (rank# e *# n#)\\n\\n--------------------------------------------------------------------------------\\n\\n{- Tuple instances. -}\\n\\ninstance Unboxed ()\\n where\\n {-# INLINE sizeof #-}\\n sizeof _ _ = 0\\n \\n {-# INLINE (!#) #-}\\n (!>#) = \\\\ _ _ s# -> (# s#, () #)\\n (!#) = \\\\ _ _ -> ()\\n \\n newUnboxed _ _ = newByteArray# 0#\\n newUnboxed' _ _ = newByteArray# 0#\\n \\n writeByteArray# _ _ = \\\\ _ s# -> s#\\n fillByteArray# _ _ = \\\\ _ s# -> s#\\n\\ninstance (Unboxed e) => Unboxed (T2 e)\\n where\\n sizeof e2 n = psizeof e2 (2 * n)\\n sizeof# e2 n# = psizeof# e2 (2# *# n#)\\n \\n bytes# !# n# = let o# = 2# *# n# in (bytes# !# o#, bytes# !# (o#+#1#))\\n bytes# !># n# = let o# = 2# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> (# s3#, (e1,e2) #)\\n \\n writeByteArray# mbytes# n# (e1,e2) = let o# = 2# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> writeByteArray# mbytes# (o# +# 1#) e2 s2#\\n \\n newUnboxed e n# = pnewUnboxed e (2# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T3 e)\\n where\\n sizeof e2 n = psizeof e2 (3 * n)\\n sizeof# e2 n# = psizeof# e2 (3# *# n#)\\n \\n bytes# !# n# =\\n let o# = 3# *# n#\\n in (bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#))\\n \\n bytes# !># n# = let o# = 3# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> (# s4#, (e1,e2,e3) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3) = let o# = 3# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> writeByteArray# mbytes# (o# +# 2#) e3 s3#\\n \\n newUnboxed e n# = pnewUnboxed e (3# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T4 e)\\n where\\n sizeof e2 n = psizeof e2 (4 * n)\\n sizeof# e2 n# = psizeof# e2 (4# *# n#)\\n \\n bytes# !# n# =\\n let o# = 4# *# n#\\n in (bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#), bytes# !# (o#+#3#))\\n \\n bytes# !># n# = let o# = 4# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> (# s5#, (e1,e2,e3,e4) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4) = let o# = 4# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> writeByteArray# mbytes# (o# +# 3#) e4 s4#\\n \\n newUnboxed e n# = pnewUnboxed e (4# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T5 e)\\n where\\n sizeof e2 n = psizeof e2 (5 * n)\\n sizeof# e2 n# = psizeof# e2 (5# *# n#)\\n \\n bytes# !# n# =\\n let o# = 5# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#)\\n )\\n \\n bytes# !># n# = let o# = 5# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> (# s6#, (e1,e2,e3,e4,e5) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5) = let o# = 5# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> writeByteArray# mbytes# (o# +# 4#) e5 s5#\\n \\n newUnboxed e n# = pnewUnboxed e (5# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T6 e)\\n where\\n sizeof e2 n = psizeof e2 (6 * n)\\n sizeof# e2 n# = psizeof# e2 (6# *# n#)\\n \\n bytes# !# n# =\\n let o# = 6# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#)\\n )\\n \\n bytes# !># n# = let o# = 6# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> (# s7#, (e1,e2,e3,e4,e5,e6) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6) = let o# = 6# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> writeByteArray# mbytes# (o# +# 5#) e6 s6#\\n \\n newUnboxed e n# = pnewUnboxed e (6# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T7 e)\\n where\\n sizeof e2 n = psizeof e2 (7 * n)\\n sizeof# e2 n# = psizeof# e2 (7# *# n#)\\n \\n bytes# !# n# =\\n let o# = 7# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#)\\n )\\n \\n bytes# !># n# = let o# = 7# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> (# s8#, (e1,e2,e3,e4,e5,e6,e7) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7) = let o# = 7# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> writeByteArray# mbytes# (o# +# 6#) e7 s7#\\n \\n newUnboxed e n# = pnewUnboxed e (7# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T8 e)\\n where\\n sizeof e2 n = psizeof e2 (8 * n)\\n sizeof# e2 n# = psizeof# e2 (8# *# n#)\\n \\n bytes# !# n# =\\n let o# = 8# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#)\\n )\\n \\n bytes# !># n# = let o# = 8# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> (# s9#, (e1,e2,e3,e4,e5,e6,e7,e8) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8) = let o# = 8# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> writeByteArray# mbytes# (o# +# 7#) e8 s8#\\n \\n newUnboxed e n# = pnewUnboxed e (8# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T9 e)\\n where\\n sizeof e2 n = psizeof e2 (9 * n)\\n sizeof# e2 n# = psizeof# e2 (9# *# n#)\\n \\n bytes# !# n# =\\n let o# = 9# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#)\\n )\\n \\n bytes# !># n# = let o# = 9# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> (# s10#, (e1,e2,e3,e4,e5,e6,e7,e8,e9) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9) = let o# = 9# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> writeByteArray# mbytes# (o# +# 8#) e9 s9#\\n \\n newUnboxed e n# = pnewUnboxed e (9# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T10 e)\\n where\\n sizeof e2 n = psizeof e2 (10 * n)\\n sizeof# e2 n# = psizeof# e2 (10# *# n#)\\n \\n bytes# !# n# =\\n let o# = 10# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#)\\n )\\n \\n bytes# !># n# = let o# = 10# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> (# s11#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10) = let o# = 10# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> writeByteArray# mbytes# (o# +# 9#) e10 s10#\\n \\n newUnboxed e n# = pnewUnboxed e (10# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T11 e)\\n where\\n sizeof e2 n = psizeof e2 (11 * n)\\n sizeof# e2 n# = psizeof# e2 (11# *# n#)\\n \\n bytes# !# n# =\\n let o# = 11# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#), bytes# !# (o#+#10#)\\n )\\n \\n bytes# !># n# = let o# = 11# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\\n (# s12#, e11 #) -> (# s12#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11) = let o# = 11# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\\n s11# -> writeByteArray# mbytes# (o# +# 10#) e11 s11#\\n \\n newUnboxed e n# = pnewUnboxed e (11# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T12 e)\\n where\\n sizeof e2 n = psizeof e2 (12 * n)\\n sizeof# e2 n# = psizeof# e2 (12# *# n#)\\n \\n bytes# !# n# =\\n let o# = 12# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#)\\n )\\n \\n bytes# !># n# = let o# = 12# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\\n (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\\n (# s13#, e12 #) -> (# s13#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12) = let o# = 12# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\\n s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\\n s12# -> writeByteArray# mbytes# (o# +# 11#) e12 s12#\\n \\n newUnboxed e n# = pnewUnboxed e (12# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T13 e)\\n where\\n sizeof e2 n = psizeof e2 (13 * n)\\n sizeof# e2 n# = psizeof# e2 (13# *# n#)\\n \\n bytes# !# n# =\\n let o# = 13# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\\n bytes# !# (o#+#12#)\\n )\\n \\n bytes# !># n# = let o# = 13# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\\n (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\\n (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\\n (# s14#, e13 #) -> (# s14#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13) = let o# = 13# *# n# in\\n \\\\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\\n s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\\n s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\\n s13# -> writeByteArray# mbytes# (o# +# 12#) e13 s13#\\n \\n newUnboxed e n# = pnewUnboxed e (13# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T14 e)\\n where\\n sizeof e2 n = psizeof e2 (14 * n)\\n sizeof# e2 n# = psizeof# e2 (14# *# n#)\\n \\n bytes# !# n# =\\n let o# = 14# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\\n bytes# !# (o#+#12#), bytes# !# (o#+#13#)\\n )\\n \\n bytes# !># n# = let o# = 14# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\\n (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\\n (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\\n (# s14#, e13 #) -> case (!>#) bytes# (o# +# 13#) s14# of\\n (# s15#, e14 #) -> (# s15#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14) =\\n \\\\ s1# -> let o# = 14# *# n# in case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\\n s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\\n s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\\n s13# -> case writeByteArray# mbytes# (o# +# 12#) e13 s13# of\\n s14# -> writeByteArray# mbytes# (o# +# 13#) e14 s14#\\n \\n newUnboxed e n# = pnewUnboxed e (14# *# n#)\\n\\ninstance (Unboxed e) => Unboxed (T15 e)\\n where\\n sizeof e2 n = psizeof e2 (15 * n)\\n sizeof# e2 n# = psizeof# e2 (15# *# n#)\\n \\n bytes# !# n# =\\n let o# = 15# *# n#\\n in\\n (\\n bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\\n bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\\n bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\\n bytes# !# (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\\n bytes# !# (o#+#12#), bytes# !# (o#+#13#), bytes# !# (o#+#14#)\\n )\\n \\n bytes# !># n# = let o# = 15# *# n# in \\\\ s1# -> case (!>#) bytes# o# s1# of\\n (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\\n (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\\n (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\\n (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\\n (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\\n (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\\n (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\\n (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\\n (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\\n (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\\n (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\\n (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\\n (# s14#, e13 #) -> case (!>#) bytes# (o# +# 13#) s14# of\\n (# s15#, e14 #) -> case (!>#) bytes# (o# +# 14#) s15# of\\n (# s16#, e15 #) -> (# s16#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15) #)\\n \\n writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15) =\\n \\\\ s1# -> let o# = 15# *# n# in case writeByteArray# mbytes# o# e1 s1# of\\n s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\\n s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\\n s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\\n s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\\n s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\\n s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\\n s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\\n s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\\n s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\\n s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\\n s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\\n s13# -> case writeByteArray# mbytes# (o# +# 12#) e13 s13# of\\n s14# -> case writeByteArray# mbytes# (o# +# 13#) e14 s14# of\\n s15# -> writeByteArray# mbytes# (o# +# 14#) e15 s15#\\n \\n newUnboxed e n# = pnewUnboxed e (15# *# n#)\\n\\n--------------------------------------------------------------------------------\\n\\n-- | 'ByteArray#' wrapper.\\ndata Wrap = Wrap {unwrap :: ByteArray#}\\n\\n{- |\\n @since 0.2.1\\n Wrapped empty 'ByteArray#'.\\n-}\\nlzero# :: Wrap\\nlzero# = runST $ ST $ \\\\ s1# -> case newByteArray# 0# s1# of\\n (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\\n (# s3#, arr# #) -> (# s3#, Wrap arr# #)\\n\\n{- |\\n @since 0.2.1\\n 'ByteArray#' singleton.\\n-}\\nsingle# :: (Unboxed e) => e -> ByteArray#\\nsingle# e = unwrap $ runST $ ST $ \\\\ s1# -> case newUnboxed' e 1# s1# of\\n (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\\n (# s3#, arr# #) -> (# s3#, Wrap arr# #)\\n\\n{- |\\n @since 0.2.1\\n Create immutable 'Unboxed' array from given list.\\n-}\\nfromList# :: (Unboxed e) => [e] -> ByteArray#\\nfromList# es = let !(I# n#) = length es in fromListN# n# es\\n\\n{- |\\n @since 0.2.1\\n Create immutable 'Unboxed' array from 'Foldable' stream.\\n-}\\nfromFoldable# :: (Foldable f, Unboxed e) => f e -> (# Int, ByteArray# #)\\nfromFoldable# es = unpack' $ runST $ ST $ \\\\ s1# -> case fromFoldableM# es s1# of\\n (# s2#, n, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\\n (# s3#, arr# #) -> (# s3#, (n, Wrap arr#) #)\\n where\\n unpack' (i, Wrap arr#) = (# i, arr# #)\\n\\n{- |\\n @since 0.2.1\\n Create immutable 'Unboxed' array from known size list.\\n-}\\nfromListN# :: (Unboxed e) => Int# -> [e] -> ByteArray#\\nfromListN# n# es = unwrap $ runST $ ST $ \\\\ s1# -> case newLinearN# n# es s1# of\\n (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\\n (# s3#, arr# #) -> (# s3#, Wrap arr# #)\\n\\n{- |\\n @since 0.2.1\\n Create mutable 'Unboxed' array from given list.\\n-}\\nnewLinear# :: (Unboxed e) => [e] -> State# s ->\\n (# State# s, MutableByteArray# s #)\\nnewLinear# es = let !(I# n#) = length es in newLinearN# n# es\\n\\n{- |\\n @since 0.2.1\\n Create mutable 'Unboxed' array from known size list.\\n-}\\nnewLinearN# :: (Unboxed e) => Int# -> [e] -> State# s ->\\n (# State# s, MutableByteArray# s #)\\nnewLinearN# c# es = \\\\ s1# -> case pnewUnboxed es n# s1# of\\n (# s2#, marr# #) ->\\n let\\n go y r = \\\\ i# s4# -> case writeByteArray# marr# i# y s4# of\\n s5# -> if isTrue# (i# ==# n# -# 1#) then s5# else r (i# +# 1#) s5#\\n in case if n == 0 then s2# else foldr go (\\\\ _ s# -> s#) es 0# s2# of\\n s3# -> (# s3#, marr# #)\\n where\\n !n@(I# n#) = max 0 (I# c#)\\n\\n{- |\\n @since 0.2.1\\n Create mutable 'Unboxed' array from 'Foldable' stream.\\n-}\\nfromFoldableM# :: (Foldable f, Unboxed e) => f e -> State# s ->\\n (# State# s, Int, MutableByteArray# s #)\\nfromFoldableM# es = \\\\ s1# -> case pnewUnboxed es n# s1# of\\n (# s2#, marr# #) ->\\n let\\n go y r = \\\\ i# s4# -> case writeByteArray# marr# i# y s4# of\\n s5# -> if isTrue# (i# ==# n# -# 1#) then s5# else r (i# +# 1#) s5#\\n in case if n == 0 then s2# else foldr go (\\\\ _ s# -> s#) es 0# s2# of\\n s3# -> (# s3#, n, marr# #)\\n where\\n !n@(I# n#) = length es\\n\\n{- |\\n @since 0.2.1\\n Concatenation of two 'Unboxed' arrays.\\n-}\\nconcat# :: (Unboxed e) => e ->\\n ByteArray# -> Int# -> Int# ->\\n ByteArray# -> Int# -> Int# -> State# s ->\\n (# State# s, Int#, MutableByteArray# s #)\\nconcat# e arr1# n1# o1# arr2# n2# o2# = \\\\ s1# -> case newUnboxed e n# s1# of\\n (# s2#, marr# #) -> case copyUnboxed# e arr1# o1# marr# 0# n1# s2# of\\n s3# -> case copyUnboxed# e arr2# o2# marr# n1# n2# s3# of\\n s4# -> (# s4#, n#, marr# #)\\n where\\n n# = n1# +# n2#\\n\\n-- | Proxy concatenation of two byte arrays representing 'Unboxed' structures.\\npconcat :: (Unboxed e) => proxy e ->\\n ByteArray# -> Int# -> Int# -> ByteArray# -> Int# -> Int# ->\\n State# s -> (# State# s, Int#, MutableByteArray# s #)\\npconcat = concat# . fromProxy\\n\\n--------------------------------------------------------------------------------\\n\\nrank# :: (Shape i) => i -> Int#\\nrank# i = case rank i of I# r# -> r#\\n\\n{-# INLINE bool_scale #-}\\nbool_scale :: Int# -> Int#\\nbool_scale n# = (n# +# 7#) `uncheckedIShiftRA#` 3#\\n\\n{-# INLINE bool_bit #-}\\nbool_bit :: Int# -> Word#\\nbool_bit n# = case (SIZEOF_HSWORD * 8 - 1) of\\n W# mask# -> int2Word# 1# `uncheckedShiftL#` word2Int# (int2Word# n# `and#` mask#)\\n\\n{-# INLINE bool_not_bit #-}\\nbool_not_bit :: Int# -> Word#\\nbool_not_bit n# = case maxBound of W# mb# -> bool_bit n# `xor#` mb#\\n\\n{-# INLINE bool_index #-}\\nbool_index :: Int# -> Int#\\n#if SIZEOF_HSWORD == 4\\nbool_index = (`uncheckedIShiftRA#` 5#)\\n#elif SIZEOF_HSWORD == 8\\nbool_index = (`uncheckedIShiftRA#` 6#)\\n#endif\\n\\nconsSizeof :: (a -> b) -> b -> a\\nconsSizeof = \\\\ _ _ -> undefined\\n\\n\\n\"} {\"text\": \"[STATEMENT]\\nlemma prod_mset_multiset_prime_factorization_nat [simp]: \\n \\\"(x::nat) \\\\<noteq> 0 \\\\<Longrightarrow> prod_mset (prime_factorization x) = x\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. x \\\\<noteq> 0 \\\\<Longrightarrow> \\\\<Prod>\\\\<^sub># (prime_factorization x) = x\\n[PROOF STEP]\\nby simp\"} {\"text\": \"-- a^7 = b^7 syss a = b\\n-- ====================\\n\\nimport tactic\\nimport algebra.order.ring\\n\\ntheorem ex_1_3_5\\n {\\u03b1}\\n [linear_ordered_ring \\u03b1]\\n (a b : \\u03b1)\\n (h : a^7 = b^7)\\n : a = b :=\\n(@strict_mono_pow_bit1 \\u03b1 _ 3).injective h\\n\\n-- Referencia\\n-- ==========\\n\\n-- Mario Carneiro \\\"if a^7=b^7 then a=b\\\" https://bit.ly/3oyBS6M\\n\"} {\"text\": \"import tactic\\n/--------------------------------------------------------------------------\\n\\nRecall that for any ``P : Prop``, you can use ``false.elim : false \\u2192 P``\\n to prove ``P`` from a contradiction.\\n\\nDelete the ``sorry,`` below and replace them with a legitimate proof.\\n\\n--------------------------------------------------------------------------/\\n\\nexample (P Q R : Prop) : P \\u2227 false \\u2194 false :=\\nbegin\\n sorry,\\nend\\n\\ntheorem principle_of_explosion (P Q : Prop) : P \\u2227 \\u00ac P \\u2192 Q :=\\nbegin\\n sorry,\\nend\"} {\"text\": \"lemmas linear_imp_scaleR = linear_imp_scale\"} {\"text\": \"module ModuleArityMismatch where\\n\\n module M (A : Set) where\\n\\n postulate\\n A : Set\\n\\n module M\\u2032 = M A A\\n\"} {\"text\": \"classdef(Abstract) AbstractGeometricVectorConstraint < AbstractConstraint\\n %AbstractGeometricVectorConstraint Summary of this class goes here\\n % Detailed explanation goes here\\n\\n properties\\n normFact = 1;\\n vector AbstractGeometricVector\\n event LaunchVehicleEvent\\n eventNode(1,1) ConstraintStateComparisonNodeEnum = ConstraintStateComparisonNodeEnum.FinalState;\\n \\n lb(1,1) double = 0;\\n ub(1,1) double = 0;\\n\\n type(1,:) char\\n \\n evalType(1,1) ConstraintEvalTypeEnum = ConstraintEvalTypeEnum.FixedBounds;\\n stateCompType(1,1) ConstraintStateComparisonTypeEnum = ConstraintStateComparisonTypeEnum.Equals;\\n stateCompEvent LaunchVehicleEvent\\n stateCompNode(1,1) ConstraintStateComparisonNodeEnum = ConstraintStateComparisonNodeEnum.FinalState;\\n end\\n\\n methods\\n function [lb, ub] = getBounds(obj)\\n lb = obj.lb;\\n ub = obj.ub;\\n end\\n \\n function [c, ceq, value, lwrBnd, uprBnd, type, eventNum, valueStateComp] = evalConstraint(obj, stateLog, celBodyData) \\n type = obj.getConstraintType();\\n \\n switch obj.eventNode\\n case ConstraintStateComparisonNodeEnum.FinalState\\n stateLogEntry = stateLog.getLastStateLogForEvent(obj.event);\\n \\n case ConstraintStateComparisonNodeEnum.InitialState\\n stateLogEntry = stateLog.getFirstStateLogForEvent(obj.event);\\n \\n otherwise\\n error('Unknown event node.');\\n end\\n\\n if(not(isempty(obj.frame)))\\n frame = obj.frame;\\n else\\n frame = stateLogEntry.centralBody.getBodyCenteredInertialFrame();\\n end\\n \\n value = lvd_GeometricVectorTasks(stateLogEntry, obj.type, obj.vector, frame);\\n \\n if(obj.evalType == ConstraintEvalTypeEnum.StateComparison)\\n switch obj.stateCompNode\\n case ConstraintStateComparisonNodeEnum.FinalState\\n stateLogEntryStateComp = stateLog.getLastStateLogForEvent(obj.stateCompEvent);\\n\\n case ConstraintStateComparisonNodeEnum.InitialState\\n stateLogEntryStateComp = stateLog.getFirstStateLogForEvent(obj.stateCompEvent);\\n\\n otherwise\\n error('Unknown event node.');\\n end\\n\\n valueStateComp = lvd_GeometricVectorTasks(stateLogEntryStateComp, obj.type, obj.vector, frame);\\n else\\n valueStateComp = NaN;\\n end\\n \\n [c, ceq] = obj.computeCAndCeqValues(value, valueStateComp); \\n \\n lwrBnd = obj.lb;\\n uprBnd = obj.ub;\\n \\n eventNum = obj.event.getEventNum();\\n end\\n \\n function sF = getScaleFactor(obj)\\n sF = obj.normFact;\\n end\\n \\n function setScaleFactor(obj, sF)\\n obj.normFact = sF;\\n end\\n \\n function tf = usesStage(obj, stage)\\n tf = false;\\n end\\n \\n function tf = usesEngine(obj, engine)\\n tf = false;\\n end\\n \\n function tf = usesTank(obj, tank)\\n tf = false;\\n end\\n \\n function tf = usesEngineToTankConn(obj, engineToTank)\\n tf = false;\\n end\\n \\n function tf = usesEvent(obj, event)\\n tf = obj.event == event;\\n if(obj.evalType == ConstraintEvalTypeEnum.StateComparison)\\n tf = tf || obj.stateCompEvent == event;\\n end\\n end\\n \\n function tf = usesStopwatch(~, ~)\\n tf = false;\\n end\\n \\n function tf = usesExtremum(~, ~)\\n tf = false;\\n end\\n \\n function tf = usesGroundObj(~, ~)\\n tf = false;\\n end\\n \\n function tf = usesGeometricVector(obj, vector)\\n tf = obj.vector == vector;\\n end\\n \\n function tf = canUseSparseOutput(obj)\\n tf = true;\\n end\\n \\n function event = getConstraintEvent(obj)\\n event = obj.event;\\n end\\n \\n function [unit, lbLim, ubLim, usesLbUb, usesCelBody, usesRefSc] = getConstraintStaticDetails(obj)\\n unit = '';\\n lbLim = 0;\\n ubLim = Inf;\\n usesLbUb = true;\\n usesCelBody = false;\\n usesRefSc = false;\\n end\\n \\n function addConstraintTf = openEditConstraintUI(obj, lvdData)\\n if(lvdData.geometry.vectors.getNumVectors() >= 1)\\n% addConstraintTf = lvd_EditGeometricVectorConstraintGUI(obj, lvdData);\\n\\n output = AppDesignerGUIOutput({false});\\n lvd_EditGeometricVectorConstraintGUI_App(obj, lvdData, output);\\n addConstraintTf = output.output{1};\\n else\\n errordlg('There are currently no geometric vectors in this scenario. Add at least one new vector first.');\\n \\n addConstraintTf = false;\\n end\\n end\\n \\n function vector = selectConstraintObj(obj, lvdData)\\n [listBoxStr, vectors] = lvdData.geometry.vectors.getListboxStr();\\n\\n vector = [];\\n if(isempty(vectors)) \\n warndlg('Cannot create vector value object: no vectors have been created. Create a vector first.','Vector Value Constraint','modal');\\n else\\n [Selection,ok] = listdlg('PromptString',{'Select a vector:'},...\\n 'SelectionMode','single',...\\n 'Name','Vectors',...\\n 'ListString',listBoxStr);\\n \\n if(ok == 0)\\n vector = [];\\n else\\n vector = vectors(Selection);\\n end\\n end\\n end\\n \\n function useObjFcn = setupForUseAsObjectiveFcn(obj,lvdData)\\n vectorSel = obj.selectConstraintObj(lvdData);\\n \\n if(not(isempty(vectorSel)))\\n obj.vector = vectorSel;\\n useObjFcn = true;\\n else\\n useObjFcn = false;\\n end\\n end\\n end\\nend\"} {\"text\": \"/-\\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro\\n-/\\nimport Mathlib.Tactic.Alias\\nimport Mathlib.Tactic.IrreducibleDef\\nimport Mathlib.Mathport.Rename\\nimport Mathlib.Init.Logic\\n\\n/-! ### alignments from lean 3 `init.classical` -/\\n\\nnamespace Classical\\n\\n#align classical.inhabited_of_nonempty Classical.inhabited_of_nonempty\\n#align classical.inhabited_of_exists Classical.inhabited_of_exists\\n\\nattribute [local instance] propDecidable\\nattribute [local instance] decidableInhabited\\n\\nalias axiomOfChoice \\u2190 axiom_of_choice -- TODO: fix in core\\nalias propComplete \\u2190 prop_complete -- TODO: fix in core\\n\\n@[elab_as_elim] theorem cases_true_false (p : Prop \\u2192 Prop)\\n (h1 : p True) (h2 : p False) (a : Prop) : p a :=\\n Or.elim (prop_complete a) (fun ht : a = True \\u21a6 ht.symm \\u25b8 h1) fun hf : a = False \\u21a6 hf.symm \\u25b8 h2\\n\\ntheorem cases_on (a : Prop) {p : Prop \\u2192 Prop} (h1 : p True) (h2 : p False) : p a :=\\n @cases_true_false p h1 h2 a\\n\\ntheorem cases {p : Prop \\u2192 Prop} (h1 : p True) (h2 : p False) (a) : p a := cases_on a h1 h2\\n#align classical.cases Classical.cases\\n\\nalias byCases \\u2190 by_cases\\nalias byContradiction \\u2190 by_contradiction\\n\\ntheorem eq_false_or_eq_true (a : Prop) : a = False \\u2228 a = True := (prop_complete a).symm\\n\\nend Classical\\n\"} {\"text\": \"# Copyright \\u00a9 2021, UChicago Argonne, LLC\\n# All Rights Reserved.\\n\\n# This source code is licensed under the BSD-style license found in the\\n# LICENSE file in the root directory of this source tree. \\n\\nusing DataFrames, DataStructures, InteractiveUtils, Logging, Printf\\nimport CSV, DelimitedFiles, SCIP, Statistics, Glob\\nusing JuMP, MathOptInterface\\nconst MOI = MathOptInterface\"} {\"text\": \"variables (a b c d e : \\u2115)\\nvariable h1 : a = b\\nvariable h2 : b = c + 1\\nvariable h3 : c = d\\nvariable h4 : e = 1 + d\\n\\ninclude h1 h2 h3 h4\\ntheorem T : a = e :=\\n calc\\n a = b : by rw h1\\n ... = c + 1 : by rw h2\\n ... = d + 1 : by rw h3\\n ... = 1 + d : by rw add_comm\\n ... = e : by rw h4\\n\"} {\"text\": \"import data.real.irrational\\nimport topology.basic\\nimport algebra.order.floor\\n\\n\\n--OUTPUT 1\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nbegin\\n -- Let $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n have h1 : \\u2200 (i j : \\u2124), i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from\\n assume (i j : \\u2124) (h : i \\u2260 j),\\n have h2 : \\u03b1 \\u2260 (int.fract (\\u03b1 * \\u2191i) - int.fract (\\u03b1 * \\u2191j)) / (i - j), from by {\\n assume h3 : \\u03b1 = (int.fract (\\u03b1 * \\u2191i) - int.fract (\\u03b1 * \\u2191j)) / (i - j),\\n have h4 : \\u03b1 * \\u2191i = \\u2191(int.nat_abs (\\u03b1 * \\u2191i)) + int.fract (\\u03b1 * \\u2191i), from by {\\n rw int.fract_eq_of_nat_abs_lt_one,\\n have h5 : 0 < \\u03b1 * \\u2191i, from by {\\n apply mul_pos,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_pos,\\n },\\n exact lt_of_le_of_lt (int.nat_abs_nonneg (\\u03b1 * \\u2191i)) h5,\\n },\\n have h6 : \\u03b1 * \\u2191j = \\u2191(int.nat_abs (\\u03b1 * \\u2191j)) + int.fract (\\u03b1 * \\u2191j), from by {\\n rw int.fract_eq_of_nat_abs_lt_one,\\n have h7 : 0 < \\u03b1 * \\u2191j, from by {\\n apply mul_pos,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_pos,\\n },\\n exact lt_of_le_of_lt (int.nat_abs_nonneg (\\u03b1 * \\u2191j)) h7,\\n },\\n have h8 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (int.nat_abs (\\u03b1 * \\u2191i) - int.nat_abs (\\u03b1 * \\u2191j)) + (int.fract (\\u03b1 * \\u2191i) - int.fract (\\u03b1 * \\u2191j)), from by {\\n rw [h4,h6],\\n ring,\\n },\\n have h9 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (i - j) * \\u03b1, from by {\\n rw [\\u2190 mul_sub,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n },\\n have h10 : (int.nat_abs (\\u03b1 * \\u2191i) - int.nat_abs (\\u03b1 * \\u2191j)) = 0, from by {\\n rw [\\u2190 int.coe_nat_eq_coe_nat_iff,\\u2190 int.coe_nat_eq_coe_nat_iff],\\n rw [\\u2190 int.nat_abs_of_nonneg,\\u2190 int.nat_abs_of_nonneg],\\n have h11 : 0 \\u2264 \\u03b1 * \\u2191i, from by {\\n apply mul_nonneg,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_nonneg,\\n },\\n have h12 : 0 \\u2264 \\u03b1 * \\u2191j, from by {\\n apply mul_nonneg,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_nonneg,\\n },\\n have h13 : 0 \\u2264 i, from by {\\n apply int.coe_nat_nonneg,\\n },\\n have h14 : 0 \\u2264 j, from by {\\n apply int.coe_nat_nonneg,\\n },\\n have h15 : 0 \\u2264 (i - j), from by {\\n apply sub_nonneg,\\n exact h13,\\n exact h14,\\n },\\n have h16 : 0 \\u2264 (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j), from by {\\n apply sub_nonneg,\\n exact h11,\\n exact h12,\\n },\\n have h17 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (i - j) * \\u03b1, from by {\\n rw [\\u2190 mul_sub,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n },\\n have h18 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (i - j) * \\u03b1, from by {\\n rw [\\u2190 mul_sub,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n },\\n have h19 : (i - j) * \\u03b1 = 0, from by {\\n rw [\\u2190 h17,\\u2190 h18],\\n rw [\\u2190 int.coe_nat_eq_coe_nat_iff,\\u2190 int.coe_nat_eq_coe_nat_iff],\\n rw [\\u2190 int.nat_abs_of_nonneg,\\u2190 int.nat_abs_of_nonneg],\\n exact h16,\\n exact h15,\\n },\\n have h20 : (i - j) = 0, from by {\\n rw [\\u2190 mul_eq_zero,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n exact h19,\\n exact irrational.irrat_pos h\\u03b1_irrat,\\n },\\n have h21 : i = j, from by {\\n rw [\\u2190 sub_eq_zero,\\u2190 h20],\\n },\\n exact h21,\\n },\\n have h22 : (int.fract (\\u03b1 * \\u2191i) - int.fract (\\u03b1 * \\u2191j)) = 0, from by {\\n rw [\\u2190 int.coe_nat_eq_coe_nat_iff,\\u2190 int.coe_nat_eq_coe_nat_iff],\\n rw [\\u2190 int.nat_abs_of_nonneg,\\u2190 int.nat_abs_of_nonneg],\\n have h23 : 0 \\u2264 \\u03b1 * \\u2191i, from by {\\n apply mul_nonneg,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_nonneg,\\n },\\n have h24 : 0 \\u2264 \\u03b1 * \\u2191j, from by {\\n apply mul_nonneg,\\n apply irrational.irrat_pos,\\n exact h\\u03b1_irrat,\\n apply int.coe_nat_nonneg,\\n },\\n have h25 : 0 \\u2264 (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j), from by {\\n apply sub_nonneg,\\n exact h23,\\n exact h24,\\n },\\n have h26 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (i - j) * \\u03b1, from by {\\n rw [\\u2190 mul_sub,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n },\\n have h27 : (\\u03b1 * \\u2191i - \\u03b1 * \\u2191j) = (i - j) * \\u03b1, from by {\\n rw [\\u2190 mul_sub,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n },\\n have h28 : (i - j) * \\u03b1 = 0, from by {\\n rw [\\u2190 h26,\\u2190 h27],\\n rw [\\u2190 int.coe_nat_eq_coe_nat_iff,\\u2190 int.coe_nat_eq_coe_nat_iff],\\n rw [\\u2190 int.nat_abs_of_nonneg,\\u2190 int.nat_abs_of_nonneg],\\n exact h25,\\n exact h10,\\n },\\n have h29 : (i - j) = 0, from by {\\n rw [\\u2190 mul_eq_zero,mul_comm,mul_comm \\u2191i \\u03b1,mul_comm \\u2191j \\u03b1],\\n exact h28,\\n exact irrational.irrat_pos h\\u03b1_irrat,\\n },\\n have h30 : i = j, from by {\\n rw [\\u2190 sub_eq_zero,\\u2190 h29],\\n },\\n exact h30,\\n },\\n have h31 :\\nend --Needs more than 2000 tokens!\\n\\n--OUTPUT 2\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nbegin\\n --Let $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$.\\n have h1 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n assume h2 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h3 : \\u03b1 * \\u2191i - \\u2191(int.floor (\\u03b1 * \\u2191i)) = int.fract (\\u03b1 * \\u2191i), from by {rw \\u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191i)))),},\\n have h4 : \\u03b1 * \\u2191j - \\u2191(int.floor (\\u03b1 * \\u2191j)) = int.fract (\\u03b1 * \\u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191j)))),},\\n have h5 : \\u03b1 = (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j), from by {rw [h3,h4], ring,},\\n have h6 : (i - j) \\u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\\n have h7 : (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j) \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n have h8 : \\u03b1 \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n exact h\\u03b1_irrat h8,\\n },\\n\\n --If this were not true, then\\n --$$\\n --i \\\\alpha-\\\\lfloor i \\\\alpha\\\\rfloor=\\\\{i \\\\alpha\\\\}=\\\\{j \\\\alpha\\\\}=j \\\\alpha-\\\\lfloor j \\\\alpha\\\\rfloor,\\n --$$\\n --which yields the false statement $\\\\alpha=\\\\frac{\\\\lfloor i \\\\alpha\\\\rfloor-\\\\lfloor j \\\\alpha\\\\rfloor}{i-j} \\\\in \\\\mathbb{Q}$.\\n --Hence,\\n --$$\\n --S:=\\\\{\\\\{i \\\\alpha\\\\} \\\\mid i \\\\in \\\\mathbb{Z}\\\\}\\n --$$\\n --is an infinite subset of $\\\\left[0,1\\\\right]$.\\n have h2 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n assume h2 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h3 : \\u03b1 * \\u2191i - \\u2191(int.floor (\\u03b1 * \\u2191i)) = int.fract (\\u03b1 * \\u2191i), from by {rw \\u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191i)))),},\\n have h4 : \\u03b1 * \\u2191j - \\u2191(int.floor (\\u03b1 * \\u2191j)) = int.fract (\\u03b1 * \\u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191j)))),},\\n have h5 : \\u03b1 = (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j), from by {rw [h3,h4], ring,},\\n have h6 : (i - j) \\u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\\n have h7 : (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j) \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n have h8 : \\u03b1 \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n exact h\\u03b1_irrat h8,\\n },\\n have h3 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n assume h2 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h3 : \\u03b1 * \\u2191i - \\u2191(int.floor (\\u03b1 * \\u2191i)) = int.fract (\\u03b1 * \\u2191i), from by {rw \\u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191i)))),},\\n have h4 : \\u03b1 * \\u2191j - \\u2191(int.floor (\\u03b1 * \\u2191j)) = int.fract (\\u03b1 * \\u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191j)))),},\\n have h5 : \\u03b1 = (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j), from by {rw [h3,h4], ring,},\\n have h6 : (i - j) \\u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\\n have h7 : (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j) \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n have h8 : \\u03b1 \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n exact h\\u03b1_irrat h8,\\n },\\n have h4 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n assume h2 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h3 : \\u03b1 * \\u2191i - \\u2191(int.floor (\\u03b1 * \\u2191i)) = int.fract (\\u03b1 * \\u2191i), from by {rw \\u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191i)))),},\\n have h4 : \\u03b1 * \\u2191j - \\u2191(int.floor (\\u03b1 * \\u2191j)) = int.fract (\\u03b1 * \\u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\\u03b1 * \\u2191j)))),},\\n have h5 : \\u03b1 = (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j), from by {rw [h3,h4], ring,},\\n have h6 : (i - j) \\u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\\n have h7 : (int.floor (\\u03b1 * \\u2191i) - int.floor (\\u03b1 * \\u2191j)) / (i - j) \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n have h8 : \\u03b1 \\u2208 \\u211a, from by {rw h5, apply_instance,},\\n exact h\\u03b1_irrat h8,\\n },\\n have h5 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n assume h2 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h3 : \\u03b1 * \\u2191\\nend --Needs more than 2000 tokens!\\n\\n--OUTPUT 3\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nbegin\\n -- Let $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n -- $$\\n -- i \\\\alpha-\\\\lfloor i \\\\alpha\\\\rfloor=\\\\{i \\\\alpha\\\\}=\\\\{j \\\\alpha\\\\}=j \\\\alpha-\\\\lfloor j \\\\alpha\\\\rfloor,\\n -- $$\\n -- which yields the false statement $\\\\alpha=\\\\frac{\\\\lfloor i \\\\alpha\\\\rfloor-\\\\lfloor j \\\\alpha\\\\rfloor}{i-j} \\\\in \\\\mathbb{Q}$. Hence,\\n -- $$\\n -- S:=\\\\{\\\\{i \\\\alpha\\\\} \\\\mid i \\\\in \\\\mathbb{Z}\\\\}\\n -- $$\\n -- is an infinite subset of $\\\\left[0,1\\\\right]$.\\n have h1 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j h,\\n have h2 : \\u03b1 = (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) / (i - j), from by {\\n have h3 : \\u03b1 * \\u2191i = (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i), from by {\\n rw int.fract_eq_of_nat_abs_lt_one,\\n have h4 : (0 : \\u211d) < (1 : \\u211d), from by {exact zero_lt_one},\\n have h5 : (0 : \\u211d) < (\\u03b1 * \\u2191i), from by {apply mul_pos h4, exact int.coe_nat_pos.mpr (int.coe_nat_ne_zero_iff_pos.mpr h)},\\n have h6 : (0 : \\u211d) < int.nat_abs (\\u03b1 * \\u2191i), from by {apply int.nat_abs_pos.mpr h5},\\n have h7 : (0 : \\u211d) < int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i, from by {apply mul_pos h6, exact int.coe_nat_pos.mpr (int.coe_nat_ne_zero_iff_pos.mpr h)},\\n have h8 : (0 : \\u211d) < int.nat_abs (\\u03b1 * \\u2191i) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i), from by {apply add_pos h6 h7},\\n have h9 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {rw \\u2190 int.fract_eq_of_nat_abs_lt_one, exact h8},\\n have h10 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h9 h8},\\n have h11 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i), from by {apply add_pos h10 h7},\\n have h12 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h11 h8},\\n have h13 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h12 h8},\\n have h14 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h13 h8},\\n have h15 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h14 h8},\\n have h16 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h15 h8},\\n have h17 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.nat_abs (\\u03b1 * \\u2191i) * \\u2191i) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)) + (int.fract (\\u03b1 * \\u2191i) + int.nat_abs (\\u03b1 * \\u2191i)), from by {apply add_pos h16 h8},\\n have h18 : (0 : \\u211d) < (\\u03b1 * \\u2191i) - (int\\nend --Needs more than 2000 tokens!\\n\\n/- FEW SHOT PROMPTS TO CODEX(START)\\n/--`theorem`\\nPower Set is Closed under Intersection\\nLet $S$ be a set.\\n\\nLet $\\\\powerset S$ be the power set of $S$.\\n\\n\\nThen:\\n:$\\\\forall A, B \\\\in \\\\powerset S: A \\\\cap B \\\\in \\\\powerset S$\\n`proof`\\nLet $A, B \\\\in \\\\powerset S$.\\n\\nThen by the definition of power set, $A \\\\subseteq S$ and $B \\\\subseteq S$.\\n\\nFrom Intersection is Subset we have that $A \\\\cap B \\\\subseteq A$.\\n\\nIt follows from Subset Relation is Transitive that $A \\\\cap B \\\\subseteq S$.\\n\\nThus $A \\\\cap B \\\\in \\\\powerset S$ and closure is proved.\\n{{qed}}\\n-/\\ntheorem power_set_intersection_closed {\\u03b1 : Type*} (S : set \\u03b1) : \\u2200 A B \\u2208 \\ud835\\udcab S, (A \\u2229 B) \\u2208 \\ud835\\udcab S :=\\nbegin\\n -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\\n assume (A : set \\u03b1) (hA : A \\u2208 \\ud835\\udcab S) (B : set \\u03b1) (hB : B \\u2208 \\ud835\\udcab S),\\n -- Then $A \\u2286 S$ and $B \\u2286 S$, by power set definition\\n have h1 : (A \\u2286 S) \\u2227 (B \\u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\\n -- Then $(A \\u2229 B) \\u2286 A$, by intersection of set is a subset\\n have h2 : (A \\u2229 B) \\u2286 A, from by apply set.inter_subset_left,\\n -- Then $(A \\u2229 B) \\u2286 S$, by subset relation is transitive \\n have h3 : (A \\u2229 B) \\u2286 S, from by {apply set.subset.trans h2 h1.left},\\n -- Hence $(A \\u2229 B) \\u2208 \\ud835\\udcab S$, by power set definition\\n show (A \\u2229 B) \\u2208 \\ud835\\udcab S, from by {apply set.mem_powerset h3},\\nend\\n\\n/--`theorem`\\nSquare of Sum\\n :$\\\\forall x, y \\\\in \\\\R: \\\\paren {x + y}^2 = x^2 + 2 x y + y^2$\\n`proof`\\nFollows from the distribution of multiplication over addition:\\n\\n{{begin-eqn}}\\n{{eqn | l = \\\\left({x + y}\\\\right)^2\\n | r = \\\\left({x + y}\\\\right) \\\\cdot \\\\left({x + y}\\\\right)\\n}}\\n{{eqn | r = x \\\\cdot \\\\left({x + y}\\\\right) + y \\\\cdot \\\\left({x + y}\\\\right)\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x \\\\cdot x + x \\\\cdot y + y \\\\cdot x + y \\\\cdot y\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x^2 + 2xy + y^2\\n | c = \\n}}\\n{{end-eqn}}\\n{{qed}}\\n-/\\ntheorem square_of_sum (x y : \\u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \\nbegin\\n -- expand the power\\n calc (x + y)^2 = (x+y)*(x+y) : by rw sq\\n -- distributive property of multiplication over addition gives:\\n ... = x*(x+y) + y*(x+y) : by rw add_mul\\n -- applying the above property further gives:\\n ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\\n -- rearranging the terms using commutativity and adding gives:\\n ... = x^2 + 2*x*y + y^2 : by {repeat {rw \\u2190 sq}, rw mul_comm y x, ring}\\nend\\n\\n/--`theorem`\\nIdentity of Group is Unique\\nLet $\\\\struct {G, \\\\circ}$ be a group. Then there is a unique identity element $e \\\\in G$.\\n`proof`\\nFrom Group has Latin Square Property, there exists a unique $x \\\\in G$ such that:\\n:$a x = b$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = b$\\n\\nSetting $b = a$, this becomes:\\n\\nThere exists a unique $x \\\\in G$ such that:\\n:$a x = a$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = a$\\n\\nThese $x$ and $y$ are both $e$, by definition of identity element.\\n{{qed}}\\n-/\\ntheorem group_identity_unique {G : Type*} [group G] : \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a :=\\nbegin\\n -- Group has Latin Square Property\\n have h1 : \\u2200 a b : G, \\u2203! x : G, a * x = b, from by {\\n assume a b : G, use a\\u207b\\u00b9 * b, obviously, },\\n have h2 : \\u2200 a b : G, \\u2203! y : G, y * a = b, from by {\\n assume a b : G, use b * a\\u207b\\u00b9, obviously, }, \\n\\n -- Setting $b = a$, this becomes:\\n have h3 : \\u2200 a : G, \\u2203! x : G, a * x = a, from \\n assume a : G, h1 a a,\\n have h4 : \\u2200 a : G, \\u2203! y : G, y * a = a, from\\n assume a : G, h2 a a,\\n\\n -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\\n have h5 : \\u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\\n exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\\n (mul_one a),\\n have h6 : \\u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\\n exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \\n\\n show \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a, from by {\\n use (1 : G),\\n have h7 : \\u2200 e : G, (\\u2200 a : G, e * a = a \\u2227 a * e = a) \\u2192 e = 1, from by {\\n assume (e : G) (hident : \\u2200 a : G, e * a = a \\u2227 a * e = a),\\n have h8 : \\u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\\n exists_unique.unique (h3 a) (hident a).right\\n (classical.some_spec (exists_unique.exists (h3 a))), \\n have h9 : \\u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\\n exists_unique.unique (h4 a) (hident a).left\\n (classical.some_spec (exists_unique.exists (h4 a))),\\n show e = (1 : G), from eq.trans (h9 e) (h6 _), \\n },\\n exact \\u27e8by obviously, h7\\u27e9,\\n }\\nend\\n\\n/--`theorem`\\nSqueeze Theorem for Real Numbers\\nLet $\\\\sequence {x_n}$, $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ be sequences in $\\\\R$.\\n\\nLet $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ both be convergent to the following limit:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l, \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$\\n\\nSuppose that:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\n\\nThen:\\n:$x_n \\\\to l$ as $n \\\\to \\\\infty$\\nthat is:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} x_n = l$\\n\\n`proof`\\nFrom Negative of Absolute Value:\\n:$\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n\\nLet $\\\\epsilon > 0$.\\n\\nWe need to prove that:\\n:$\\\\exists N: \\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that:\\n:$\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that:\\n:$\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n\\n\\nLet $N = \\\\max \\\\set {N_1, N_2}$.\\n\\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n:$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n\\nBut:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n\\nand so:\\n:$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n\\nSo:\\n:$\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nHence the result.\\n{{qed}}\\n\\n-/\\ntheorem squeeze_theorem_real_numbers (x y z : \\u2115 \\u2192 \\u211d) (l : \\u211d) : \\nlet seq_limit : (\\u2115 \\u2192 \\u211d) \\u2192 \\u211d \\u2192 Prop := \\u03bb (u : \\u2115 \\u2192 \\u211d) (l : \\u211d), \\u2200 \\u03b5 > 0, \\u2203 N, \\u2200 n > N, |u n - l| < \\u03b5 in\\n seq_limit y l \\u2192 seq_limit z l \\u2192 (\\u2200 n : \\u2115, (y n) \\u2264 (x n) \\u2227 (x n) \\u2264 (z n)) \\u2192 seq_limit x l :=\\nbegin\\n assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \\u2200 (n : \\u2115), y n \\u2264 x n \\u2227 x n \\u2264 z n) (\\u03b5), \\n\\n --From Negative of Absolute Value: $\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n have h5 : \\u2200 x, |x - l| < \\u03b5 \\u2194 (((l - \\u03b5) < x) \\u2227 (x < (l + \\u03b5))), \\n from by \\n {\\n intro x0,\\n have h6 : |x0 - l| < \\u03b5 \\u2194 ((x0 - l) < \\u03b5) \\u2227 ((l - x0) < \\u03b5), \\n from abs_sub_lt_iff, rw h6,\\n split, \\n rintro \\u27e8 S_1, S_2 \\u27e9, \\n split; linarith, \\n rintro \\u27e8 S_3, S_4 \\u27e9, \\n split; linarith,\\n },\\n \\n --Let $\\\\epsilon > 0$.\\n assume (h7 : \\u03b5 > 0),\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that $\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n cases h2 \\u03b5 h7 with N1 h8,\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that $\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n cases h3 \\u03b5 h7 with N2 h9,\\n \\n --Let $N = \\\\max \\\\set {N_1, N_2}$.\\n let N := max N1 N2,\\n use N,\\n\\n --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n have h10 : \\u2200 n > N, n > N1 \\u2227 n > N2 := by {\\n assume n h,\\n split,\\n exact lt_of_le_of_lt (le_max_left N1 N2) h, \\n exact lt_of_le_of_lt (le_max_right N1 N2) h,\\n },\\n \\n --$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n --$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n --$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n --So $\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n have h11 : \\u2200 n > N, (((l - \\u03b5) < (y n)) \\u2227 ((y n) \\u2264 (x n))) \\u2227 (((x n) \\u2264 (z n)) \\u2227 ((z n) < l+\\u03b5)), \\n from by {\\n intros n h12,\\n split,\\n {\\n\\n have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\\n split,\\n exact h13.left,\\n exact (h4 n).left,\\n },\\n { \\n have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\\n split,\\n exact (h4 n).right,\\n exact h14.right,\\n },\\n \\n },\\n\\n --$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n have h15 : \\u2200 n > N, ((l - \\u03b5) < (x n)) \\u2227 ((x n) < (l+\\u03b5)), \\n from by {\\n intros n1 h16, cases (h11 n1 h16);\\n split; linarith,\\n },\\n\\n --So $\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n --Hence the result\\n show \\u2200 (n : \\u2115), n > N \\u2192 |x n - l| < \\u03b5, \\n from by {\\n intros n h17,\\n cases h5 (x n) with h18 h19,\\n apply h19, exact h15 n h17,\\n },\\nend\\n\\n/--`theorem`\\nDensity of irrational orbit\\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\\n`proof`\\nLet $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n$$\\ni \\\\alpha-\\\\lfloor i \\\\alpha\\\\rfloor=\\\\{i \\\\alpha\\\\}=\\\\{j \\\\alpha\\\\}=j \\\\alpha-\\\\lfloor j \\\\alpha\\\\rfloor,\\n$$\\nwhich yields the false statement $\\\\alpha=\\\\frac{\\\\lfloor i \\\\alpha\\\\rfloor-\\\\lfloor j \\\\alpha\\\\rfloor}{i-j} \\\\in \\\\mathbb{Q}$. Hence,\\n$$\\nS:=\\\\{\\\\{i \\\\alpha\\\\} \\\\mid i \\\\in \\\\mathbb{Z}\\\\}\\n$$\\nis an infinite subset of $\\\\left[0,1\\\\right]$.\\n\\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\\n\\nTo show that $S$ is dense in $[0, 1]$, consider $y \\\\in[0,1]$, and $\\\\epsilon>0$. Then by selecting $x \\\\in S$ such that $\\\\{x\\\\}<\\\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\\\cdot\\\\{x\\\\} \\\\leq y<(N+1) \\\\cdot\\\\{x\\\\}$, we get: $|y-\\\\{N x\\\\}|<\\\\epsilon$.\\n\\nQED\\n-/\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nFEW SHOT PROMPTS TO CODEX(END)-/\\n\"} {\"text\": \"/-\\nCopyright (c) 2022 Andrew Yang. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Andrew Yang\\n-/\\nimport morphisms.open_immersion\\n\\n/-!\\n\\n# Open immersions\\n\\nA morphism is an open immersions if the underlying map of spaces is an open embedding\\n`f : X \\u27f6 U \\u2286 Y`, and the sheaf map `Y(V) \\u27f6 f _* X(V)` is an iso for each `V \\u2286 U`.\\n\\nMost of the theories are developed in `algebraic_geometry/open_immersion`, and we provide the\\nremaining theorems analogous to other lemmas in `algebraic_geometry/morphisms/*`.\\n\\n-/\\n\\nnoncomputable theory\\n\\nopen category_theory category_theory.limits opposite topological_space\\n\\nuniverse u\\n\\nnamespace algebraic_geometry\\n\\nvariables {X Y Z : Scheme.{u}} (f : X \\u27f6 Y) (g : Y \\u27f6 Z)\\n\\nlemma is_iso_iff_stalk {f : X \\u27f6 Y} :\\n is_iso f \\u2194\\n is_iso f.1.base \\u2227 \\u2200 x, is_iso (PresheafedSpace.stalk_map f.1 x) :=\\nbegin\\n split,\\n { intro h, exactI \\u27e8infer_instance, infer_instance\\u27e9 },\\n { rintro \\u27e8h\\u2081, h\\u2082\\u27e9, resetI,\\n haveI := is_open_immersion.of_stalk_iso f (Top.homeo_of_iso $ as_iso f.1.base).open_embedding,\\n exact is_open_immersion.to_iso f }\\nend\\n\\nlemma is_iso_respects_iso : morphism_property.respects_iso (@is_iso Scheme _) :=\\nby split; { introv H, resetI, apply_instance }\\n\\nlemma is_iso_is_local_at_target : property_is_local_at_target (@is_iso Scheme _) :=\\nbegin\\n constructor,\\n { exact is_iso_respects_iso },\\n { introsI, apply_instance },\\n { introsI X Y f \\ud835\\udcb0 H,\\n haveI := is_open_immersion_is_local_at_target.3 f \\ud835\\udcb0 infer_instance,\\n suffices : function.surjective f.1.base,\\n { rw \\u2190 Top.epi_iff_surjective f.1.base at this, exactI is_open_immersion.to_iso f },\\n have := congr_arg (coe : opens Y.carrier \\u2192 set Y.carrier) \\ud835\\udcb0.supr_opens_range,\\n rw opens.coe_supr at this,\\n rw set.surjective_iff_surjective_of_Union_eq_univ this,\\n intro i,\\n haveI := (is_iso_respects_iso.arrow_iso_iff\\n (morphism_restrict_opens_range f (\\ud835\\udcb0.map i))).mpr (H i),\\n have : epi (arrow.mk (f \\u2223_ Scheme.hom.opens_range (\\ud835\\udcb0.map i))).hom.1.base := infer_instance,\\n rw [Top.epi_iff_surjective, arrow.mk_hom, morphism_restrict_val_base] at this,\\n exact this }\\nend\\n\\nlemma is_iso.open_cover_tfae {X Y : Scheme.{u}} (f : X \\u27f6 Y) :\\n tfae [is_iso f,\\n \\u2203 (\\ud835\\udcb0 : Scheme.open_cover.{u} Y), \\u2200 (i : \\ud835\\udcb0.J),\\n is_iso (pullback.snd : (\\ud835\\udcb0.pullback_cover f).obj i \\u27f6 \\ud835\\udcb0.obj i),\\n \\u2200 (\\ud835\\udcb0 : Scheme.open_cover.{u} Y) (i : \\ud835\\udcb0.J),\\n is_iso (pullback.snd : (\\ud835\\udcb0.pullback_cover f).obj i \\u27f6 \\ud835\\udcb0.obj i),\\n \\u2200 (U : opens Y.carrier), is_iso (f \\u2223_ U),\\n \\u2200 {U : Scheme} (g : U \\u27f6 Y) [is_open_immersion g],\\n is_iso (pullback.snd : pullback f g \\u27f6 U),\\n \\u2203 {\\u03b9 : Type u} (U : \\u03b9 \\u2192 opens Y.carrier) (hU : supr U = \\u22a4),\\n \\u2200 i, is_iso (f \\u2223_ (U i))] :=\\nis_iso_is_local_at_target.open_cover_tfae f\\n\\nlemma is_iso_of_is_affine_is_iso {X Y : Scheme} [hX : is_affine X] [hY : is_affine Y] (f : X \\u27f6 Y)\\n [hf : is_iso (f.1.c.app (op \\u22a4))] : is_iso f :=\\nbegin\\n rw \\u2190 mem_Spec_ess_image at hX hY,\\n have : is_iso (AffineScheme.\\u0393.map (@quiver.hom.op AffineScheme _ \\u27e8X, hX\\u27e9 \\u27e8Y, hY\\u27e9 f)) := hf,\\n have := @@is_iso_of_reflects_iso _ _ _ _ this _,\\n exact @@functor.map_is_iso _ _ AffineScheme.forget_to_Scheme _ (@@is_iso_of_op _ _ this)\\nend\\n\\nlemma target_affine_locally_affine_and_is_iso :\\n target_affine_locally (\\u03bb X Y f hY, is_affine X \\u2227 is_iso (Scheme.\\u0393.map f.op)) = @is_iso Scheme _ :=\\nbegin\\n rw \\u2190 is_iso_is_local_at_target.target_affine_locally_eq,\\n congr,\\n ext X Y f hY,\\n split,\\n { rintros \\u27e8hX, hf\\u27e9, exactI @@is_iso_of_is_affine_is_iso _ _ f hf },\\n { intro hf, exactI \\u27e8is_affine_of_iso f, infer_instance\\u27e9 }\\nend\\n\\nend algebraic_geometry\"} {\"text\": \"[STATEMENT]\\nlemma size_Iff [simp]: \\\"size (A IFF B) = 2*(size A + size B) + 8\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. size (A IFF B) = 2 * (size A + size B) + 8\\n[PROOF STEP]\\nby (simp add: Iff_def)\"} {\"text\": \"{-# OPTIONS --safe --warning=error --without-K #-}\\n\\nopen import LogicalFormulae\\nopen import Setoids.Setoids\\nopen import Rings.Definition\\n\\nopen import Agda.Primitive using (Level; lzero; lsuc; _\\u2294_)\\n\\nmodule Rings.Units.Definition {a b : _} {A : Set a} {S : Setoid {a} {b} A} {_+_ _*_ : A \\u2192 A \\u2192 A} (R : Ring S _+_ _*_) where\\n\\nopen Setoid S\\nopen Ring R\\n\\nUnit : A \\u2192 Set (a \\u2294 b)\\nUnit r = Sg A (\\u03bb s \\u2192 (r * s) \\u223c 1R)\\n\"} {\"text\": \"lemma Cauchy_uniform_iff: \\\"Cauchy X \\\\<longleftrightarrow> (\\\\<forall>P. eventually P uniformity \\\\<longrightarrow> (\\\\<exists>N. \\\\<forall>n\\\\<ge>N. \\\\<forall>m\\\\<ge>N. P (X n, X m)))\\\"\"} {\"text\": \"import fibonacci_world.divides_mul -- hide\\n/-\\n## Divisibility of a sum\\n\\nIn the quest for proving an interesting result about Fibonacci numbers\\nit will be useful to have the following lemma, that allows to deduce\\nthe divibility of a sum from the divisibility of the summands.\\n-/\\n\\n/- Lemma :\\nIf $k$ divides $n$ and $m$, then $k$ divides $m + n$.\\n-/\\nlemma divides_add {k n m : \\u2115} (hn : k \\u2223 n) (hm : k \\u2223 m) : k \\u2223 m + n :=\\nbegin\\n cases hn with n1 hn1,\\n cases hm with m1 hm1,\\n use n1 + m1,\\n rw hn1,\\n rw hm1,\\n ring,\\n\\n\\n\\n \\nend\\n\\n\"} {\"text\": \"\\nimport analysis.normed.normed_field\\nimport data.polynomial.taylor\\nimport topology.metric_space.cau_seq_filter\\nimport topology.algebra.polynomial\\n\\nsection nonarchimedean\\n variables (\\ud835\\udd5c : Type) [normed_group \\ud835\\udd5c]\\n\\n /-- A type with a normed group structure is nonarchimedean if it satisfies `\\u2225x + y\\u2225 \\u2264 max \\u2225x\\u2225 \\u2225y\\u2225`. -/\\n class nonarchimedean :=\\n (nonarch : \\u2200 x y : \\ud835\\udd5c, \\u2225x + y\\u2225 \\u2264 max (\\u2225x\\u2225) (\\u2225y\\u2225))\\n\\n variables {\\ud835\\udd5c} [nonarchimedean \\ud835\\udd5c]\\n\\n /-- The nonarchimedean inequality with addition replaced with subtraction. -/\\n theorem nonarchimedean.nonarch_sub (x y : \\ud835\\udd5c) : \\u2225x - y\\u2225 \\u2264 max (\\u2225x\\u2225) (\\u2225y\\u2225) :=\\n (sub_eq_add_neg x y).symm \\u25b8 norm_neg y \\u25b8 nonarchimedean.nonarch x (-y)\\n\\n /-- The nonarchimedean inequality is equal if the elements being added have different norms. -/\\n theorem nonarchimedean.eq_max_of_ne_norm {x y : \\ud835\\udd5c} (h : \\u2225x\\u2225 \\u2260 \\u2225y\\u2225) :\\n \\u2225x + y\\u2225 = max (\\u2225x\\u2225) (\\u2225y\\u2225) :=\\n begin\\n have : \\u2200 {x y : \\ud835\\udd5c}, \\u2225x\\u2225 > \\u2225y\\u2225 \\u2192 \\u2225x + y\\u2225 = max (\\u2225x\\u2225) (\\u2225y\\u2225),\\n { intros x y h,\\n rw [max_eq_left_of_lt h],\\n have := nonarchimedean.nonarch_sub (x + y) y,\\n rw [\\u2190(eq_sub_of_add_eq rfl : x = x + y - y)] at this,\\n apply le_antisymm (max_eq_left_of_lt h \\u25b8 nonarchimedean.nonarch x y : \\u2225x + y\\u2225 \\u2264 \\u2225x\\u2225),\\n cases le_max_iff.mp this with h' h',\\n { exact h' },\\n { exact absurd h' (not_le.mpr h) } },\\n cases h.lt_or_lt with h h,\\n { rw [add_comm, max_comm], exact this h },\\n { exact this h }\\n end\\n\\n /-- If the nonarchimedean inequality is not equal, the elements being added have the same norm. -/\\n theorem nonarchimedean.eq_norm_of_ne_max {x y : \\ud835\\udd5c} (h : \\u2225x + y\\u2225 \\u2260 max (\\u2225x\\u2225) (\\u2225y\\u2225)) :\\n \\u2225x\\u2225 = \\u2225y\\u2225 := of_not_not (mt nonarchimedean.eq_max_of_ne_norm h)\\n\\n /-- A `\\u2115`-indexed sequence in a nonarchimedean normed ring is Cauchy iff the difference\\n of its consecutive terms tends to `0`. -/\\n theorem nonarchimedean.cau {\\ud835\\udd5c} [normed_ring \\ud835\\udd5c] [nonarchimedean \\ud835\\udd5c] {s : \\u2115 \\u2192 \\ud835\\udd5c} :\\n is_cau_seq norm s \\u2194 \\u2200 \\u03b5 > 0, \\u2203 i, \\u2200 j \\u2265 i, \\u2225s (j + 1) - s j\\u2225 < \\u03b5 :=\\n begin\\n apply forall\\u2082_congr, intros \\u03b5 h\\u03b5,\\n split,\\n { rintro \\u27e8i, hi\\u27e9, use i, intros j hj,\\n exact sub_add_sub_cancel (s (j + 1)) (s i) (s j) \\u25b8 neg_sub (s j) (s i) \\u25b8\\n lt_of_le_of_lt (nonarchimedean.nonarch (s (j + 1) - s i) (-(s j - s i)))\\n (max_lt (hi (j + 1) (le_add_right hj)) ((norm_neg (s j - s i)).symm \\u25b8 hi j hj)) },\\n { rintro \\u27e8i, hi\\u27e9, use i, intros j hj,\\n cases le_iff_exists_add.mp hj with k hk,\\n induction k with k ih generalizing j,\\n { rw [(add_zero i \\u25b8 hk : j = i), sub_self, norm_zero], exact h\\u03b5 },\\n { exact hk.symm \\u25b8 (sub_add_sub_cancel (s (i + k + 1)) (s (i + k)) (s i)) \\u25b8\\n lt_of_le_of_lt (nonarchimedean.nonarch (s (i + k + 1) - s (i + k)) (s (i + k) - s i))\\n (max_lt (hi (i + k) le_self_add) (ih (i + k) le_self_add rfl)) } }\\n end\\nend nonarchimedean\\n\\nsection\\n variables (\\ud835\\udd5c : Type) [normed_field \\ud835\\udd5c] [nonarchimedean \\ud835\\udd5c]\\n\\n /-- The closed unit ball in the nonarchimedean normed field `\\ud835\\udd5c`. -/\\n def disc : subring \\ud835\\udd5c := {\\n carrier := {x | \\u2225x\\u2225 \\u2264 1},\\n mul_mem' := \\u03bb x y hx hy, (norm_mul_le x y).trans (one_mul (1 : \\u211d) \\u25b8\\n mul_le_mul hx hy (norm_nonneg y) zero_le_one),\\n one_mem' := norm_one.le,\\n add_mem' := \\u03bb x y hx hy, (nonarchimedean.nonarch x y).trans (max_le hx hy),\\n zero_mem' := norm_zero.le.trans zero_le_one,\\n neg_mem' := \\u03bb x hx, ((norm_neg x).symm \\u25b8 hx : \\u2225-x\\u2225 \\u2264 1)\\n }\\n\\n namespace disc\\n /-- `disc \\ud835\\udd5c` inherits the norm of `\\ud835\\udd5c`. -/\\n instance disc_normed_ring : normed_ring (disc \\ud835\\udd5c) := {\\n norm := norm \\u2218 subtype.val,\\n dist_eq := \\u03bb x y, normed_field.dist_eq x.1 y.1 \\u25b8 rfl,\\n norm_mul := \\u03bb x y, le_of_eq (norm_mul x.1 y.1)\\n }\\n\\n section\\n variable {\\ud835\\udd5c}\\n\\n /-- The norm of `disc \\ud835\\udd5c` equals the norm of the inclusion into `\\ud835\\udd5c`. -/\\n theorem norm_def (x : disc \\ud835\\udd5c) : \\u2225x\\u2225 = \\u2225x.1\\u2225 := rfl\\n\\n /-- All elements in `disc \\ud835\\udd5c` have norm less than or equal to `1`. -/\\n theorem norm_le_one (x : disc \\ud835\\udd5c) : \\u2225x\\u2225 \\u2264 1 := x.2\\n\\n /-- The norm in `disc \\ud835\\udd5c` preserves multiplication. -/\\n protected theorem norm_mul (x y : disc \\ud835\\udd5c) : \\u2225x * y\\u2225 = \\u2225x\\u2225 * \\u2225y\\u2225 :=\\n norm_mul x.1 y.1\\n\\n /-- The norm in `disc \\ud835\\udd5c` preserves exponentiation. -/\\n protected theorem norm_pow (x : disc \\ud835\\udd5c) (n : \\u2115) : \\u2225x ^ n\\u2225 = \\u2225x\\u2225 ^ n :=\\n norm_pow x.1 n\\n\\n /-- Sequences with all elements having norm `\\u2264 1` are Cauchy in `\\ud835\\udd5c` if and only if they are Cauchy in `disc \\ud835\\udd5c`. -/\\n theorem disc_is_cau_seq_iff (s : \\u2115 \\u2192 \\ud835\\udd5c) (hs : \\u2200 n, \\u2225s n\\u2225 \\u2264 1) :\\n is_cau_seq norm s \\u2194 is_cau_seq norm (\\u03bb n, \\u27e8s n, hs n\\u27e9 : \\u2115 \\u2192 disc \\ud835\\udd5c) := iff.rfl\\n\\n /-- The injection of any Cauchy sequence in `disc \\ud835\\udd5c` into `\\ud835\\udd5c` is also a Cauchy sequence. -/\\n theorem disc_is_cau_seq {s : \\u2115 \\u2192 disc \\ud835\\udd5c} (h : is_cau_seq norm s) : is_cau_seq norm (\\u03bb n, (s n).1) :=\\n (disc_is_cau_seq_iff (\\u03bb n, (s n).1) (\\u03bb n, (s n).2)).mpr h\\n\\n variables {x y : disc \\ud835\\udd5c} (h : \\u2225x\\u2225 \\u2264 \\u2225y\\u2225)\\n include h\\n\\n /-- `disc \\ud835\\udd5c` inherits division from `\\ud835\\udd5c`, so long as the denominator has at least the numerator's norm. -/\\n def divide : disc \\ud835\\udd5c := \\u27e8x.1 / y.1,\\n begin\\n change \\u2225_\\u2225 \\u2264 1,\\n rw [norm_div, \\u2190norm_def x, \\u2190norm_def y],\\n by_cases hy : \\u2225y\\u2225 = 0,\\n { rw [hy, div_zero], exact zero_le_one },\\n { exact (div_le_one (lt_of_le_of_ne (norm_nonneg y) (ne.symm hy))).mpr h }\\n end\\u27e9\\n\\n /-- The norm in `disc \\ud835\\udd5c` preserves division. -/\\n theorem divide.norm : \\u2225divide h\\u2225 = \\u2225x\\u2225 / \\u2225y\\u2225 :=\\n norm_div x.1 y.1\\n\\n /-- If the denominator `y` is non-zero, multiplying `divide h` by `y` cancels the division, leaving the numerator `x`. -/\\n theorem divide.mul_cancel (hy : y \\u2260 0) : divide h * y = x :=\\n subtype.val_inj.mp (div_mul_cancel x.1 (mt subtype.val_inj.mp hy : y.1 \\u2260 (0 : disc \\ud835\\udd5c).val))\\n end\\n\\n /-- `disc \\ud835\\udd5c` inherits the nonarchimedean inequality from `\\ud835\\udd5c`. -/\\n instance disc_nonarchimedean : nonarchimedean (disc \\ud835\\udd5c) :=\\n \\u27e8\\u03bb x y, (norm_def (x + y)).symm \\u25b8 nonarchimedean.nonarch x.1 y.1\\u27e9\\n\\n /-- The norm in `disc \\ud835\\udd5c` is an absolute value, thanks to properties inherited from the normed field `\\ud835\\udd5c`. -/\\n instance disc_norm_is_absolute_value : is_absolute_value (norm : disc \\ud835\\udd5c \\u2192 \\u211d) := {\\n abv_nonneg := norm_nonneg,\\n abv_eq_zero := \\u03bb _, norm_eq_zero,\\n abv_add := \\u03bb x y, (normed_field.is_absolute_value.abv_add : \\u2200 x y : \\ud835\\udd5c, \\u2225x + y\\u2225 \\u2264 \\u2225x\\u2225 + \\u2225y\\u2225) x y,\\n abv_mul := disc.norm_mul,\\n }\\n\\n /-- `disc \\ud835\\udd5c` inherits the completeness of `\\ud835\\udd5c`, i.e. if all Cauchy sequences in `\\ud835\\udd5c` are convergent,\\n then so are all Cauchy sequences in `disc \\ud835\\udd5c`. -/\\n instance disc_is_complete [cau_seq.is_complete \\ud835\\udd5c norm] : cau_seq.is_complete (disc \\ud835\\udd5c) norm := \\u27e8\\u03bb s,\\n begin\\n let s' : cau_seq \\ud835\\udd5c norm := \\u27e8\\u03bb n, (s n).1, s.2\\u27e9,\\n use s'.lim,\\n { cases s'.equiv_lim 1 zero_lt_one with n hn,\\n rw [\\u2190sub_add_cancel s'.lim (s' n)],\\n apply le_trans (nonarchimedean.nonarch (s'.lim - s' n) (s' n)),\\n have : \\u2225s' n - cau_seq.const norm s'.lim n\\u2225 = \\u2225s'.lim - s' n\\u2225,\\n { rw [\\u2190norm_neg, neg_sub, cau_seq.const_apply] },\\n exact max_le (this \\u25b8 le_of_lt (hn n (le_refl n))) (s n).2 },\\n { exact s'.equiv_lim }\\n end\\u27e9\\n end disc\\nend\\n\\nsection taylor\\n open polynomial\\n variables {R : Type} [comm_ring R]\\n\\n /-- Any term of a polynomial sum can be removed and added separately so long as zero terms\\n do not contribute to the sum. -/\\n theorem polynomial.sum_term (n : \\u2115) (f : polynomial R) (fn : \\u2115 \\u2192 R \\u2192 polynomial R) (h : \\u2200 k, fn k 0 = 0) :\\n f.sum fn = fn n (f.coeff n) + (f.erase n).sum fn :=\\n begin\\n rw [sum_def, sum_def, support_erase],\\n by_cases hn : n \\u2208 f.support,\\n { rw [\\u2190finset.add_sum_erase f.support (\\u03bb n, fn n (f.coeff n)) hn],\\n apply congr_arg, apply finset.sum_congr rfl, intros x hx,\\n rw [erase_ne f n x (finset.ne_of_mem_erase hx)] },\\n { rw [not_mem_support_iff.mp hn, h n, zero_add],\\n exact eq.symm (finset.sum_congr (finset.erase_eq_of_not_mem hn)\\n (\\u03bb x hx, congr_arg _ (erase_ne f n x (\\u03bb h, absurd (h \\u25b8 hx : n \\u2208 f.support) hn)))) }\\n end\\n\\n /-- Any polynomial `f` can be approximated as a quadratic polynomial centred on a chosen point `t\\u2080`. -/\\n theorem taylor\\u2082 (f : polynomial R) (t\\u2080 : R) : \\u2203 err : polynomial R, \\u2200 t,\\n f.eval t = f.eval t\\u2080 + (t - t\\u2080) * f.derivative.eval t\\u2080 + (t - t\\u2080)^2 * err.eval t :=\\n begin\\n use (((taylor t\\u2080 f).erase 0).erase 1).sum (\\u03bb i a, C a * (X - C t\\u2080) ^ (i - 2)), intro t,\\n have : \\u2200 n, C 0 * (X - C t\\u2080) ^ n = 0, { intro n, rw [C_0, zero_mul] },\\n conv_lhs { rw [\\u2190f.sum_taylor_eq t\\u2080, (taylor t\\u2080 f).sum_term 0 (\\u03bb i a, C a * (X - C t\\u2080) ^ i) this,\\n ((taylor t\\u2080 f).erase 0).sum_term 1 (\\u03bb i a, C a * (X - C t\\u2080) ^ i) this, taylor_coeff_zero,\\n erase_ne (taylor t\\u2080 f) 0 1 nat.one_ne_zero, taylor_coeff_one], simp only,\\n rw [pow_zero, mul_one, pow_one, \\u2190add_assoc, mul_comm, eval_add, eval_add,\\n eval_C, eval_mul, eval_sub, eval_X, eval_C, eval_C] },\\n apply congr_arg,\\n have : (t - t\\u2080)^2 = ((X - C t\\u2080) ^ 2).eval t := by rw [eval_pow, eval_sub, eval_X, eval_C],\\n rw [this, \\u2190eval_mul], apply congr_arg,\\n rw [sum_def, sum_def, finset.mul_sum, finset.sum_congr rfl],\\n intros n hn,\\n conv_rhs { rw [mul_comm, mul_assoc, \\u2190pow_add], },\\n have : 2 \\u2264 n,\\n { cases n with n,\\n { exfalso, rw [support_erase, support_erase, finset.erase_right_comm] at hn,\\n exact absurd rfl (finset.ne_of_mem_erase hn) },\\n { cases n with n, { rw [support_erase] at hn, exact absurd rfl (finset.ne_of_mem_erase hn) },\\n { simp only [succ_order.succ_le_succ_iff, zero_le'] } } },\\n rw [nat.sub_add_cancel this]\\n end\\n\\n /-- Any polynomial `f` can be approximated as a linear polynomial centred on a chosen point `t\\u2080`. -/\\n theorem taylor\\u2081 (f : polynomial R) (t\\u2080 : R) : \\u2203 err : polynomial R, \\u2200 t,\\n f.eval t = f.eval t\\u2080 + (t - t\\u2080) * err.eval t :=\\n begin\\n cases taylor\\u2082 f t\\u2080 with err h,\\n use C (f.derivative.eval t\\u2080) + (X - C t\\u2080) * err, intro t,\\n rw [h t, eval_add, eval_C, mul_add, \\u2190add_assoc, eval_mul,\\n eval_sub, eval_X, eval_C, \\u2190mul_assoc, sq]\\n end\\n\\nend taylor\\n\\nsection\\n variables {R : Type} [normed_ring R] [is_absolute_value (norm : R \\u2192 \\u211d)]\\n\\n /-- A filter-wise Cauchy sequence is an absolute-value-wise Cauchy sequence.\\n (This already exists in `topology.metric_space.cau_seq_filter`, but only for normed fields,\\n here it is restated for normed rings whose norm is an absolute value). -/\\n theorem cauchy_seq.is_cau_seq' {f : \\u2115 \\u2192 R} (hf : cauchy_seq f) :\\n is_cau_seq norm f :=\\n begin\\n cases cauchy_iff.1 hf with hf1 hf2,\\n intros \\u03b5 h\\u03b5,\\n rcases hf2 {x | dist x.1 x.2 < \\u03b5} (metric.dist_mem_uniformity h\\u03b5) with \\u27e8t, \\u27e8ht, htsub\\u27e9\\u27e9,\\n simp at ht, cases ht with N hN,\\n existsi N,\\n intros j hj,\\n rw \\u2190dist_eq_norm,\\n apply @htsub (f j, f N),\\n apply set.mk_mem_prod; solve_by_elim [le_refl]\\n end\\n\\n variable [cau_seq.is_complete R norm]\\n\\n /-- A Cauchy sequence formed by composing a Cauchy sequence with a polynomial. -/\\n noncomputable def polynomial_comp (f : polynomial R) (s : cau_seq R norm) : cau_seq R norm :=\\n \\u27e8\\u03bb n, f.eval (s n), ((f.continuous.tendsto s.lim).comp s.tendsto_limit).cauchy_seq.is_cau_seq'\\u27e9\\n\\n /-- The composition of a polynomial with a Cauchy sequence's limit equals the limit of the\\n composition of the polynomial with the Cauchy sequence. -/\\n theorem polynomial_comp_lim (f : polynomial R) (s : cau_seq R norm) : f.eval s.lim = (polynomial_comp f s).lim :=\\n tendsto_nhds_unique ((f.continuous.tendsto s.lim).comp s.tendsto_limit) (polynomial_comp f s).tendsto_limit\\n\\n /-- A Cauchy sequence formed by composing a Cauchy sequence with the norm. -/\\n noncomputable def norm_comp (s : cau_seq R norm) : cau_seq \\u211d norm :=\\n \\u27e8\\u03bb n, \\u2225s n\\u2225, ((continuous_norm.tendsto s.lim).comp s.tendsto_limit).cauchy_seq.is_cau_seq'\\u27e9\\n\\n /-- The composition of the norm with a Cauchy sequence's limit equals the limit of the\\n composition of the norm with the Cauchy sequence. -/\\n theorem norm_comp_lim (s : cau_seq R norm) : \\u2225s.lim\\u2225 = (norm_comp s).lim :=\\n tendsto_nhds_unique ((continuous_norm.tendsto s.lim).comp s.tendsto_limit) (norm_comp s).tendsto_limit\\nend\\n\"} {\"text\": \"parameters (n:Nat)\\n namespace X\\n export\\n foo : Bool\\n foo = True\\n\\n U : Bool\\n U = foo\\n\"} {\"text\": \" integer function fun(num)\\n write(6, *) num\\n fun = 10 + num\\n return\\n end\\n\\n subroutine sub1(func)\\n implicit none\\n external func\\n integer func\\n integer i\\n save\\n i = func(i)\\n write(6, *) i\\n return\\n end\\n\\n subroutine sub2(func)\\n external func\\n integer func\\n i = func(3)\\n write(6, *) i\\n return\\n end\\n\\n program prog\\n implicit none\\n external fun\\n integer fun\\n integer i\\n i = fun(1)\\n write(6, *) i\\n call sub1(fun)\\n call sub1(fun)\\n call sub2(fun)\\n end\\n\"} {\"text\": \"{-# LANGUAGE FlexibleContexts #-}\\n{-# LANGUAGE BangPatterns #-}\\n{-# LANGUAGE DataKinds #-}\\n{-# LANGUAGE DeriveGeneric #-}\\n{-# LANGUAGE DeriveAnyClass #-}\\n{-# LANGUAGE FlexibleInstances #-}\\n{-# LANGUAGE FunctionalDependencies #-}\\n{-# LANGUAGE MultiParamTypeClasses #-}\\n{-# LANGUAGE TemplateHaskell #-}\\n{-# LANGUAGE TypeFamilies #-}\\n{-# LANGUAGE RankNTypes #-}\\n{-# LANGUAGE ScopedTypeVariables #-}\\n{-# LANGUAGE StandaloneDeriving #-}\\n{-# LANGUAGE ViewPatterns #-}\\n{-# OPTIONS_HADDOCK show-extensions #-}\\n\\nmodule NQS.CG\\n ( Operator\\n , NQS.CG.cg\\n , test\\n ) where\\n\\nimport Data.Complex\\nimport Control.Monad.Primitive\\n\\nimport qualified Data.Vector.Storable as V\\nimport qualified Data.Vector.Storable.Mutable as MV\\n\\nimport Foreign.Storable\\n\\nimport Lens.Micro\\n\\nimport NQS.Internal.Types\\nimport NQS.Internal.BLAS\\n\\n\\ntype Operator m el = -- forall m. PrimMonad m\\n MDenseVector 'Direct (PrimState m) el -- ^ Input\\n -> MDenseVector 'Direct (PrimState m) el -- ^ Output\\n -> m ()\\n\\nclass ToComplex a where\\n promoteToComplex :: RealOf a -> a\\n\\ninstance {-# OVERLAPPABLE #-} (a ~ RealOf a) => ToComplex a where\\n promoteToComplex = id\\n\\ninstance {-# OVERLAPS #-} (Num a, a ~ RealOf (Complex a)) => ToComplex (Complex a) where\\n promoteToComplex = (:+ 0)\\n\\ncg :: forall v el m.\\n ( PrimMonad m, v ~ MDenseVector 'Direct\\n , DOTC v el el, AXPY v el, COPY v el\\n , NRM2 v el (RealOf el), SCAL (RealOf el) v el\\n , Storable el, Fractional el, ToComplex el, RealFloat (RealOf el)\\n )\\n => Int -- ^ Max number of iterations\\n -> RealOf el -- ^ Tolerance\\n -> Operator m el -- ^ A\\n -> MDenseVector 'Direct (PrimState m) el -- ^ b\\n -> MDenseVector 'Direct (PrimState m) el -- ^ Initial guess x\\n -> m (Int, RealOf el)\\ncg !maxIter !tol operator !b !x0 = do\\n r <- newTempVector n\\n p <- newTempVector n\\n q <- newTempVector n\\n bNorm <- norm b\\n -- This will probably never ever happen, but we should check anyway\\n if bNorm == 0\\n then fill x0 0 >> return (0, 0)\\n else do\\n -- r := b - max * x0\\n copy b r\\n operator x0 q\\n axpy (-1) q r\\n -- Are we done already?\\n norm r >>= \\\\rNorm -> if rNorm < tol * tol * bNorm\\n then return $! (0, sqrt (rNorm / bNorm))\\n else do\\n -- Start the loop\\n copy r p\\n go bNorm x0 r p q rNorm 0\\n where\\n n = b ^. dim\\n newTempVector size = MDenseVector size 1 <$> newVectorAligned size 64\\n norm x = (\\\\y -> y * y) <$> nrm2 x\\n go !bNorm !x !r !p !q !\\u03c1 !i\\n | i >= maxIter = nrm2 r >>= \\\\rNorm -> return (i, rNorm / bNorm)\\n | otherwise = do\\n operator p q\\n \\u03b1 <- (promoteToComplex \\u03c1 /) <$> dotc p q\\n axpy \\u03b1 p x\\n axpy (-\\u03b1) q r\\n norm r >>= \\\\rNorm -> if rNorm < threshold\\n then return (i, sqrt (rNorm / bNorm))\\n else do copy r q\\n let \\u03c1' = rNorm\\n \\u03b2 = \\u03c1' / \\u03c1\\n scal \\u03b2 p\\n axpy 1 q p\\n go bNorm x r p q \\u03c1' (i + 1)\\n where threshold :: RealOf el\\n threshold = tol * tol * bNorm\\n\\ntest :: IO ()\\ntest = do\\n let -- operator :: Operator Float\\n operator x y = do\\n aBuff <- newVectorAligned 9 64 :: IO (MV.MVector (PrimState IO) Float)\\n V.copy aBuff $ V.fromList [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n let a = MDenseMatrix 3 3 3 aBuff :: MDenseMatrix 'Row (PrimState IO) Float\\n gemv NoTranspose 1.0 a x 0.0 y\\n bBuff <- V.unsafeThaw $ V.fromList [2, 2, 2 :: Float]\\n xBuff <- V.unsafeThaw $ V.fromList [0, 0, 0 :: Float]\\n let x = MDenseVector 3 1 xBuff :: MDenseVector 'Direct (PrimState IO) Float\\n let b = MDenseVector 3 1 bBuff :: MDenseVector 'Direct (PrimState IO) Float\\n print =<< (NQS.CG.cg 30 (1.0E-8 :: Float) operator b x)\\n\\n\"} {\"text\": \"/-\\nCopyright (c) 2022 Jannis Limperg. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: David Renshaw, Jannis Limperg\\n-/\\n\\nimport Aesop\\n\\n-- This is an example which is currently challenging for Lean 4 `tauto`.\\nexample {\\u03b1 : Type} [LE \\u03b1] (a b c : \\u03b1) (x\\u2080 x\\u2081 x\\u2082 : Prop)\\n (this1 : x\\u2080 \\u2192 x\\u2081 \\u2192 a \\u2264 c)\\n (this2 : x\\u2081 \\u2192 x\\u2082 \\u2192 b \\u2264 a)\\n (this3 : x\\u2082 \\u2192 x\\u2080 \\u2192 c \\u2264 b) :\\n ((x\\u2080 \\u2227 \\u00acb \\u2264 a) \\u2227 x\\u2081 \\u2227 \\u00acc \\u2264 b \\u2228\\n (x\\u2081 \\u2227 \\u00acc \\u2264 b) \\u2227 x\\u2082 \\u2227 \\u00aca \\u2264 c \\u2228 (x\\u2082 \\u2227 \\u00aca \\u2264 c) \\u2227 x\\u2080 \\u2227 \\u00acb \\u2264 a \\u2194\\n (x\\u2080 \\u2227 x\\u2081 \\u2228 x\\u2081 \\u2227 x\\u2082 \\u2228 x\\u2082 \\u2227 x\\u2080) \\u2227\\n \\u00ac(c \\u2264 b \\u2227 b \\u2264 a \\u2228 b \\u2264 a \\u2227 a \\u2264 c \\u2228 a \\u2264 c \\u2227 c \\u2264 b)) :=\\nby aesop\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 Mario Carneiro. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Mario Carneiro\\n-/\\nimport Lean\\n\\nsection\\nopen Lean Elab Command\\n\\nsyntax (name := timeCmd) \\\"#time \\\" command : command\\n\\n/--\\nTime the elaboration of a command, and print the result (in milliseconds).\\n\\nExample usage:\\n```\\nset_option maxRecDepth 100000 in\\n#time example : (List.range 500).length = 500 := rfl\\n```\\n-/\\n@[commandElab timeCmd] def timeCmdElab : CommandElab\\n | `(#time%$tk $stx:command) => do\\n let start \\u2190 IO.monoMsNow\\n elabCommand stx\\n logInfoAt tk m!\\\"time: {(\\u2190 IO.monoMsNow) - start}ms\\\"\\n | _ => throwUnsupportedSyntax\\n\\nend\\n\"} {\"text\": \"",
    "formal_statement": "is: lemma contractible_empty [simp]: \\\"contractible {}\\\" Informal statement is: The empty space is contractible.\"} {\"text\": \"Reserved Notation \\\"A 'wimp' B\\\" (at level 99).\\n\\nInductive WImp (A B : Prop) : Prop"
  },
  {
    "informal_statement": "is: The polynomial $f(0)$ is the zero polynomial.\"} {\"text\": \"import data.real.irrational\\nimport topology.basic\\nimport algebra.order.floor\\n\\n\\n--OUTPUT 1\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nbegin\\n --Let $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n have h1 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 int.fract (\\u03b1 * \\u2191i) \\u2260 int.fract (\\u03b1 * \\u2191j), from by {\\n assume i j : \\u2124,\\n assume h2 : i \\u2260 j,\\n assume h3 : int.fract (\\u03b1 * \\u2191i) = int.fract (\\u03b1 * \\u2191j),\\n have h4 : \\u03b1 * \\u2191i - \\u2191(int.floor (\\u03b1 * \\u2191i)) = int.fract (\\u03b1 * \\u2191i), from by {rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\u03b1 * \\u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\\nend --Needs more than 2000 tokens!\\n\\n/- FEW SHOT PROMPTS TO CODEX(START)\\n/--`theorem`\\nPower Set is Closed under Intersection\\nLet $S$ be a set.\\n\\nLet $\\\\powerset S$ be the power set of $S$.\\n\\n\\nThen:\\n:$\\\\forall A, B \\\\in \\\\powerset S: A \\\\cap B \\\\in \\\\powerset S$\\n`proof`\\nLet $A, B \\\\in \\\\powerset S$.\\n\\nThen by the definition of power set, $A \\\\subseteq S$ and $B \\\\subseteq S$.\\n\\nFrom Intersection is Subset we have that $A \\\\cap B \\\\subseteq A$.\\n\\nIt follows from Subset Relation is Transitive that $A \\\\cap B \\\\subseteq S$.\\n\\nThus $A \\\\cap B \\\\in \\\\powerset S$ and closure is proved.\\n{{qed}}\\n-/\\ntheorem power_set_intersection_closed {\\u03b1 : Type*} (S : set \\u03b1) : \\u2200 A B \\u2208 \\ud835\\udcab S, (A \\u2229 B) \\u2208 \\ud835\\udcab S :=\\nbegin\\n -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\\n assume (A : set \\u03b1) (hA : A \\u2208 \\ud835\\udcab S) (B : set \\u03b1) (hB : B \\u2208 \\ud835\\udcab S),\\n -- Then $A \\u2286 S$ and $B \\u2286 S$, by power set definition\\n have h1 : (A \\u2286 S) \\u2227 (B \\u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\\n -- Then $(A \\u2229 B) \\u2286 A$, by intersection of set is a subset\\n have h2 : (A \\u2229 B) \\u2286 A, from by apply set.inter_subset_left,\\n -- Then $(A \\u2229 B) \\u2286 S$, by subset relation is transitive \\n have h3 : (A \\u2229 B) \\u2286 S, from by {apply set.subset.trans h2 h1.left},\\n -- Hence $(A \\u2229 B) \\u2208 \\ud835\\udcab S$, by power set definition\\n show (A \\u2229 B) \\u2208 \\ud835\\udcab S, from by {apply set.mem_powerset h3},\\nend\\n\\n/--`theorem`\\nSquare of Sum\\n :$\\\\forall x, y \\\\in \\\\R: \\\\paren {x + y}^2 = x^2 + 2 x y + y^2$\\n`proof`\\nFollows from the distribution of multiplication over addition:\\n\\n{{begin-eqn}}\\n{{eqn | l = \\\\left({x + y}\\\\right)^2\\n | r = \\\\left({x + y}\\\\right) \\\\cdot \\\\left({x + y}\\\\right)\\n}}\\n{{eqn | r = x \\\\cdot \\\\left({x + y}\\\\right) + y \\\\cdot \\\\left({x + y}\\\\right)\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x \\\\cdot x + x \\\\cdot y + y \\\\cdot x + y \\\\cdot y\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x^2 + 2xy + y^2\\n | c = \\n}}\\n{{end-eqn}}\\n{{qed}}\\n-/\\ntheorem square_of_sum (x y : \\u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \\nbegin\\n -- expand the power\\n calc (x + y)^2 = (x+y)*(x+y) : by rw sq\\n -- distributive property of multiplication over addition gives:\\n ... = x*(x+y) + y*(x+y) : by rw add_mul\\n -- applying the above property further gives:\\n ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\\n -- rearranging the terms using commutativity and adding gives:\\n ... = x^2 + 2*x*y + y^2 : by {repeat {rw \\u2190 sq}, rw mul_comm y x, ring}\\nend\\n\\n/--`theorem`\\nIdentity of Group is Unique\\nLet $\\\\struct {G, \\\\circ}$ be a group. Then there is a unique identity element $e \\\\in G$.\\n`proof`\\nFrom Group has Latin Square Property, there exists a unique $x \\\\in G$ such that:\\n:$a x = b$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = b$\\n\\nSetting $b = a$, this becomes:\\n\\nThere exists a unique $x \\\\in G$ such that:\\n:$a x = a$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = a$\\n\\nThese $x$ and $y$ are both $e$, by definition of identity element.\\n{{qed}}\\n-/\\ntheorem group_identity_unique {G : Type*} [group G] : \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a :=\\nbegin\\n -- Group has Latin Square Property\\n have h1 : \\u2200 a b : G, \\u2203! x : G, a * x = b, from by {\\n assume a b : G, use a\\u207b\\u00b9 * b, obviously, },\\n have h2 : \\u2200 a b : G, \\u2203! y : G, y * a = b, from by {\\n assume a b : G, use b * a\\u207b\\u00b9, obviously, }, \\n\\n -- Setting $b = a$, this becomes:\\n have h3 : \\u2200 a : G, \\u2203! x : G, a * x = a, from \\n assume a : G, h1 a a,\\n have h4 : \\u2200 a : G, \\u2203! y : G, y * a = a, from\\n assume a : G, h2 a a,\\n\\n -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\\n have h5 : \\u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\\n exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\\n (mul_one a),\\n have h6 : \\u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\\n exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \\n\\n show \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a, from by {\\n use (1 : G),\\n have h7 : \\u2200 e : G, (\\u2200 a : G, e * a = a \\u2227 a * e = a) \\u2192 e = 1, from by {\\n assume (e : G) (hident : \\u2200 a : G, e * a = a \\u2227 a * e = a),\\n have h8 : \\u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\\n exists_unique.unique (h3 a) (hident a).right\\n (classical.some_spec (exists_unique.exists (h3 a))), \\n have h9 : \\u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\\n exists_unique.unique (h4 a) (hident a).left\\n (classical.some_spec (exists_unique.exists (h4 a))),\\n show e = (1 : G), from eq.trans (h9 e) (h6 _), \\n },\\n exact \\u27e8by obviously, h7\\u27e9,\\n }\\nend\\n\\n/--`theorem`\\nSqueeze Theorem for Real Numbers\\nLet $\\\\sequence {x_n}$, $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ be sequences in $\\\\R$.\\n\\nLet $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ both be convergent to the following limit:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l, \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$\\n\\nSuppose that:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\n\\nThen:\\n:$x_n \\\\to l$ as $n \\\\to \\\\infty$\\nthat is:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} x_n = l$\\n\\n`proof`\\nFrom Negative of Absolute Value:\\n:$\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n\\nLet $\\\\epsilon > 0$.\\n\\nWe need to prove that:\\n:$\\\\exists N: \\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that:\\n:$\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that:\\n:$\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n\\n\\nLet $N = \\\\max \\\\set {N_1, N_2}$.\\n\\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n:$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n\\nBut:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n\\nand so:\\n:$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n\\nSo:\\n:$\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nHence the result.\\n{{qed}}\\n\\n-/\\ntheorem squeeze_theorem_real_numbers (x y z : \\u2115 \\u2192 \\u211d) (l : \\u211d) : \\nlet seq_limit : (\\u2115 \\u2192 \\u211d) \\u2192 \\u211d \\u2192 Prop := \\u03bb (u : \\u2115 \\u2192 \\u211d) (l : \\u211d), \\u2200 \\u03b5 > 0, \\u2203 N, \\u2200 n > N, |u n - l| < \\u03b5 in\\n seq_limit y l \\u2192 seq_limit z l \\u2192 (\\u2200 n : \\u2115, (y n) \\u2264 (x n) \\u2227 (x n) \\u2264 (z n)) \\u2192 seq_limit x l :=\\nbegin\\n assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \\u2200 (n : \\u2115), y n \\u2264 x n \\u2227 x n \\u2264 z n) (\\u03b5), \\n\\n --From Negative of Absolute Value: $\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n have h5 : \\u2200 x, |x - l| < \\u03b5 \\u2194 (((l - \\u03b5) < x) \\u2227 (x < (l + \\u03b5))), \\n from by \\n {\\n intro x0,\\n have h6 : |x0 - l| < \\u03b5 \\u2194 ((x0 - l) < \\u03b5) \\u2227 ((l - x0) < \\u03b5), \\n from abs_sub_lt_iff, rw h6,\\n split, \\n rintro \\u27e8 S_1, S_2 \\u27e9, \\n split; linarith, \\n rintro \\u27e8 S_3, S_4 \\u27e9, \\n split; linarith,\\n },\\n \\n --Let $\\\\epsilon > 0$.\\n assume (h7 : \\u03b5 > 0),\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that $\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n cases h2 \\u03b5 h7 with N1 h8,\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that $\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n cases h3 \\u03b5 h7 with N2 h9,\\n \\n --Let $N = \\\\max \\\\set {N_1, N_2}$.\\n let N := max N1 N2,\\n use N,\\n\\n --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n have h10 : \\u2200 n > N, n > N1 \\u2227 n > N2 := by {\\n assume n h,\\n split,\\n exact lt_of_le_of_lt (le_max_left N1 N2) h, \\n exact lt_of_le_of_lt (le_max_right N1 N2) h,\\n },\\n \\n --$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n --$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n --$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n --So $\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n have h11 : \\u2200 n > N, (((l - \\u03b5) < (y n)) \\u2227 ((y n) \\u2264 (x n))) \\u2227 (((x n) \\u2264 (z n)) \\u2227 ((z n) < l+\\u03b5)), \\n from by {\\n intros n h12,\\n split,\\n {\\n\\n have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\\n split,\\n exact h13.left,\\n exact (h4 n).left,\\n },\\n { \\n have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\\n split,\\n exact (h4 n).right,\\n exact h14.right,\\n },\\n \\n },\\n\\n --$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n have h15 : \\u2200 n > N, ((l - \\u03b5) < (x n)) \\u2227 ((x n) < (l+\\u03b5)), \\n from by {\\n intros n1 h16, cases (h11 n1 h16);\\n split; linarith,\\n },\\n\\n --So $\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n --Hence the result\\n show \\u2200 (n : \\u2115), n > N \\u2192 |x n - l| < \\u03b5, \\n from by {\\n intros n h17,\\n cases h5 (x n) with h18 h19,\\n apply h19, exact h15 n h17,\\n },\\nend\\n\\n/--`theorem`\\nDensity of irrational orbit\\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\\n`proof`\\nLet $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n$$\\ni \\\\alpha-\\\\lfloor i \\\\alpha\\\\rfloor=\\\\{i \\\\alpha\\\\}=\\\\{j \\\\alpha\\\\}=j \\\\alpha-\\\\lfloor j \\\\alpha\\\\rfloor,\\n$$\\nwhich yields the false statement $\\\\alpha=\\\\frac{\\\\lfloor i \\\\alpha\\\\rfloor-\\\\lfloor j \\\\alpha\\\\rfloor}{i-j} \\\\in \\\\mathbb{Q}$. Hence,\\n$$\\nS:=\\\\{\\\\{i \\\\alpha\\\\} \\\\mid i \\\\in \\\\mathbb{Z}\\\\}\\n$$\\nis an infinite subset of $\\\\left[0,1\\\\right]$.\\n\\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\\n\\nTo show that $S$ is dense in $[0, 1]$, consider $y \\\\in[0,1]$, and $\\\\epsilon>0$. Then by selecting $x \\\\in S$ such that $\\\\{x\\\\}<\\\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\\\cdot\\\\{x\\\\} \\\\leq y<(N+1) \\\\cdot\\\\{x\\\\}$, we get: $|y-\\\\{N x\\\\}|<\\\\epsilon$.\\n\\nQED\\n-/\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=\\nFEW SHOT PROMPTS TO CODEX(END)-/\\n\"} {\"text\": \"import data.complex.basic\\nimport data.complex.module\\nimport data.fintype.basic\\nimport data.real.basic\\nimport data.matrix.basic\\nimport linear_algebra.matrix\\n\\nopen_locale matrix big_operators\\nopen_locale complex_conjugate\\nopen fintype finset matrix complex\\n\\nuniverses u\\n-- variables {\\u03b1 : Type u}\\n-- variables {m n : Type*} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] [has_one n]\\nvariable (n : \\u2115) \\n-- namespace matrix\\n\\nvariables (M : matrix (fin n) (fin n) \\u2102)\\n\\n-- end matrix\\n\\n-- def make_mat (M : matrix n n \\u2102) : matrix n n \\u2102 := \\u03bb i: n, (\\u03bb j : n, (M i j))\\n\\n-- lemma trace_form (A : matrix n n \\u2102) (B : matrix n n \\u2102) : \\u2211 (i : n), \\u2211 (j : n), (A i j)*(B i j) = ( (A.transpose).mul B).trce :=\\n-- begin\\n-- simp only [matrix.trce, matrix.mul],\\n-- -- \\u2211 (i j : n), A i j * B i j = \\u2211 (x : n), A\\u1d40 x \\u2b1d\\u1d65 \\u03bb (j : n), B j x\\n-- simp [matrix.transpose, dot_product],\\n-- exact sum_comm,\\n-- -- \\u2211 (i j : n), A i j * B i j = \\u2211 (x : n), A\\u1d40 x \\u2b1d\\u1d65 \\u03bb (j : n), B j x\\n-- end\\n\\nlemma trace_form (A : matrix (fin n) (fin n) \\u2102) (B : matrix (fin n) (fin n) \\u2102) : \\u2211 (i : (fin n)), \\u2211 (j : (fin n)), (A i j)*(B i j) = matrix.trace (fin n) \\u2102 \\u2102 ( (A.transpose).mul B) :=\\nbegin\\n simp only [matrix.trace, matrix.mul],\\n -- \\u2211 (i j : n), A i j * B i j = \\u2211 (x : n), A\\u1d40 x \\u2b1d\\u1d65 \\u03bb (j : n), B j x\\n simp [matrix.transpose, dot_product],\\n exact sum_comm,\\n -- \\u2211 (i j : n), A i j * B i j = \\u2211 (x : n), A\\u1d40 x \\u2b1d\\u1d65 \\u03bb (j : n), B j x\\nend\\n\\nlemma Laplace (A : matrix (fin n.succ) (fin n.succ) \\u2102) : \\u2200 i : (fin n.succ), det A = \\u2211 (j : (fin n.succ)), (A i j)*(-1)^(i+j : \\u2115)*det (A.minor i.succ_above j.succ_above) :=\\nbegin\\n intro i,\\n have hyp := det_succ_row A i,\\n rw hyp,\\n simp [add_comm, mul_comm],\\nend \\n\\n\\n\\n\\n\\n\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 OpenAI. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\\n-/\\nimport mathzoo.imports.miniF2F\\n\\nopen_locale nat rat real big_operators topological_space\\n\\ntheorem mathd_algebra_419\\n (a b : \\u211d)\\n (h\\u2080 : a = -1)\\n (h\\u2081 : b = 5) :\\n -a - b^2 + 3 * (a * b) = -39 :=\\nbegin\\n rw [h\\u2080, h\\u2081],\\n norm_num,\\nend\"} {\"text\": \"{-# OPTIONS --type-in-type --guardedness #-}\\n\\nmodule IO.Exts where\\n\\nimport IO.Primitive as Prim\\nopen import Class.Monad\\nopen import Class.Functor\\nopen import Data.List\\nopen import Data.Nat using (\\u2115)\\nopen import Data.String\\nopen import Data.Sum\\nopen import Data.Unit\\nopen import Function\\nopen import IO using (IO; run; readFiniteFile; lift)\\nopen import IO.Instance\\nopen import Level\\n\\nprivate\\n variable\\n A : Set\\n\\n{-#\\n FOREIGN GHC\\n import Data.Text\\n import System.CPUTime\\n import System.Environment\\n import System.Exit\\n import System.IO\\n import System.IO.Error\\n import System.Process\\n#-}\\n\\npostulate\\n flushStdoutPrim : Prim.IO \\u22a4\\n getCPUTimePrim : Prim.IO \\u2115\\n putStrErrPrim : String \\u2192 Prim.IO \\u22a4\\n runShellCmdPrim : String \\u2192 List String \\u2192 Prim.IO String\\n catchIOErrorPrim : Prim.IO A \\u2192 (String \\u2192 Prim.IO A) \\u2192 Prim.IO A\\n\\n{-# COMPILE GHC flushStdoutPrim = hFlush stdout #-}\\n{-# COMPILE GHC getCPUTimePrim = getCPUTime #-}\\n{-# COMPILE GHC putStrErrPrim = hPutStr stderr . unpack #-}\\n{-# COMPILE GHC runShellCmdPrim = \\\\ s t -> pack <$> (readProcess (unpack s) (fmap unpack t) \\\"\\\") #-} -- use haskell proc\\n{-# COMPILE GHC catchIOErrorPrim = \\\\ _ a f -> catchIOError a (f . pack . show) #-}\\n\\nflushStdout : IO \\u22a4\\nflushStdout = lift flushStdoutPrim\\n\\ngetCPUTime : IO \\u2115\\ngetCPUTime = lift getCPUTimePrim\\n\\nputStrErr : String \\u2192 IO \\u22a4\\nputStrErr s = lift (putStrErrPrim s)\\n\\nrunShellCmd : String \\u2192 List String \\u2192 IO String\\nrunShellCmd s args = lift (runShellCmdPrim s args)\\n\\ncatchIOError : IO A \\u2192 (String \\u2192 IO A) \\u2192 IO A\\ncatchIOError a f = lift $ catchIOErrorPrim (run a) (run \\u2218 f)\\n\\nreadFiniteFileError : String \\u2192 IO (String \\u228e String)\\nreadFiniteFileError name =\\n catchIOError (inj\\u2082 <$> readFiniteFile name) (return \\u2218 inj\\u2081)\\n\"} {\"text\": \"lemma convex_onD_Icc: assumes \\\"convex_on {x..y} f\\\" \\\"x \\\\<le> (y :: _ :: {real_vector,preorder})\\\" shows \\\"\\\\<And>t. t \\\\<ge> 0 \\\\<Longrightarrow> t \\\\<le> 1 \\\\<Longrightarrow> f ((1 - t) *\\\\<^sub>R x + t *\\\\<^sub>R y) \\\\<le> (1 - t) * f x + t * f y\\\"\"} {\"text\": \"import data.real.basic\\n\\ntheorem exo (f: real -> real):\\n (forall x y, f(x^2)-f(y^2)=(x+y)*(f(x)-f(y)))\\n -> (exists m l, forall x, f(x) = m * x + l)\\n:=\\n sorry\\n\"} {\"text\": \"-- Int\\n\\ntheorem Int.n_sub_0 (n: Int): n - 0 = n := by\\n cases n <;> rfl\\n\\ntheorem Int.ge_0_NonNeg (n: Int): n \\u2265 0 \\u2194 Int.NonNeg n := by\\n simp [GE.ge, LE.le, Int.le]\\n simp [Int.n_sub_0]\\n\\ntheorem Int.mul_ge_0 (n m: Int): n \\u2265 0 \\u2192 m \\u2265 0 \\u2192 n * m \\u2265 0 := by\\n rw [Int.ge_0_NonNeg, Int.ge_0_NonNeg, Int.ge_0_NonNeg]\\n intros hn hm;\\n cases hn; cases hm; constructor\\n\\ntheorem Int.mul_comm (n m: Int): n * m = m * n := by\\n sorry\\n\\n-- Nat\\n\\ntheorem Nat.lt_of_add_lt_add_right {a b c: Nat} (h: a + c < b + c):\\n a < b := by\\n sorry\\n\\ntheorem Nat.minus_plus_one {a: Nat} (h: a > 0):\\n a - 1 + 1 = a := by\\n sorry\\n\"} {\"text\": \"(*************************************************************)\\n(* Copyright Dominique Larchey-Wendling [*] *)\\n(* Yannick Forster [+] *)\\n(* *)\\n(* [*] Affiliation LORIA -- CNRS *)\\n(* [+] Affiliation Saarland Univ. *)\\n(*************************************************************)\\n(* This file is distributed under the terms of the *)\\n(* CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT *)\\n(*************************************************************)\\n\\nFrom Undecidability.Shared.Libs.DLW\\n Require Import utils_tac.\\n\\nRequire Import Undecidability.Synthetic.Undecidability.\\nRequire Import Undecidability.Synthetic.ReducibilityFacts.\\n\\nFrom Undecidability.PCP Require Import PCP PCP_undec.\\nFrom Undecidability.StackMachines Require Import BSM.\\nFrom Undecidability.MinskyMachines Require Import MM.\\n\\nFrom Undecidability.ILL \\n Require Import EILL ILL iBPCP_MM MM_EILL EILL_ILL.\\n\\nRequire Import Undecidability.PCP.Reductions.HaltTM_1_to_PCPb.\\n\\nImport ReductionChainNotations UndecidabilityNotations.\\n\\n(* The reduction chain from the CPP 2019, Y. Forster & D. Larchey-Wendling *)\\n\\nTheorem PCP_chain_ILL : \\n \\u23a9 PCP \\u2aaf\\u2098 PCPb \\u2aaf\\u2098 iPCPb \\u2aaf\\u2098 BSM_HALTING \\u2aaf\\u2098 MM_HALTS_ON_ZERO \\u2aaf\\u2098 EILL_PROVABILITY \\u2aaf\\u2098 ILL_PROVABILITY \\u23ad.\\nProof.\\n msplit 5; ( apply PCP_chain_iPCPb || apply iBPCP_chain_MM || idtac).\\n + apply MM_HALTS_ON_ZERO_EILL_PROVABILITY.\\n + apply EILL_ILL_PROVABILITY.\\nQed.\\n\\nCheck PCP_chain_ILL.\\n\\n(* Undecidability results *)\\n\\nLocal Hint Resolve EILL_rILL_cf_PROVABILITY \\n EILL_rILL_PROVABILITY\\n EILL_ILL_cf_PROVABILITY\\n : core.\\n\\n(* EILL provability using G_eill *)\\n\\nTheorem EILL_undec : undecidable EILL_PROVABILITY.\\nProof. undec from PCP_undec using chain PCP_chain_ILL. Qed.\\n\\n(* whole ILL with cut *)\\n\\nTheorem ILL_undec : undecidable ILL_PROVABILITY.\\nProof. undec from PCP_undec using chain PCP_chain_ILL. Qed.\\n\\n(* whole ILL without cut *)\\n\\nTheorem ILL_cf_undec : undecidable ILL_cf_PROVABILITY.\\nProof. undec from EILL_undec; auto. Qed.\\n\\n(* (!,&,-o) fragment of ILL without cut *)\\n\\nTheorem rILL_cf_undec : undecidable rILL_cf_PROVABILITY.\\nProof. undec from EILL_undec; auto. Qed.\\n\\n(* (!,&,-o) fragment of ILL with cut *)\\n\\nTheorem rILL_undec : undecidable rILL_PROVABILITY.\\nProof. undec from EILL_undec; auto. Qed.\\n\"} {\"text\": \"Require Import Coq.ZArith.ZArith.\\nRequire Import Crypto.LegacyArithmetic.Interface.\\nRequire Import Crypto.LegacyArithmetic.Double.Core.\\nRequire Import Crypto.LegacyArithmetic.Double.Proofs.Decode.\\nRequire Import Crypto.LegacyArithmetic.Double.Proofs.ShiftLeftRightTactic.\\nRequire Import Crypto.Util.ZUtil.\\n(*Require Import Crypto.Util.Tactics.*)\\n\\nLocal Open Scope Z_scope.\\n\\nLocal Opaque tuple_decoder.\\nLocal Arguments Z.pow !_ !_.\\nLocal Arguments Z.mul !_ !_.\\n\\nSection shr.\\n Context (n : Z) {W}\\n {ldi : load_immediate W}\\n {shl : shift_left_immediate W}\\n {shr : shift_right_immediate W}\\n {or : bitwise_or W}\\n {decode : decoder n W}\\n {isdecode : is_decode decode}\\n {isldi : is_load_immediate ldi}\\n {isshl : is_shift_left_immediate shl}\\n {isshr : is_shift_right_immediate shr}\\n {isor : is_bitwise_or or}.\\n\\n Global Instance is_shift_right_immediate_double : is_shift_right_immediate (shr_double n).\\n Proof using Type*.\\n intros r count H; hnf in H.\\n assert (0 < 2^count) by auto with zarith.\\n assert (0 < 2^(n+count)) by auto with zarith.\\n assert (forall n', ~n' + count < n -> 2^n <= 2^(n'+count)) by auto with zarith omega.\\n assert (forall n', ~n' + count < n -> 2^n <= 2^(n'+count)) by auto with zarith omega.\\n unfold shr_double; simpl.\\n generalize (decode_range r).\\n pose proof (decode_range (fst r)).\\n pose proof (decode_range (snd r)).\\n assert (forall n', 2^n <= 2^n' -> 0 <= decode (fst r) < 2^n') by (simpl in *; auto with zarith).\\n assert (forall n', n <= n' -> 0 <= decode (fst r) < 2^n') by auto with zarith omega.\\n autorewrite with simpl_tuple_decoder; push_decode.\\n shift_left_right_t.\\n Qed.\\nEnd shr.\\n\"} {\"text\": \"{-# OPTIONS --without-K --rewriting #-}\\n\\nopen import HoTT\\n\\nmodule homotopy.PathSetIsInitalCover {i} (X : Ptd i)\\n -- and an arbitrary covering\\n {k} (\\u2299cov : \\u2299Cover X k) where\\n\\n open Cover\\n\\n private\\n univ-cover = path-set-cover X\\n module \\u2299cov = \\u2299Cover \\u2299cov\\n\\n -- Weak initiality by transport.\\n quotient-cover : CoverHom univ-cover \\u2299cov.cov\\n quotient-cover _ p = cover-trace \\u2299cov.cov \\u2299cov.pt p\\n\\n -- Strong initiality by path induction.\\n module Uniqueness\\n (cover-hom : CoverHom univ-cover \\u2299cov.cov)\\n (pres-pt : cover-hom (pt X) idp\\u2080 == \\u2299cov.pt)\\n where\\n\\n private\\n lemma\\u2081 : \\u2200 a p \\u2192 cover-hom a [ p ] == quotient-cover a [ p ]\\n lemma\\u2081 ._ idp = pres-pt\\n\\n lemma\\u2082 : \\u2200 a p \\u2192 cover-hom a p == quotient-cover a p\\n lemma\\u2082 a = Trunc-elim\\n (\\u03bb p \\u2192 =-preserves-set (\\u2299cov.Fiber-level a))\\n (lemma\\u2081 a)\\n\\n theorem : cover-hom == quotient-cover\\n theorem = \\u03bb= \\u03bb a \\u2192 \\u03bb= $ lemma\\u2082 a\\n\"} {\"text\": \"\\ntheorem Ex006(a b c : Prop): a \\u2228 b \\u2192 a \\u2228 c \\u2192 a \\u2228 (b \\u2227 c) :=\\nassume H1:a \\u2228 b,\\n assume H2:a \\u2228 c,\\n show a \\u2228 (b \\u2227 c), from or.elim H1 \\n ( \\n assume H :a,\\n show a \\u2228 (b \\u2227 c), from or.inl H\\n )\\n (\\n assume H: b,\\n show a \\u2228 (b \\u2227 c), from or.elim H2 \\n (\\n assume HH:a,\\n show a \\u2228 (b \\u2227 c), from or.inl HH\\n )\\n (\\n assume HH:c,\\n have H3:b \\u2227 c, from and.intro H HH,\\n show a \\u2228 (b \\u2227 c), from or.inr H3\\n )\\n ) \\n\"} {\"text\": \"import data.real.basic\\nimport game.Completeness.level04\\nimport game.Completeness.level02\\n\\n\\nnoncomputable theory\\nopen_locale classical\\n\\ndefinition has_lub (S : set \\u211d) := \\u2203 x, is_lub S x\\n\\n--sup(S) - \\u03b5 < s < sup(S)\\n\\n--lemma thinklater (S : set \\u211d) (x y \\u03b5 : \\u211d) (H : has_lub S) (S \\u2260 \\u2205) (hy : is_sup S y) : \\n --\\u2200 \\u03b5 > 0, \\u2203 x \\u2208 S, is_sup S y - \\u03b5 < x \\u2227 x \\u2264 is_sup S y :=\\n\\nlemma do_now {x : \\u211d} {S : set \\u211d} (h : S \\u2260 \\u2205) (Hsup : is_sup S x) : (\\u2200 \\u03b5 > 0, \\u2203 s \\u2208 S, x-\\u03b5<s \\u2227 s \\u2264 x) := \\nbegin\\n \\n\\n rw is_sup at Hsup, \\n cases Hsup with a ha, \\n rw upper_bound at a, \\n\\n intro \\u03b5, intro h, \\n use x, split, swap, \\n\\n split, \\n linarith, linarith,\\n \\n\\n \\n\\n\\n\\n -- rewrite this level cause I am pretty sure it is written incorrectly \\n \\nend\\n\"} {\"text\": \"theorem ex1 (p : Prop) (h1 : p) (h2 : p \\u2192 False) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex2 (p : Prop) (h1 : p) (h2 : \\u00ac p) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex3 (p : Prop) (h1 : id p) (h2 : \\u00ac p) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex4 (p : Prop) (h1 : id p) (h2 : id (Not p)) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex5 (h : x+1 = 0) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex6 (h : 0+0 \\u2260 0) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex7 (x : \\u03b1) (h : Not (x = x)) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex8 (h : 0+0 = 0 \\u2192 False) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex9 (h : 10 = 20) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex10 (h : [] = [1, 2, 3]) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex11 (h : id [] = [1, 2, 3]) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex12 (h : False) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex13 (h : id False) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex14 (h : 100000000 \\u2264 20) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex15 (x : \\u03b1) (h : x = x \\u2192 False) : \\u03b1 := by\\n contradiction\\n\\ntheorem ex16 (xs : List \\u03b1) (h : xs = [] \\u2192 False) : Nonempty \\u03b1 := by\\n cases xs using List.rec with\\n | nil => contradiction\\n | cons x _ => apply Nonempty.intro; assumption\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 OpenAI. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\\n-/\\nimport mathzoo.imports.miniF2F\\n\\nopen_locale nat rat real big_operators topological_space\\n\\ntheorem mathd_algebra_109\\n (a b : \\u211d)\\n (h\\u2080 : 3 * a + 2 * b = 12)\\n (h\\u2081 : a = 4) :\\n b = 0 :=\\nbegin\\n linarith,\\nend\"} {\"text\": \"corollary fps_coeff_residues_bigo: fixes f :: \\\"complex \\\\<Rightarrow> complex\\\" and r :: real assumes \\\"open A\\\" \\\"connected A\\\" \\\"cball 0 r \\\\<subseteq> A\\\" \\\"r > 0\\\" assumes \\\"f holomorphic_on A - S\\\" \\\"S \\\\<subseteq> ball 0 r\\\" \\\"finite S\\\" \\\"0 \\\\<notin> S\\\" assumes g: \\\"eventually (\\\\<lambda>n. g n = -(\\\\<Sum>z\\\\<in>S. residue (\\\\<lambda>z. f z / z ^ Suc n) z)) sequentially\\\" (is \\\"eventually (\\\\<lambda>n. _ = -?g' n) _\\\") shows \\\"(\\\\<lambda>n. (deriv ^^ n) f 0 / fact n - g n) \\\\<in> O(\\\\<lambda>n. 1 / r ^ n)\\\" (is \\\"(\\\\<lambda>n. ?c n - _) \\\\<in> O(_)\\\")\"} {\"text\": \"lemma of_real_add [simp]: \\\"of_real (x + y) = of_real x + of_real y\\\"\"} {\"text\": \"[STATEMENT]\\nlemma of_hypnat_0 [simp]: \\\"of_hypnat 0 = 0\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. of_hypnat 0 = 0\\n[PROOF STEP]\\nby transfer (rule of_nat_0)\"} {\"text\": \"import data.nat.modeq\\n\\n/-\\n(a) Find r with 0 \\u2264 r \\u2264 10 such that 7^137 \\u2261 r mod 11.\\n(b) Find r with 0 \\u2264 r < 645 such that 2^81 \\u2261 r mod 645.\\n(c) Find the last two digits of 3^124 (when expressed in decimal notation).\\n(d) Show that there is a multiple of 21 which has 241 as its last three digits.\\n-/\\n\\nlemma part_a : \\u2203r : \\u2115, 0 \\u2264 r \\u2227 r \\u2264 10 \\u2227 7^137 \\u2261 r [MOD 11] :=\\nbegin\\n use 6,\\n unfold nat.modeq,\\n norm_num,\\nend\\n\\nlemma part_b : \\u2203r : \\u2115, 0 \\u2264 r \\u2227 r < 645 \\u2227 2^81 \\u2261 r [MOD 645] :=\\nbegin\\n use 242,\\n unfold nat.modeq,\\n norm_num,\\nend\\n\\n-- Once you compute the last two digits, change 37 below to them.\\nlemma part_c : 3^124 \\u2261 81 [MOD 100] :=\\nbegin\\n unfold nat.modeq,\\n norm_num,\\nend\\n\\nlemma part_d : \\u2203k : \\u2115, 21 \\u2223 k \\u2227 k \\u2261 241 [MOD 1000] :=\\nbegin\\n unfold nat.modeq,\\n use 17241,\\n split,\\n {norm_num, },\\n {norm_num, },\\nend\"} {\"text\": \"import MyNat.Definition\\nimport MultiplicationWorld.Level6 -- succ_mul\\nimport MyNat.Multiplication -- mul_succ, mul_zero\\nimport AdvancedMultiplicationWorld.Level2 -- eq_zero_or_eq_zero_of_mul_eq_zero\\nnamespace MyNat\\nopen MyNat\\n\\n/-!\\n# Advanced Multiplication World\\n\\n## Level 4: `mul_left_cancel`\\n\\nThis is the last of the bonus multiplication levels. `mul_left_cancel` will be useful in inequality\\nworld.\\n\\nPeople find this level hard. I have probably had more questions about this level than all the other\\nlevels put together, in fact. Many levels in this game can just be solved by \\\"running at it\\\" -- do\\ninduction on one of the variables, keep your head, and you're done. In fact, if you like a\\nchallenge, it might be instructive if you stop reading after the end of this paragraph and try\\nsolving this level now by induction, seeing the trouble you run into, and reading the rest of these\\ncomments afterwards. This level has a sting in the tail. If you are a competent mathematician, try\\nand figure out what is going on. Write down a maths proof of the theorem in this level. Exactly what\\nstatement do you want to prove by induction? It is subtle.\\n\\nOk so here are some spoilers. The problem with naively running at it, is that if you try induction\\non, say, `c`, then you are imagining `a` and `b` as fixed, and your inductive hypothesis `P(c)` is\\n`ab=ac \\u27f9 b=c`. So for your inductive step you will be able to assume `ab=ad \\u27f9 b=d` and your goal\\nwill be to show `ab=a(d+1) \\u27f9 b=d+1`. When you also assume `ab=a(d+1)` you will realize that your\\ninductive hypothesis is *useless*, because `ab=ad` is not true! The statement `P(c)` (with `a` and\\n`b` regarded as constants) is not provable by induction.\\n\\nWhat you *can* prove by induction is the following *stronger* statement. Imagine `a \\u2260 0` as fixed,\\nand then prove \\\"for all `b`, if `ab=ac` then `b=c`\\\" by induction on `c`. This gives us the extra\\nflexibility we require. Note that we are quantifying over all `b` in the inductive hypothesis -- it\\nis essential that `b` is not fixed.\\n\\nYou can do this in two ways in Lean -- before you start the induction you can write `revert b`. The\\n`revert` tactic is the opposite of the `intro` tactic; it replaces the `b` in the hypotheses with\\n\\\"for all `b`\\\" in the goal.\\n\\nAlternatively, you can write `induction c generalizing b with` as the first line of the proof.\\n\\nIf you do not modify your technique in this way, then this level seems\\nto be impossible (judging by the comments I've had about it!)\\n\\n## Theorem\\nIf `a \\u2260 0`, `b` and `c` are natural numbers such that ` ab = ac, ` then `b = c`.\\n-/\\n\\nset_option trace.Meta.Tactic.simp true\\ntheorem mul_left_cancel (a b c : MyNat) (ha : a \\u2260 0) : a * b = a * c \\u2192 b = c := by\\n induction c generalizing b with\\n | zero =>\\n rw [zero_is_0]\\n rw [mul_zero]\\n intro h\\n cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ h) with\\n | inl h1 =>\\n exfalso\\n apply ha\\n assumption\\n | inr h2 =>\\n assumption\\n | succ d hd =>\\n intro hb\\n cases b with\\n | zero =>\\n rw [zero_is_0] at hb\\n rw [mul_zero] at hb\\n rw [zero_is_0]\\n exfalso\\n apply ha\\n have hb := hb.symm\\n cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ hb) with\\n | inl h =>\\n exact h\\n | inr h =>\\n exfalso\\n exact succ_ne_zero _ h\\n | succ c =>\\n have h := c = d\\n apply hd\\n rw [mul_succ] at hb\\n rw [mul_succ] at hb\\n apply add_right_cancel _ _ _ hb\\n rw [h]\\n\\n/-!\\nYou should now be ready for [Inequality World](../InequalityWorld.lean.md).\\n\\n\\n-/\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Heather Macbeth\\n-/\\n\\nimport measure_theory.measure.regular\\nimport measure_theory.function.simple_func_dense\\nimport topology.urysohns_lemma\\n\\n/-!\\n# Approximation in L\\u1d56 by continuous functions\\n\\nThis file proves that bounded continuous functions are dense in `Lp E p \\u03bc`, for `1 \\u2264 p < \\u221e`, if the\\ndomain `\\u03b1` of the functions is a normal topological space and the measure `\\u03bc` is weakly regular.\\n\\nThe result is presented in several versions:\\n* `measure_theory.Lp.bounded_continuous_function_dense`: The subgroup\\n `measure_theory.Lp.bounded_continuous_function` of `Lp E p \\u03bc`, the additive subgroup of\\n `Lp E p \\u03bc` consisting of equivalence classes containing a continuous representative, is dense in\\n `Lp E p \\u03bc`.\\n* `bounded_continuous_function.to_Lp_dense_range`: For finite-measure `\\u03bc`, the continuous linear\\n map `bounded_continuous_function.to_Lp p \\u03bc \\ud835\\udd5c` from `\\u03b1 \\u2192\\u1d47 E` to `Lp E p \\u03bc` has dense range.\\n* `continuous_map.to_Lp_dense_range`: For compact `\\u03b1` and finite-measure `\\u03bc`, the continuous linear\\n map `continuous_map.to_Lp p \\u03bc \\ud835\\udd5c` from `C(\\u03b1, E)` to `Lp E p \\u03bc` has dense range.\\n\\nNote that for `p = \\u221e` this result is not true: the characteristic function of the set `[0, \\u221e)` in\\n`\\u211d` cannot be continuously approximated in `L\\u221e`.\\n\\nThe proof is in three steps. First, since simple functions are dense in `Lp`, it suffices to prove\\nthe result for a scalar multiple of a characteristic function of a measurable set `s`. Secondly,\\nsince the measure `\\u03bc` is weakly regular, the set `s` can be approximated above by an open set and\\nbelow by a closed set. Finally, since the domain `\\u03b1` is normal, we use Urysohn's lemma to find a\\ncontinuous function interpolating between these two sets.\\n\\n## Related results\\n\\nAre you looking for a result on \\\"directional\\\" approximation (above or below with respect to an\\norder) of functions whose codomain is `\\u211d\\u22650\\u221e` or `\\u211d`, by semicontinuous functions? See the\\nVitali-Carath\\u00e9odory theorem, in the file `measure_theory.vitali_caratheodory`.\\n\\n-/\\n\\nopen_locale ennreal nnreal topological_space bounded_continuous_function\\nopen measure_theory topological_space continuous_map\\n\\nvariables {\\u03b1 : Type*} [measurable_space \\u03b1] [topological_space \\u03b1] [normal_space \\u03b1] [borel_space \\u03b1]\\nvariables (E : Type*) [measurable_space E] [normed_group E] [borel_space E]\\n [second_countable_topology E]\\nvariables {p : \\u211d\\u22650\\u221e} [_i : fact (1 \\u2264 p)] (hp : p \\u2260 \\u221e) (\\u03bc : measure \\u03b1)\\n\\ninclude _i hp\\n\\nnamespace measure_theory.Lp\\n\\nvariables [normed_space \\u211d E]\\n\\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\\nlemma bounded_continuous_function_dense [\\u03bc.weakly_regular] :\\n (bounded_continuous_function E p \\u03bc).topological_closure = \\u22a4 :=\\nbegin\\n have hp\\u2080 : 0 < p := lt_of_lt_of_le ennreal.zero_lt_one _i.elim,\\n have hp\\u2080' : 0 \\u2264 1 / p.to_real := div_nonneg zero_le_one ennreal.to_real_nonneg,\\n have hp\\u2080'' : 0 < p.to_real,\\n { simpa [\\u2190 ennreal.to_real_lt_to_real ennreal.zero_ne_top hp] using hp\\u2080 },\\n -- It suffices to prove that scalar multiples of the indicator function of a finite-measure\\n -- measurable set can be approximated by continuous functions\\n suffices : \\u2200 (c : E) {s : set \\u03b1} (hs : measurable_set s) (h\\u03bcs : \\u03bc s < \\u22a4),\\n (Lp.simple_func.indicator_const p hs h\\u03bcs.ne c : Lp E p \\u03bc)\\n \\u2208 (bounded_continuous_function E p \\u03bc).topological_closure,\\n { rw add_subgroup.eq_top_iff',\\n refine Lp.induction hp _ _ _ _,\\n { exact this },\\n { exact \\u03bb f g hf hg hfg', add_subgroup.add_mem _ },\\n { exact add_subgroup.is_closed_topological_closure _ } },\\n -- Let `s` be a finite-measure measurable set, let's approximate `c` times its indicator function\\n intros c s hs hs\\u03bc,\\n refine mem_closure_iff_frequently.mpr _,\\n rw metric.nhds_basis_closed_ball.frequently_iff,\\n intros \\u03b5 h\\u03b5,\\n -- A little bit of pre-emptive work, to find `\\u03b7 : \\u211d\\u22650` which will be a margin small enough for\\n -- our purposes\\n obtain \\u27e8\\u03b7, h\\u03b7_pos, h\\u03b7_le\\u27e9 : \\u2203 \\u03b7, 0 < \\u03b7 \\u2227 (\\u2191(\\u2225bit0 (\\u2225c\\u2225)\\u2225\\u208a * (2 * \\u03b7) ^ (1 / p.to_real)) : \\u211d) \\u2264 \\u03b5,\\n { have : filter.tendsto (\\u03bb x : \\u211d\\u22650, \\u2225bit0 (\\u2225c\\u2225)\\u2225\\u208a * (2 * x) ^ (1 / p.to_real)) (\\ud835\\udcdd 0) (\\ud835\\udcdd 0),\\n { have : filter.tendsto (\\u03bb x : \\u211d\\u22650, 2 * x) (\\ud835\\udcdd 0) (\\ud835\\udcdd (2 * 0)) := filter.tendsto_id.const_mul 2,\\n convert ((nnreal.continuous_at_rpow_const (or.inr hp\\u2080')).tendsto.comp this).const_mul _,\\n simp [hp\\u2080''.ne'] },\\n let \\u03b5' : \\u211d\\u22650 := \\u27e8\\u03b5, h\\u03b5.le\\u27e9,\\n have h\\u03b5' : 0 < \\u03b5' := by exact_mod_cast h\\u03b5,\\n obtain \\u27e8\\u03b4, h\\u03b4, h\\u03b4\\u03b5'\\u27e9 :=\\n nnreal.nhds_zero_basis.eventually_iff.mp (eventually_le_of_tendsto_lt h\\u03b5' this),\\n obtain \\u27e8\\u03b7, h\\u03b7, h\\u03b7\\u03b4\\u27e9 := exists_between h\\u03b4,\\n refine \\u27e8\\u03b7, h\\u03b7, _\\u27e9,\\n exact_mod_cast h\\u03b4\\u03b5' h\\u03b7\\u03b4 },\\n have h\\u03b7_pos' : (0 : \\u211d\\u22650\\u221e) < \\u03b7 := ennreal.coe_pos.2 h\\u03b7_pos,\\n -- Use the regularity of the measure to `\\u03b7`-approximate `s` by an open superset and a closed\\n -- subset\\n obtain \\u27e8u, su, u_open, \\u03bcu\\u27e9 : \\u2203 u \\u2287 s, is_open u \\u2227 \\u03bc u < \\u03bc s + \\u2191\\u03b7,\\n { refine s.exists_is_open_lt_of_lt _ _,\\n simpa using ennreal.add_lt_add_left hs\\u03bc.ne h\\u03b7_pos' },\\n obtain \\u27e8F, Fs, F_closed, \\u03bcF\\u27e9 : \\u2203 F \\u2286 s, is_closed F \\u2227 \\u03bc s < \\u03bc F + \\u2191\\u03b7 :=\\n hs.exists_is_closed_lt_add hs\\u03bc.ne h\\u03b7_pos'.ne',\\n have : disjoint u\\u1d9c F,\\n { rw [set.disjoint_iff_inter_eq_empty, set.inter_comm, \\u2190 set.subset_compl_iff_disjoint],\\n simpa using Fs.trans su },\\n have h_\\u03bc_sdiff : \\u03bc (u \\\\ F) \\u2264 2 * \\u03b7,\\n { have hF\\u03bc : \\u03bc F < \\u22a4 := (measure_mono Fs).trans_lt hs\\u03bc,\\n refine ennreal.le_of_add_le_add_left hF\\u03bc.ne _,\\n have : \\u03bc u < \\u03bc F + \\u2191\\u03b7 + \\u2191\\u03b7,\\n from \\u03bcu.trans (ennreal.add_lt_add_right ennreal.coe_ne_top \\u03bcF),\\n convert this.le using 1,\\n { rw [add_comm, \\u2190 measure_union, set.diff_union_of_subset (Fs.trans su)],\\n { exact disjoint_sdiff_self_left },\\n { exact (u_open.sdiff F_closed).measurable_set },\\n { exact F_closed.measurable_set } },\\n have : (2:\\u211d\\u22650\\u221e) * \\u03b7 = \\u03b7 + \\u03b7 := by simpa using add_mul (1:\\u211d\\u22650\\u221e) 1 \\u03b7,\\n rw this,\\n abel },\\n -- Apply Urysohn's lemma to get a continuous approximation to the characteristic function of\\n -- the set `s`\\n obtain \\u27e8g, hgu, hgF, hg_range\\u27e9 :=\\n exists_continuous_zero_one_of_closed u_open.is_closed_compl F_closed this,\\n -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\\n -- that this is pointwise bounded by the indicator of the set `u \\\\ F`\\n have g_norm : \\u2200 x, \\u2225g x\\u2225 = g x := \\u03bb x, by rw [real.norm_eq_abs, abs_of_nonneg (hg_range x).1],\\n have gc_bd : \\u2200 x, \\u2225g x \\u2022 c - s.indicator (\\u03bb x, c) x\\u2225 \\u2264 \\u2225(u \\\\ F).indicator (\\u03bb x, bit0 \\u2225c\\u2225) x\\u2225,\\n { intros x,\\n by_cases hu : x \\u2208 u,\\n { rw \\u2190 set.diff_union_of_subset (Fs.trans su) at hu,\\n cases hu with hFu hF,\\n { refine (norm_sub_le _ _).trans _,\\n refine (add_le_add_left (norm_indicator_le_norm_self (\\u03bb x, c) x) _).trans _,\\n have h\\u2080 : g x * \\u2225c\\u2225 + \\u2225c\\u2225 \\u2264 2 * \\u2225c\\u2225,\\n { nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c] },\\n have h\\u2081 : (2:\\u211d) * \\u2225c\\u2225 = bit0 (\\u2225c\\u2225) := by simpa using add_mul (1:\\u211d) 1 (\\u2225c\\u2225),\\n simp [hFu, norm_smul, h\\u2080, \\u2190 h\\u2081, g_norm x] },\\n { simp [hgF hF, Fs hF] } },\\n { have : x \\u2209 s := \\u03bb h, hu (su h),\\n simp [hgu hu, this] } },\\n -- The rest is basically just `ennreal`-arithmetic\\n have gc_snorm : snorm ((\\u03bb x, g x \\u2022 c) - s.indicator (\\u03bb x, c)) p \\u03bc\\n \\u2264 (\\u2191(\\u2225bit0 (\\u2225c\\u2225)\\u2225\\u208a * (2 * \\u03b7) ^ (1 / p.to_real)) : \\u211d\\u22650\\u221e),\\n { refine (snorm_mono_ae (filter.eventually_of_forall gc_bd)).trans _,\\n rw snorm_indicator_const (u_open.sdiff F_closed).measurable_set hp\\u2080.ne' hp,\\n push_cast [\\u2190 ennreal.coe_rpow_of_nonneg _ hp\\u2080'],\\n exact ennreal.mul_left_mono (ennreal.rpow_left_monotone_of_nonneg hp\\u2080' h_\\u03bc_sdiff) },\\n have gc_cont : continuous (\\u03bb x, g x \\u2022 c) := g.continuous.smul continuous_const,\\n have gc_mem_\\u2112p : mem_\\u2112p (\\u03bb x, g x \\u2022 c) p \\u03bc,\\n { have : mem_\\u2112p ((\\u03bb x, g x \\u2022 c) - s.indicator (\\u03bb x, c)) p \\u03bc :=\\n \\u27e8(gc_cont.ae_measurable \\u03bc).sub (measurable_const.indicator hs).ae_measurable,\\n gc_snorm.trans_lt ennreal.coe_lt_top\\u27e9,\\n simpa using this.add (mem_\\u2112p_indicator_const p hs c (or.inr hs\\u03bc.ne)) },\\n refine \\u27e8gc_mem_\\u2112p.to_Lp _, _, _\\u27e9,\\n { rw mem_closed_ball_iff_norm,\\n refine le_trans _ h\\u03b7_le,\\n rw [simple_func.coe_indicator_const, indicator_const_Lp, \\u2190 mem_\\u2112p.to_Lp_sub, Lp.norm_to_Lp],\\n exact ennreal.to_real_le_coe_of_le_coe gc_snorm },\\n { rw [set_like.mem_coe, mem_bounded_continuous_function_iff],\\n refine \\u27e8bounded_continuous_function.of_normed_group _ gc_cont (\\u2225c\\u2225) _, rfl\\u27e9,\\n intros x,\\n have h\\u2080 : g x * \\u2225c\\u2225 \\u2264 \\u2225c\\u2225,\\n { nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c] },\\n simp [norm_smul, g_norm x, h\\u2080] },\\nend\\n\\nend measure_theory.Lp\\n\\nvariables (\\ud835\\udd5c : Type*) [measurable_space \\ud835\\udd5c] [normed_field \\ud835\\udd5c] [opens_measurable_space \\ud835\\udd5c]\\n [normed_algebra \\u211d \\ud835\\udd5c] [normed_space \\ud835\\udd5c E]\\n\\nnamespace bounded_continuous_function\\n\\nlemma to_Lp_dense_range [\\u03bc.weakly_regular] [is_finite_measure \\u03bc] :\\n dense_range \\u21d1(to_Lp p \\u03bc \\ud835\\udd5c : (\\u03b1 \\u2192\\u1d47 E) \\u2192L[\\ud835\\udd5c] Lp E p \\u03bc) :=\\nbegin\\n haveI : normed_space \\u211d E := restrict_scalars.normed_space \\u211d \\ud835\\udd5c E,\\n rw dense_range_iff_closure_range,\\n suffices : (to_Lp p \\u03bc \\ud835\\udd5c : _ \\u2192L[\\ud835\\udd5c] Lp E p \\u03bc).range.to_add_subgroup.topological_closure = \\u22a4,\\n { exact congr_arg coe this },\\n simp [range_to_Lp p \\u03bc, measure_theory.Lp.bounded_continuous_function_dense E hp],\\nend\\n\\nend bounded_continuous_function\\n\\nnamespace continuous_map\\n\\nlemma to_Lp_dense_range [compact_space \\u03b1] [\\u03bc.weakly_regular] [is_finite_measure \\u03bc] :\\n dense_range \\u21d1(to_Lp p \\u03bc \\ud835\\udd5c : C(\\u03b1, E) \\u2192L[\\ud835\\udd5c] Lp E p \\u03bc) :=\\nbegin\\n haveI : normed_space \\u211d E := restrict_scalars.normed_space \\u211d \\ud835\\udd5c E,\\n rw dense_range_iff_closure_range,\\n suffices : (to_Lp p \\u03bc \\ud835\\udd5c : _ \\u2192L[\\ud835\\udd5c] Lp E p \\u03bc).range.to_add_subgroup.topological_closure = \\u22a4,\\n { exact congr_arg coe this },\\n simp [range_to_Lp p \\u03bc, measure_theory.Lp.bounded_continuous_function_dense E hp]\\nend\\n\\nend continuous_map\\n\"} {\"text\": \"import topology.basic\\nimport data.real.nnreal\\nimport data.real.basic\\n\\nopen set\\n\\ntheorem open_set_for_each \\n (X : Type*)\\n [topological_space X]\\n (A : set X) \\n (h\\u2080 : \\u2200 x \\u2208 A, \\u2203 (U : set X), is_open U \\u2227 x \\u2208 U \\u2227 U \\u2286 A) : \\n is_open A :=\\nbegin\\n choose! f hf using h\\u2080,\\n have : A = \\u22c3 x \\u2208 A, f x,\\n {\\n ext p,\\n split, \\n {\\n intro hp,\\n have hfp := hf p hp,\\n rw mem_Union\\u2082,\\n use p,\\n exact \\u27e8 hp, hfp.2.1 \\u27e9,\\n },\\n {\\n intro hp,\\n rw mem_Union\\u2082 at hp,\\n cases hp with i hi,\\n cases hi with hia hpfi,\\n have x := hf i hia,\\n exact x.2.2 hpfi,\\n }\\n },\\n rw this,\\n apply is_open_bUnion,\\n intros i hi,\\n exact (hf i hi).1,\\nend \\n\\n\\n\\ndef intersection_of_topologies {X : Type*} {\\u03b9 : Sort*}\\n (f : \\u03b9 \\u2192 topological_space X) : topological_space X :=\\n{ is_open := \\u03bb s, \\u2200 i, (f i).is_open s,\\n is_open_univ := \\n begin\\n sorry\\n end,\\n is_open_inter := \\n begin\\n intros s t hos hot i,\\n specialize hos i,\\n specialize hot i,\\n exact (f i).is_open_inter s t hos hot,\\n end,\\n is_open_sUnion := sorry }\"} {\"text\": \"/-\\nCopyright 2020 Google LLC\\n\\nLicensed under the Apache License, Version 2.0 (the \\\"License\\\");\\nyou may not use this file except in compliance with the License.\\nYou may obtain a copy of the License at\\n\\n http://www.apache.org/licenses/LICENSE-2.0\\n\\nUnless required by applicable law or agreed to in writing, software\\ndistributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\nSee the License for the specific language governing permissions and\\nlimitations under the License.\\n -/\\nimport measure_theory.measurable_space\\n\\nimport measure_theory.measure_space\\nimport measure_theory.outer_measure\\nimport measure_theory.lebesgue_measure\\nimport measure_theory.integration\\nimport measure_theory.set_integral\\nimport measure_theory.borel_space\\nimport data.set.countable\\nimport formal_ml.nnreal\\nimport formal_ml.sum\\nimport formal_ml.core\\nimport formal_ml.measurable_space\\nimport formal_ml.semiring\\nimport formal_ml.real_measurable_space\\nimport formal_ml.set\\nimport formal_ml.filter_util\\nimport topology.instances.ennreal\\nimport formal_ml.int\\nimport formal_ml.with_density_compose_eq_multiply\\nimport formal_ml.classical\\n\\n\\nlemma with_density_le_with_density {\\u03a9:Type*} {M:measurable_space \\u03a9}\\n {\\u03bc:measure_theory.measure \\u03a9} {x y:\\u03a9 \\u2192 ennreal} \\n {S:set \\u03a9}:\\n measurable_set S \\u2192\\n (\\u2200 \\u03c9 \\u2208 S, x \\u03c9 \\u2264 y \\u03c9) \\u2192 \\n \\u03bc.with_density x S \\u2264 \\u03bc.with_density y S :=\\nbegin\\n intros A3 A4,\\n rw measure_theory.with_density_apply2' \\u03bc x S A3,\\n rw measure_theory.with_density_apply2' \\u03bc y S A3,\\n apply measure_theory.lintegral_mono,\\n\\n rw le_func_def2,\\n intros \\u03c9,\\n cases (classical.em (\\u03c9 \\u2208 S)) with A5 A5,\\n {\\n rw set.indicator_of_mem A5,\\n rw set.indicator_of_mem A5,\\n apply A4 _ A5,\\n },\\n {\\n rw set.indicator_of_not_mem A5,\\n rw set.indicator_of_not_mem A5,\\n apply le_refl _,\\n },\\nend\\n\\n\\n--TODO: Remove measurability?\\nlemma with_density_sup_of_le {\\u03a9:Type*} {M:measurable_space \\u03a9}\\n {\\u03bc:measure_theory.measure \\u03a9} {x y:\\u03a9 \\u2192 ennreal} \\n {S:set \\u03a9}:measurable x \\u2192 measurable y \\u2192\\n measurable_set S \\u2192\\n (\\u2200 \\u03c9 \\u2208 S, x \\u03c9 \\u2264 y \\u03c9) \\u2192 \\n \\u03bc.with_density (x\\u2294y) S = \\u03bc.with_density y S :=\\nbegin\\n intros A1 A2 A3 A4,\\n rw measure_theory.with_density_apply2' \\u03bc (x \\u2294 y) S A3,\\n rw measure_theory.with_density_apply2' \\u03bc y S A3,\\n have A5:set.indicator S (x \\u2294 y) = set.indicator S y,\\n {\\n apply funext,\\n intro \\u03c9,\\n cases (classical.em (\\u03c9\\u2208 S)) with A5A A5A,\\n {\\n rw set.indicator_of_mem A5A,\\n rw set.indicator_of_mem A5A,\\n rw sup_apply,\\n simp [A4 _ A5A],\\n },\\n {\\n rw set.indicator_of_not_mem A5A,\\n rw set.indicator_of_not_mem A5A,\\n },\\n },\\n rw A5,\\nend\\n\\n\\nlemma measure_theory.measure.sup_le_apply {\\u03a9:Type*}\\n {M:measurable_space \\u03a9}\\n {\\u03bc \\u03bd m:measure_theory.measure \\u03a9}\\n {S:set \\u03a9}:measurable_set S \\u2192\\n (\\u03bc \\u2264 m) \\u2192\\n (\\u03bd \\u2264 m) \\u2192 \\n (\\u03bc \\u2294 \\u03bd) S \\u2264 m S :=\\nbegin\\n intros A1 A2 A3,\\n have A4:\\u03bc \\u2294 \\u03bd \\u2264 m := \\n @sup_le (measure_theory.measure \\u03a9) _ \\u03bc \\u03bd m A2 A3,\\n apply A4,\\n apply A1,\\nend\\n\"} {\"text\": \"[STATEMENT]\\nlemma dbproj_Cons:\\n \\\"dbproj i ((i,d)#D) = (i,d)#dbproj i D\\\"\\n \\\"i \\\\<noteq> j \\\\<Longrightarrow> dbproj j ((i,d)#D) = dbproj j D\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. dbproj i ((i, d) # D) = (i, d) # dbproj i D &&& (i \\\\<noteq> j \\\\<Longrightarrow> dbproj j ((i, d) # D) = dbproj j D)\\n[PROOF STEP]\\nunfolding dbproj_def\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. filter (\\\\<lambda>d. fst d = i) ((i, d) # D) = (i, d) # filter (\\\\<lambda>d. fst d = i) D &&& (i \\\\<noteq> j \\\\<Longrightarrow> filter (\\\\<lambda>d. fst d = j) ((i, d) # D) = filter (\\\\<lambda>d. fst d = j) D)\\n[PROOF STEP]\\nby auto\"} {\"text\": \"/-\\nCopyright (c) 2015 Jeremy Avigad. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Jeremy Avigad, Robert Y. Lewis\\n-/\\nimport algebra.group_power.basic\\nimport algebra.invertible\\nimport algebra.opposites\\nimport data.list.basic\\nimport data.int.cast\\nimport data.equiv.basic\\nimport data.equiv.mul_add\\nimport deprecated.group\\n\\n/-!\\n# Lemmas about power operations on monoids and groups\\n\\nThis file contains lemmas about `monoid.pow`, `group.pow`, `nsmul`, `gsmul`\\nwhich require additional imports besides those available in `.basic`.\\n-/\\n\\nuniverses u v w x y z u\\u2081 u\\u2082\\n\\nvariables {M : Type u} {N : Type v} {G : Type w} {H : Type x} {A : Type y} {B : Type z}\\n {R : Type u\\u2081} {S : Type u\\u2082}\\n\\n/-!\\n### (Additive) monoid\\n-/\\nsection monoid\\nvariables [monoid M] [monoid N] [add_monoid A] [add_monoid B]\\n\\n@[simp] theorem nsmul_one [has_one A] : \\u2200 n : \\u2115, n \\u2022 (1 : A) = n :=\\nadd_monoid_hom.eq_nat_cast\\n \\u27e8\\u03bb n, n \\u2022 (1 : A), zero_nsmul _, \\u03bb _ _, add_nsmul _ _ _\\u27e9\\n (one_nsmul _)\\n\\n@[simp, priority 500]\\ntheorem list.prod_repeat (a : M) (n : \\u2115) : (list.repeat a n).prod = a ^ n :=\\nbegin\\n induction n with n ih,\\n { rw pow_zero, refl },\\n { rw [list.repeat_succ, list.prod_cons, ih, pow_succ] }\\nend\\n\\n@[simp, priority 500]\\ntheorem list.sum_repeat : \\u2200 (a : A) (n : \\u2115), (list.repeat a n).sum = n \\u2022 a :=\\n@list.prod_repeat (multiplicative A) _\\n\\n@[simp, norm_cast] lemma units.coe_pow (u : units M) (n : \\u2115) : ((u ^ n : units M) : M) = u ^ n :=\\n(units.coe_hom M).map_pow u n\\n\\ninstance invertible_pow (m : M) [invertible m] (n : \\u2115) : invertible (m ^ n) :=\\n{ inv_of := \\u215f m ^ n,\\n inv_of_mul_self := by rw [\\u2190 (commute_inv_of m).symm.mul_pow, inv_of_mul_self, one_pow],\\n mul_inv_of_self := by rw [\\u2190 (commute_inv_of m).mul_pow, mul_inv_of_self, one_pow] }\\n\\nlemma inv_of_pow (m : M) [invertible m] (n : \\u2115) [invertible (m ^ n)] :\\n \\u215f(m ^ n) = \\u215fm ^ n :=\\n@invertible_unique M _ (m ^ n) (m ^ n) rfl \\u2039_\\u203a (invertible_pow m n)\\n\\nlemma is_unit.pow {m : M} (n : \\u2115) : is_unit m \\u2192 is_unit (m ^ n) :=\\n\\u03bb \\u27e8u, hu\\u27e9, \\u27e8u ^ n, by simp *\\u27e9\\n\\n/-- If `x ^ n.succ = 1` then `x` has an inverse, `x^n`. -/\\ndef invertible_of_pow_succ_eq_one (x : M) (n : \\u2115) (hx : x ^ n.succ = 1) :\\n invertible x :=\\n\\u27e8x ^ n, (pow_succ' x n).symm.trans hx, (pow_succ x n).symm.trans hx\\u27e9\\n\\n/-- If `x ^ n = 1` then `x` has an inverse, `x^(n - 1)`. -/\\ndef invertible_of_pow_eq_one (x : M) (n : \\u2115) (hx : x ^ n = 1) (hn : 0 < n) :\\n invertible x :=\\nbegin\\n apply invertible_of_pow_succ_eq_one x (n - 1),\\n convert hx,\\n exact nat.sub_add_cancel (nat.succ_le_of_lt hn),\\nend\\n\\nlemma is_unit_of_pow_eq_one (x : M) (n : \\u2115) (hx : x ^ n = 1) (hn : 0 < n) :\\n is_unit x :=\\nbegin\\n haveI := invertible_of_pow_eq_one x n hx hn,\\n exact is_unit_of_invertible x\\nend\\n\\nend monoid\\n\\ntheorem nat.nsmul_eq_mul (m n : \\u2115) : m \\u2022 n = m * n :=\\nby induction m with m ih; [rw [zero_nsmul, zero_mul],\\n rw [succ_nsmul', ih, nat.succ_mul]]\\n\\nsection group\\nvariables [group G] [group H] [add_group A] [add_group B]\\n\\nopen int\\n\\nlocal attribute [ematch] le_of_lt\\nopen nat\\n\\ntheorem gsmul_one [has_one A] (n : \\u2124) : n \\u2022 (1 : A) = n :=\\nby cases n; simp\\n\\nlemma gpow_add_one (a : G) : \\u2200 n : \\u2124, a ^ (n + 1) = a ^ n * a\\n| (of_nat n) := by simp [\\u2190 int.coe_nat_succ, pow_succ']\\n| -[1+0] := by simp [int.neg_succ_of_nat_eq]\\n| -[1+(n+1)] := by rw [int.neg_succ_of_nat_eq, gpow_neg, neg_add, neg_add_cancel_right, gpow_neg,\\n \\u2190 int.coe_nat_succ, gpow_coe_nat, gpow_coe_nat, pow_succ _ (n + 1), mul_inv_rev,\\n inv_mul_cancel_right]\\n\\ntheorem add_one_gsmul : \\u2200 (a : A) (i : \\u2124), (i + 1) \\u2022 a = i \\u2022 a + a :=\\n@gpow_add_one (multiplicative A) _\\n\\nlemma gpow_sub_one (a : G) (n : \\u2124) : a ^ (n - 1) = a ^ n * a\\u207b\\u00b9 :=\\ncalc a ^ (n - 1) = a ^ (n - 1) * a * a\\u207b\\u00b9 : (mul_inv_cancel_right _ _).symm\\n ... = a^n * a\\u207b\\u00b9 : by rw [\\u2190 gpow_add_one, sub_add_cancel]\\n\\nlemma gpow_add (a : G) (m n : \\u2124) : a ^ (m + n) = a ^ m * a ^ n :=\\nbegin\\n induction n using int.induction_on with n ihn n ihn,\\n case hz : { simp },\\n { simp only [\\u2190 add_assoc, gpow_add_one, ihn, mul_assoc] },\\n { rw [gpow_sub_one, \\u2190 mul_assoc, \\u2190 ihn, \\u2190 gpow_sub_one, add_sub_assoc] }\\nend\\n\\nlemma mul_self_gpow (b : G) (m : \\u2124) : b*b^m = b^(m+1) :=\\nby { conv_lhs {congr, rw \\u2190 gpow_one b }, rw [\\u2190 gpow_add, add_comm] }\\n\\nlemma mul_gpow_self (b : G) (m : \\u2124) : b^m*b = b^(m+1) :=\\nby { conv_lhs {congr, skip, rw \\u2190 gpow_one b }, rw [\\u2190 gpow_add, add_comm] }\\n\\ntheorem add_gsmul : \\u2200 (a : A) (i j : \\u2124), (i + j) \\u2022 a = i \\u2022 a + j \\u2022 a :=\\n@gpow_add (multiplicative A) _\\n\\nlemma gpow_sub (a : G) (m n : \\u2124) : a ^ (m - n) = a ^ m * (a ^ n)\\u207b\\u00b9 :=\\nby rw [sub_eq_add_neg, gpow_add, gpow_neg]\\n\\nlemma sub_gsmul (m n : \\u2124) (a : A) : (m - n) \\u2022 a = m \\u2022 a - n \\u2022 a :=\\nby simpa only [sub_eq_add_neg] using @gpow_sub (multiplicative A) _ _ _ _\\n\\ntheorem gpow_one_add (a : G) (i : \\u2124) : a ^ (1 + i) = a * a ^ i :=\\nby rw [gpow_add, gpow_one]\\n\\ntheorem one_add_gsmul : \\u2200 (a : A) (i : \\u2124), (1 + i) \\u2022 a = a + i \\u2022 a :=\\n@gpow_one_add (multiplicative A) _\\n\\ntheorem gpow_mul_comm (a : G) (i j : \\u2124) : a ^ i * a ^ j = a ^ j * a ^ i :=\\nby rw [\\u2190 gpow_add, \\u2190 gpow_add, add_comm]\\n\\ntheorem gsmul_add_comm : \\u2200 (a : A) (i j : \\u2124), i \\u2022 a + j \\u2022 a = j \\u2022 a + i \\u2022 a :=\\n@gpow_mul_comm (multiplicative A) _\\n\\ntheorem gpow_mul (a : G) (m n : \\u2124) : a ^ (m * n) = (a ^ m) ^ n :=\\nint.induction_on n (by simp) (\\u03bb n ihn, by simp [mul_add, gpow_add, ihn])\\n (\\u03bb n ihn, by simp only [mul_sub, gpow_sub, ihn, mul_one, gpow_one])\\n\\ntheorem gsmul_mul' : \\u2200 (a : A) (m n : \\u2124), (m * n) \\u2022 a = n \\u2022 (m \\u2022 a) :=\\n@gpow_mul (multiplicative A) _\\n\\ntheorem gpow_mul' (a : G) (m n : \\u2124) : a ^ (m * n) = (a ^ n) ^ m :=\\nby rw [mul_comm, gpow_mul]\\n\\ntheorem mul_gsmul (a : A) (m n : \\u2124) : (m * n) \\u2022 a = m \\u2022 (n \\u2022 a) :=\\nby rw [mul_comm, gsmul_mul']\\n\\ntheorem gpow_bit0 (a : G) (n : \\u2124) : a ^ bit0 n = a ^ n * a ^ n := gpow_add _ _ _\\n\\ntheorem bit0_gsmul (a : A) (n : \\u2124) : bit0 n \\u2022 a = n \\u2022 a + n \\u2022 a :=\\n@gpow_bit0 (multiplicative A) _ _ _\\n\\ntheorem gpow_bit1 (a : G) (n : \\u2124) : a ^ bit1 n = a ^ n * a ^ n * a :=\\nby rw [bit1, gpow_add, gpow_bit0, gpow_one]\\n\\ntheorem bit1_gsmul : \\u2200 (a : A) (n : \\u2124), bit1 n \\u2022 a = n \\u2022 a + n \\u2022 a + a :=\\n@gpow_bit1 (multiplicative A) _\\n\\n@[simp] theorem monoid_hom.map_gpow (f : G \\u2192* H) (a : G) (n : \\u2124) : f (a ^ n) = f a ^ n :=\\nby cases n; simp\\n\\n@[simp] theorem add_monoid_hom.map_gsmul (f : A \\u2192+ B) (a : A) (n : \\u2124) : f (n \\u2022 a) = n \\u2022 f a :=\\nf.to_multiplicative.map_gpow a n\\n\\n@[simp, norm_cast] lemma units.coe_gpow (u : units G) (n : \\u2124) : ((u ^ n : units G) : G) = u ^ n :=\\n(units.coe_hom G).map_gpow u n\\n\\nend group\\n\\nsection ordered_add_comm_group\\n\\nvariables [ordered_add_comm_group A]\\n/-! Lemmas about `gsmul` under ordering, placed here (rather than in `algebra.group_power.order`\\nwith their friends) because they require facts from `data.int.basic`-/\\nopen int\\n\\nlemma gsmul_pos {a : A} (ha : 0 < a) {k : \\u2124} (hk : (0:\\u2124) < k) : 0 < k \\u2022 a :=\\nbegin\\n lift k to \\u2115 using int.le_of_lt hk,\\n rw gsmul_coe_nat,\\n apply nsmul_pos ha,\\n exact coe_nat_pos.mp hk,\\nend\\n\\ntheorem gsmul_le_gsmul {a : A} {n m : \\u2124} (ha : 0 \\u2264 a) (h : n \\u2264 m) : n \\u2022 a \\u2264 m \\u2022 a :=\\ncalc n \\u2022 a = n \\u2022 a + 0 : (add_zero _).symm\\n ... \\u2264 n \\u2022 a + (m - n) \\u2022 a : add_le_add_left (gsmul_nonneg ha (sub_nonneg.mpr h)) _\\n ... = m \\u2022 a : by { rw [\\u2190 add_gsmul], simp }\\n\\ntheorem gsmul_lt_gsmul {a : A} {n m : \\u2124} (ha : 0 < a) (h : n < m) : n \\u2022 a < m \\u2022 a :=\\ncalc n \\u2022 a = n \\u2022 a + 0 : (add_zero _).symm\\n ... < n \\u2022 a + (m - n) \\u2022 a : add_lt_add_left (gsmul_pos ha (sub_pos.mpr h)) _\\n ... = m \\u2022 a : by { rw [\\u2190 add_gsmul], simp }\\n\\nlemma abs_nsmul {\\u03b1 : Type*} [linear_ordered_add_comm_group \\u03b1] (n : \\u2115) (a : \\u03b1) :\\n abs (n \\u2022 a) = n \\u2022 abs a :=\\nbegin\\n cases le_total a 0 with hneg hpos,\\n { rw [abs_of_nonpos hneg, \\u2190 abs_neg, \\u2190 neg_nsmul, abs_of_nonneg],\\n exact nsmul_nonneg (neg_nonneg.mpr hneg) n },\\n { rw [abs_of_nonneg hpos, abs_of_nonneg],\\n exact nsmul_nonneg hpos n }\\nend\\n\\nlemma abs_gsmul {\\u03b1 : Type*} [linear_ordered_add_comm_group \\u03b1] (n : \\u2124) (a : \\u03b1) :\\n abs (n \\u2022 a) = (abs n) \\u2022 abs a :=\\nbegin\\n by_cases n0 : 0 \\u2264 n,\\n { lift n to \\u2115 using n0,\\n simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat] },\\n { lift (- n) to \\u2115 using int.le_of_lt (neg_pos.mpr (not_le.mp n0)) with m h,\\n rw [\\u2190 abs_neg (n \\u2022 a), \\u2190 neg_gsmul, \\u2190 abs_neg n, \\u2190 h, gsmul_coe_nat, coe_nat_abs,\\n gsmul_coe_nat],\\n exact abs_nsmul m _ },\\nend\\n\\nlemma abs_add_eq_add_abs_le {\\u03b1 : Type*} [linear_ordered_add_comm_group \\u03b1] {a b : \\u03b1} (hle : a \\u2264 b) :\\n abs (a + b) = abs a + abs b \\u2194 (0 \\u2264 a \\u2227 0 \\u2264 b \\u2228 a \\u2264 0 \\u2227 b \\u2264 0) :=\\nbegin\\n by_cases a0 : 0 \\u2264 a; by_cases b0 : 0 \\u2264 b,\\n { simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0] },\\n { exact (lt_irrefl (0 : \\u03b1) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim },\\n any_goals { simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm] },\\n obtain F := (not_le.mp a0),\\n have : (abs (a + b) = -a + b \\u2194 b \\u2264 0) \\u2194 (abs (a + b) =\\n abs a + abs b \\u2194 0 \\u2264 a \\u2227 0 \\u2264 b \\u2228 a \\u2264 0 \\u2227 b \\u2264 0),\\n { simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le] },\\n refine this.mp \\u27e8\\u03bb h, _, \\u03bb h, by simp only [le_antisymm h b0, abs_of_neg F, add_zero]\\u27e9,\\n by_cases ba : a + b \\u2264 0,\\n { refine le_of_eq (eq_zero_of_neg_eq _),\\n rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h },\\n { refine (lt_irrefl (0 : \\u03b1) _).elim,\\n rw [abs_of_pos (not_le.mp ba), add_left_inj] at h,\\n rwa eq_zero_of_neg_eq h.symm at F }\\nend\\n\\nlemma abs_add_eq_add_abs_iff {\\u03b1 : Type*} [linear_ordered_add_comm_group \\u03b1] (a b : \\u03b1) :\\n abs (a + b) = abs a + abs b \\u2194 (0 \\u2264 a \\u2227 0 \\u2264 b \\u2228 a \\u2264 0 \\u2227 b \\u2264 0) :=\\nbegin\\n by_cases ab : a \\u2264 b,\\n { exact abs_add_eq_add_abs_le ab },\\n { rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm,\\n @and.comm (b \\u2264 0 ) _] }\\nend\\n\\nend ordered_add_comm_group\\n\\nsection linear_ordered_add_comm_group\\nvariable [linear_ordered_add_comm_group A]\\n\\ntheorem gsmul_le_gsmul_iff {a : A} {n m : \\u2124} (ha : 0 < a) : n \\u2022 a \\u2264 m \\u2022 a \\u2194 n \\u2264 m :=\\nbegin\\n refine \\u27e8\\u03bb h, _, gsmul_le_gsmul $ le_of_lt ha\\u27e9,\\n by_contra H,\\n exact lt_irrefl _ (lt_of_lt_of_le (gsmul_lt_gsmul ha (not_le.mp H)) h)\\nend\\n\\ntheorem gsmul_lt_gsmul_iff {a : A} {n m : \\u2124} (ha : 0 < a) : n \\u2022 a < m \\u2022 a \\u2194 n < m :=\\nbegin\\n refine \\u27e8\\u03bb h, _, gsmul_lt_gsmul ha\\u27e9,\\n by_contra H,\\n exact lt_irrefl _ (lt_of_le_of_lt (gsmul_le_gsmul (le_of_lt ha) $ not_lt.mp H) h)\\nend\\n\\ntheorem nsmul_le_nsmul_iff {a : A} {n m : \\u2115} (ha : 0 < a) : n \\u2022 a \\u2264 m \\u2022 a \\u2194 n \\u2264 m :=\\nbegin\\n refine \\u27e8\\u03bb h, _, nsmul_le_nsmul $ le_of_lt ha\\u27e9,\\n by_contra H,\\n exact lt_irrefl _ (lt_of_lt_of_le (nsmul_lt_nsmul ha (not_le.mp H)) h)\\nend\\n\\ntheorem nsmul_lt_nsmul_iff {a : A} {n m : \\u2115} (ha : 0 < a) : n \\u2022 a < m \\u2022 a \\u2194 n < m :=\\nbegin\\n refine \\u27e8\\u03bb h, _, nsmul_lt_nsmul ha\\u27e9,\\n by_contra H,\\n exact lt_irrefl _ (lt_of_le_of_lt (nsmul_le_nsmul (le_of_lt ha) $ not_lt.mp H) h)\\nend\\n\\nend linear_ordered_add_comm_group\\n\\n@[simp] lemma with_bot.coe_nsmul [add_monoid A] (a : A) (n : \\u2115) :\\n ((n \\u2022 a : A) : with_bot A) = n \\u2022 a :=\\nadd_monoid_hom.map_nsmul \\u27e8(coe : A \\u2192 with_bot A), with_bot.coe_zero, with_bot.coe_add\\u27e9 a n\\n\\ntheorem nsmul_eq_mul' [semiring R] (a : R) (n : \\u2115) : n \\u2022 a = a * n :=\\nby induction n with n ih; [rw [zero_nsmul, nat.cast_zero, mul_zero],\\n rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]]\\n\\n@[simp] theorem nsmul_eq_mul [semiring R] (n : \\u2115) (a : R) : n \\u2022 a = n * a :=\\nby rw [nsmul_eq_mul', (n.cast_commute a).eq]\\n\\ntheorem mul_nsmul_left [semiring R] (a b : R) (n : \\u2115) : n \\u2022 (a * b) = a * (n \\u2022 b) :=\\nby rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]\\n\\ntheorem mul_nsmul_assoc [semiring R] (a b : R) (n : \\u2115) : n \\u2022 (a * b) = n \\u2022 a * b :=\\nby rw [nsmul_eq_mul, nsmul_eq_mul, mul_assoc]\\n\\n@[simp, norm_cast] theorem nat.cast_pow [semiring R] (n m : \\u2115) : (\\u2191(n ^ m) : R) = \\u2191n ^ m :=\\nbegin\\n induction m with m ih,\\n { rw [pow_zero, pow_zero], exact nat.cast_one },\\n { rw [pow_succ', pow_succ', nat.cast_mul, ih] }\\nend\\n\\n@[simp, norm_cast] theorem int.coe_nat_pow (n m : \\u2115) : ((n ^ m : \\u2115) : \\u2124) = n ^ m :=\\nby induction m with m ih; [exact int.coe_nat_one, rw [pow_succ', pow_succ', int.coe_nat_mul, ih]]\\n\\ntheorem int.nat_abs_pow (n : \\u2124) (k : \\u2115) : int.nat_abs (n ^ k) = (int.nat_abs n) ^ k :=\\nby induction k with k ih; [refl, rw [pow_succ', int.nat_abs_mul, pow_succ', ih]]\\n\\n-- The next four lemmas allow us to replace multiplication by a numeral with a `gsmul` expression.\\n-- They are used by the `noncomm_ring` tactic, to normalise expressions before passing to `abel`.\\n\\nlemma bit0_mul [ring R] {n r : R} : bit0 n * r = (2 : \\u2124) \\u2022 (n * r) :=\\nby { dsimp [bit0], rw [add_mul, add_gsmul, one_gsmul], }\\n\\nlemma mul_bit0 [ring R] {n r : R} : r * bit0 n = (2 : \\u2124) \\u2022 (r * n) :=\\nby { dsimp [bit0], rw [mul_add, add_gsmul, one_gsmul], }\\n\\nlemma bit1_mul [ring R] {n r : R} : bit1 n * r = (2 : \\u2124) \\u2022 (n * r) + r :=\\nby { dsimp [bit1], rw [add_mul, bit0_mul, one_mul], }\\n\\nlemma mul_bit1 [ring R] {n r : R} : r * bit1 n = (2 : \\u2124) \\u2022 (r * n) + r :=\\nby { dsimp [bit1], rw [mul_add, mul_bit0, mul_one], }\\n\\n@[simp] theorem gsmul_eq_mul [ring R] (a : R) : \\u2200 (n : \\u2124), n \\u2022 a = n * a\\n| (n : \\u2115) := by { rw [gsmul_coe_nat, nsmul_eq_mul], refl }\\n| -[1+ n] := by simp [nat.cast_succ, neg_add_rev, int.cast_neg_succ_of_nat, add_mul]\\n\\ntheorem gsmul_eq_mul' [ring R] (a : R) (n : \\u2124) : n \\u2022 a = a * n :=\\nby rw [gsmul_eq_mul, (n.cast_commute a).eq]\\n\\ntheorem mul_gsmul_left [ring R] (a b : R) (n : \\u2124) : n \\u2022 (a * b) = a * (n \\u2022 b) :=\\nby rw [gsmul_eq_mul', gsmul_eq_mul', mul_assoc]\\n\\ntheorem mul_gsmul_assoc [ring R] (a b : R) (n : \\u2124) : n \\u2022 (a * b) = n \\u2022 a * b :=\\nby rw [gsmul_eq_mul, gsmul_eq_mul, mul_assoc]\\n\\nlemma gsmul_int_int (a b : \\u2124) : a \\u2022 b = a * b := by simp\\n\\nlemma gsmul_int_one (n : \\u2124) : n \\u2022 1 = n := by simp\\n\\n@[simp, norm_cast] theorem int.cast_pow [ring R] (n : \\u2124) (m : \\u2115) : (\\u2191(n ^ m) : R) = \\u2191n ^ m :=\\nbegin\\n induction m with m ih,\\n { rw [pow_zero, pow_zero, int.cast_one] },\\n { rw [pow_succ, pow_succ, int.cast_mul, ih] }\\nend\\n\\nlemma neg_one_pow_eq_pow_mod_two [ring R] {n : \\u2115} : (-1 : R) ^ n = (-1) ^ (n % 2) :=\\nby rw [\\u2190 nat.mod_add_div n 2, pow_add, pow_mul]; simp [sq]\\n\\nsection ordered_semiring\\nvariable [ordered_semiring R]\\n\\n/-- Bernoulli's inequality. This version works for semirings but requires\\nadditional hypotheses `0 \\u2264 a * a` and `0 \\u2264 (1 + a) * (1 + a)`. -/\\ntheorem one_add_mul_le_pow' {a : R} (Hsq : 0 \\u2264 a * a) (Hsq' : 0 \\u2264 (1 + a) * (1 + a))\\n (H : 0 \\u2264 2 + a) :\\n \\u2200 (n : \\u2115), 1 + (n : R) * a \\u2264 (1 + a) ^ n\\n| 0 := by simp\\n| 1 := by simp\\n| (n+2) :=\\nhave 0 \\u2264 (n : R) * (a * a * (2 + a)) + a * a,\\n from add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq,\\ncalc 1 + (\\u2191(n + 2) : R) * a \\u2264 1 + \\u2191(n + 2) * a + (n * (a * a * (2 + a)) + a * a) :\\n (le_add_iff_nonneg_right _).2 this\\n... = (1 + a) * (1 + a) * (1 + n * a) :\\n by { simp [add_mul, mul_add, bit0, mul_assoc, (n.cast_commute (_ : R)).left_comm],\\n ac_refl }\\n... \\u2264 (1 + a) * (1 + a) * (1 + a)^n :\\n mul_le_mul_of_nonneg_left (one_add_mul_le_pow' n) Hsq'\\n... = (1 + a)^(n + 2) : by simp only [pow_succ, mul_assoc]\\n\\nprivate lemma pow_lt_pow_of_lt_one_aux {a : R} (h : 0 < a) (ha : a < 1) (i : \\u2115) :\\n \\u2200 k : \\u2115, a ^ (i + k + 1) < a ^ i\\n| 0 :=\\n begin\\n rw [\\u2190one_mul (a^i), add_zero, pow_succ],\\n exact mul_lt_mul ha (le_refl _) (pow_pos h _) zero_le_one\\n end\\n| (k+1) :=\\n begin\\n rw [\\u2190one_mul (a^i), pow_succ],\\n apply mul_lt_mul ha _ _ zero_le_one,\\n { apply le_of_lt, apply pow_lt_pow_of_lt_one_aux },\\n { show 0 < a ^ (i + (k + 1) + 0), apply pow_pos h }\\n end\\n\\nprivate lemma pow_le_pow_of_le_one_aux {a : R} (h : 0 \\u2264 a) (ha : a \\u2264 1) (i : \\u2115) :\\n \\u2200 k : \\u2115, a ^ (i + k) \\u2264 a ^ i\\n| 0 := by simp\\n| (k+1) := by { rw [\\u2190add_assoc, \\u2190one_mul (a^i), pow_succ],\\n exact mul_le_mul ha (pow_le_pow_of_le_one_aux _) (pow_nonneg h _) zero_le_one }\\n\\nlemma pow_lt_pow_of_lt_one {a : R} (h : 0 < a) (ha : a < 1)\\n {i j : \\u2115} (hij : i < j) : a ^ j < a ^ i :=\\nlet \\u27e8k, hk\\u27e9 := nat.exists_eq_add_of_lt hij in\\nby rw hk; exact pow_lt_pow_of_lt_one_aux h ha _ _\\n\\nlemma pow_lt_pow_iff_of_lt_one {a : R} {n m : \\u2115} (hpos : 0 < a) (h : a < 1) :\\n a ^ m < a ^ n \\u2194 n < m :=\\nbegin\\n have : strict_mono (\\u03bb (n : order_dual \\u2115), a ^ (id n : \\u2115)) := \\u03bb m n, pow_lt_pow_of_lt_one hpos h,\\n exact this.lt_iff_lt\\nend\\n\\nlemma pow_le_pow_of_le_one {a : R} (h : 0 \\u2264 a) (ha : a \\u2264 1)\\n {i j : \\u2115} (hij : i \\u2264 j) : a ^ j \\u2264 a ^ i :=\\nlet \\u27e8k, hk\\u27e9 := nat.exists_eq_add_of_le hij in\\nby rw hk; exact pow_le_pow_of_le_one_aux h ha _ _\\n\\nlemma pow_le_one {x : R} : \\u2200 (n : \\u2115) (h0 : 0 \\u2264 x) (h1 : x \\u2264 1), x ^ n \\u2264 1\\n| 0 h0 h1 := by rw [pow_zero]\\n| (n+1) h0 h1 := by { rw [pow_succ], exact mul_le_one h1 (pow_nonneg h0 _) (pow_le_one n h0 h1) }\\n\\nend ordered_semiring\\n\\nsection linear_ordered_semiring\\n\\nvariables [linear_ordered_semiring R]\\n\\nlemma sign_cases_of_C_mul_pow_nonneg {C r : R} (h : \\u2200 n : \\u2115, 0 \\u2264 C * r ^ n) :\\n C = 0 \\u2228 (0 < C \\u2227 0 \\u2264 r) :=\\nbegin\\n have : 0 \\u2264 C, by simpa only [pow_zero, mul_one] using h 0,\\n refine this.eq_or_lt.elim (\\u03bb h, or.inl h.symm) (\\u03bb hC, or.inr \\u27e8hC, _\\u27e9),\\n refine nonneg_of_mul_nonneg_left _ hC,\\n simpa only [pow_one] using h 1\\nend\\n\\nend linear_ordered_semiring\\n\\nsection linear_ordered_ring\\n\\nvariables [linear_ordered_ring R] {a : R} {n : \\u2115}\\n\\n@[simp] lemma abs_pow (a : R) (n : \\u2115) : abs (a ^ n) = abs a ^ n :=\\n(pow_abs a n).symm\\n\\n@[simp] theorem pow_bit1_neg_iff : a ^ bit1 n < 0 \\u2194 a < 0 :=\\n\\u27e8\\u03bb h, not_le.1 $ \\u03bb h', not_le.2 h $ pow_nonneg h' _,\\n \\u03bb h, by { rw [bit1, pow_succ], exact mul_neg_of_neg_of_pos h (pow_bit0_pos h.ne _)}\\u27e9\\n\\n@[simp] theorem pow_bit1_nonneg_iff : 0 \\u2264 a ^ bit1 n \\u2194 0 \\u2264 a :=\\nle_iff_le_iff_lt_iff_lt.2 pow_bit1_neg_iff\\n\\n@[simp] theorem pow_bit1_nonpos_iff : a ^ bit1 n \\u2264 0 \\u2194 a \\u2264 0 :=\\nby simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]\\n\\n@[simp] theorem pow_bit1_pos_iff : 0 < a ^ bit1 n \\u2194 0 < a :=\\nlt_iff_lt_of_le_iff_le pow_bit1_nonpos_iff\\n\\ntheorem pow_even_nonneg (a : R) (hn : even n) : 0 \\u2264 a ^ n :=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit0_nonneg a k\\n\\ntheorem pow_even_pos (ha : a \\u2260 0) (hn : even n) : 0 < a ^ n :=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit0_pos ha k\\n\\ntheorem pow_odd_nonneg (ha : 0 \\u2264 a) (hn : odd n) : 0 \\u2264 a ^ n :=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_nonneg_iff.mpr ha\\n\\ntheorem pow_odd_pos (ha : 0 < a) (hn : odd n) : 0 < a ^ n :=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_pos_iff.mpr ha\\n\\ntheorem pow_odd_nonpos (ha : a \\u2264 0) (hn : odd n) : a ^ n \\u2264 0:=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_nonpos_iff.mpr ha\\n\\ntheorem pow_odd_neg (ha : a < 0) (hn : odd n) : a ^ n < 0:=\\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_neg_iff.mpr ha\\n\\nlemma pow_even_abs (a : R) {p : \\u2115} (hp : even p) :\\n abs a ^ p = a ^ p :=\\nbegin\\n rw [\\u2190abs_pow, abs_eq_self],\\n exact pow_even_nonneg _ hp\\nend\\n\\n@[simp] lemma pow_bit0_abs (a : R) (p : \\u2115) :\\n abs a ^ bit0 p = a ^ bit0 p :=\\npow_even_abs _ (even_bit0 _)\\n\\nlemma strict_mono_pow_bit1 (n : \\u2115) : strict_mono (\\u03bb a : R, a ^ bit1 n) :=\\nbegin\\n intros a b hab,\\n cases le_total a 0 with ha ha,\\n { cases le_or_lt b 0 with hb hb,\\n { rw [\\u2190 neg_lt_neg_iff, \\u2190 neg_pow_bit1, \\u2190 neg_pow_bit1],\\n exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) },\\n { exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) } },\\n { exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n)) }\\nend\\n\\n/-- Bernoulli's inequality for `n : \\u2115`, `-2 \\u2264 a`. -/\\ntheorem one_add_mul_le_pow (H : -2 \\u2264 a) (n : \\u2115) : 1 + (n : R) * a \\u2264 (1 + a) ^ n :=\\none_add_mul_le_pow' (mul_self_nonneg _) (mul_self_nonneg _) (neg_le_iff_add_nonneg'.1 H) _\\n\\n/-- Bernoulli's inequality reformulated to estimate `a^n`. -/\\ntheorem one_add_mul_sub_le_pow (H : -1 \\u2264 a) (n : \\u2115) : 1 + (n : R) * (a - 1) \\u2264 a ^ n :=\\nhave -2 \\u2264 a - 1, by rwa [bit0, neg_add, \\u2190 sub_eq_add_neg, sub_le_sub_iff_right],\\nby simpa only [add_sub_cancel'_right] using one_add_mul_le_pow this n\\n\\nend linear_ordered_ring\\n\\n/-- Bernoulli's inequality reformulated to estimate `(n : K)`. -/\\ntheorem nat.cast_le_pow_sub_div_sub {K : Type*} [linear_ordered_field K] {a : K} (H : 1 < a)\\n (n : \\u2115) :\\n (n : K) \\u2264 (a ^ n - 1) / (a - 1) :=\\n(le_div_iff (sub_pos.2 H)).2 $ le_sub_left_of_add_le $\\n one_add_mul_sub_le_pow ((neg_le_self $ @zero_le_one K _).trans H.le) _\\n\\n/-- For any `a > 1` and a natural `n` we have `n \\u2264 a ^ n / (a - 1)`. See also\\n`nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator. -/\\ntheorem nat.cast_le_pow_div_sub {K : Type*} [linear_ordered_field K] {a : K} (H : 1 < a) (n : \\u2115) :\\n (n : K) \\u2264 a ^ n / (a - 1) :=\\n(n.cast_le_pow_sub_div_sub H).trans $ div_le_div_of_le (sub_nonneg.2 H.le)\\n (sub_le_self _ zero_le_one)\\n\\nnamespace int\\n\\nlemma units_sq (u : units \\u2124) : u ^ 2 = 1 :=\\n(sq u).symm \\u25b8 units_mul_self u\\n\\nalias int.units_sq \\u2190 int.units_pow_two\\n\\nlemma units_pow_eq_pow_mod_two (u : units \\u2124) (n : \\u2115) : u ^ n = u ^ (n % 2) :=\\nby conv {to_lhs, rw \\u2190 nat.mod_add_div n 2}; rw [pow_add, pow_mul, units_sq, one_pow, mul_one]\\n\\n@[simp] lemma nat_abs_sq (x : \\u2124) : (x.nat_abs ^ 2 : \\u2124) = x ^ 2 :=\\nby rw [sq, int.nat_abs_mul_self', sq]\\n\\nalias int.nat_abs_sq \\u2190 int.nat_abs_pow_two\\n\\nlemma abs_le_self_sq (a : \\u2124) : (int.nat_abs a : \\u2124) \\u2264 a ^ 2 :=\\nby { rw [\\u2190 int.nat_abs_sq a, sq], norm_cast, apply nat.le_mul_self }\\n\\nalias int.abs_le_self_sq \\u2190 int.abs_le_self_pow_two\\n\\nlemma le_self_sq (b : \\u2124) : b \\u2264 b ^ 2 := le_trans (le_nat_abs) (abs_le_self_sq _)\\n\\nalias int.le_self_sq \\u2190 int.le_self_pow_two\\n\\nend int\\n\\nvariables (M G A)\\n\\n/-- Monoid homomorphisms from `multiplicative \\u2115` are defined by the image\\nof `multiplicative.of_add 1`. -/\\ndef powers_hom [monoid M] : M \\u2243 (multiplicative \\u2115 \\u2192* M) :=\\n{ to_fun := \\u03bb x, \\u27e8\\u03bb n, x ^ n.to_add, by { convert pow_zero x, exact to_add_one },\\n \\u03bb m n, pow_add x m n\\u27e9,\\n inv_fun := \\u03bb f, f (multiplicative.of_add 1),\\n left_inv := pow_one,\\n right_inv := \\u03bb f, monoid_hom.ext $ \\u03bb n, by { simp [\\u2190 f.map_pow, \\u2190 of_add_nsmul] } }\\n\\n/-- Monoid homomorphisms from `multiplicative \\u2124` are defined by the image\\nof `multiplicative.of_add 1`. -/\\ndef gpowers_hom [group G] : G \\u2243 (multiplicative \\u2124 \\u2192* G) :=\\n{ to_fun := \\u03bb x, \\u27e8\\u03bb n, x ^ n.to_add, gpow_zero x, \\u03bb m n, gpow_add x m n\\u27e9,\\n inv_fun := \\u03bb f, f (multiplicative.of_add 1),\\n left_inv := gpow_one,\\n right_inv := \\u03bb f, monoid_hom.ext $ \\u03bb n, by { simp [\\u2190 f.map_gpow, \\u2190 of_add_gsmul ] } }\\n\\n/-- Additive homomorphisms from `\\u2115` are defined by the image of `1`. -/\\ndef multiples_hom [add_monoid A] : A \\u2243 (\\u2115 \\u2192+ A) :=\\n{ to_fun := \\u03bb x, \\u27e8\\u03bb n, n \\u2022 x, zero_nsmul x, \\u03bb m n, add_nsmul _ _ _\\u27e9,\\n inv_fun := \\u03bb f, f 1,\\n left_inv := one_nsmul,\\n right_inv := \\u03bb f, add_monoid_hom.ext_nat $ one_nsmul (f 1) }\\n\\n/-- Additive homomorphisms from `\\u2124` are defined by the image of `1`. -/\\ndef gmultiples_hom [add_group A] : A \\u2243 (\\u2124 \\u2192+ A) :=\\n{ to_fun := \\u03bb x, \\u27e8\\u03bb n, n \\u2022 x, zero_gsmul x, \\u03bb m n, add_gsmul _ _ _\\u27e9,\\n inv_fun := \\u03bb f, f 1,\\n left_inv := one_gsmul,\\n right_inv := \\u03bb f, add_monoid_hom.ext_int $ one_gsmul (f 1) }\\n\\nvariables {M G A}\\n\\n@[simp] lemma powers_hom_apply [monoid M] (x : M) (n : multiplicative \\u2115) :\\n powers_hom M x n = x ^ n.to_add := rfl\\n\\n@[simp] lemma powers_hom_symm_apply [monoid M] (f : multiplicative \\u2115 \\u2192* M) :\\n (powers_hom M).symm f = f (multiplicative.of_add 1) := rfl\\n\\n@[simp] lemma gpowers_hom_apply [group G] (x : G) (n : multiplicative \\u2124) :\\n gpowers_hom G x n = x ^ n.to_add := rfl\\n\\n@[simp] lemma gpowers_hom_symm_apply [group G] (f : multiplicative \\u2124 \\u2192* G) :\\n (gpowers_hom G).symm f = f (multiplicative.of_add 1) := rfl\\n\\n@[simp] lemma multiples_hom_apply [add_monoid A] (x : A) (n : \\u2115) :\\n multiples_hom A x n = n \\u2022 x := rfl\\n\\n@[simp] lemma multiples_hom_symm_apply [add_monoid A] (f : \\u2115 \\u2192+ A) :\\n (multiples_hom A).symm f = f 1 := rfl\\n\\n@[simp] lemma gmultiples_hom_apply [add_group A] (x : A) (n : \\u2124) :\\n gmultiples_hom A x n = n \\u2022 x := rfl\\n\\n@[simp] lemma gmultiples_hom_symm_apply [add_group A] (f : \\u2124 \\u2192+ A) :\\n (gmultiples_hom A).symm f = f 1 := rfl\\n\\nlemma monoid_hom.apply_mnat [monoid M] (f : multiplicative \\u2115 \\u2192* M) (n : multiplicative \\u2115) :\\n f n = (f (multiplicative.of_add 1)) ^ n.to_add :=\\nby rw [\\u2190 powers_hom_symm_apply, \\u2190 powers_hom_apply, equiv.apply_symm_apply]\\n\\n@[ext] lemma monoid_hom.ext_mnat [monoid M] \\u2983f g : multiplicative \\u2115 \\u2192* M\\u2984\\n (h : f (multiplicative.of_add 1) = g (multiplicative.of_add 1)) : f = g :=\\nmonoid_hom.ext $ \\u03bb n, by rw [f.apply_mnat, g.apply_mnat, h]\\n\\nlemma monoid_hom.apply_mint [group M] (f : multiplicative \\u2124 \\u2192* M) (n : multiplicative \\u2124) :\\n f n = (f (multiplicative.of_add 1)) ^ n.to_add :=\\nby rw [\\u2190 gpowers_hom_symm_apply, \\u2190 gpowers_hom_apply, equiv.apply_symm_apply]\\n\\n/-! `monoid_hom.ext_mint` is defined in `data.int.cast` -/\\n\\nlemma add_monoid_hom.apply_nat [add_monoid M] (f : \\u2115 \\u2192+ M) (n : \\u2115) :\\n f n = n \\u2022 (f 1) :=\\nby rw [\\u2190 multiples_hom_symm_apply, \\u2190 multiples_hom_apply, equiv.apply_symm_apply]\\n\\n/-! `add_monoid_hom.ext_nat` is defined in `data.nat.cast` -/\\n\\nlemma add_monoid_hom.apply_int [add_group M] (f : \\u2124 \\u2192+ M) (n : \\u2124) :\\n f n = n \\u2022 (f 1) :=\\nby rw [\\u2190 gmultiples_hom_symm_apply, \\u2190 gmultiples_hom_apply, equiv.apply_symm_apply]\\n\\n/-! `add_monoid_hom.ext_int` is defined in `data.int.cast` -/\\n\\nvariables (M G A)\\n\\n/-- If `M` is commutative, `powers_hom` is a multiplicative equivalence. -/\\ndef powers_mul_hom [comm_monoid M] : M \\u2243* (multiplicative \\u2115 \\u2192* M) :=\\n{ map_mul' := \\u03bb a b, monoid_hom.ext $ by simp [mul_pow],\\n ..powers_hom M}\\n\\n/-- If `M` is commutative, `gpowers_hom` is a multiplicative equivalence. -/\\ndef gpowers_mul_hom [comm_group G] : G \\u2243* (multiplicative \\u2124 \\u2192* G) :=\\n{ map_mul' := \\u03bb a b, monoid_hom.ext $ by simp [mul_gpow],\\n ..gpowers_hom G}\\n\\n/-- If `M` is commutative, `multiples_hom` is an additive equivalence. -/\\ndef multiples_add_hom [add_comm_monoid A] : A \\u2243+ (\\u2115 \\u2192+ A) :=\\n{ map_add' := \\u03bb a b, add_monoid_hom.ext $ by simp [nsmul_add],\\n ..multiples_hom A}\\n\\n/-- If `M` is commutative, `gmultiples_hom` is an additive equivalence. -/\\ndef gmultiples_add_hom [add_comm_group A] : A \\u2243+ (\\u2124 \\u2192+ A) :=\\n{ map_add' := \\u03bb a b, add_monoid_hom.ext $ by simp [gsmul_add],\\n ..gmultiples_hom A}\\n\\nvariables {M G A}\\n\\n@[simp] lemma powers_mul_hom_apply [comm_monoid M] (x : M) (n : multiplicative \\u2115) :\\n powers_mul_hom M x n = x ^ n.to_add := rfl\\n\\n@[simp] lemma powers_mul_hom_symm_apply [comm_monoid M] (f : multiplicative \\u2115 \\u2192* M) :\\n (powers_mul_hom M).symm f = f (multiplicative.of_add 1) := rfl\\n\\n@[simp] lemma gpowers_mul_hom_apply [comm_group G] (x : G) (n : multiplicative \\u2124) :\\n gpowers_mul_hom G x n = x ^ n.to_add := rfl\\n\\n@[simp] lemma gpowers_mul_hom_symm_apply [comm_group G] (f : multiplicative \\u2124 \\u2192* G) :\\n (gpowers_mul_hom G).symm f = f (multiplicative.of_add 1) := rfl\\n\\n@[simp] lemma multiples_add_hom_apply [add_comm_monoid A] (x : A) (n : \\u2115) :\\n multiples_add_hom A x n = n \\u2022 x := rfl\\n\\n@[simp] lemma multiples_add_hom_symm_apply [add_comm_monoid A] (f : \\u2115 \\u2192+ A) :\\n (multiples_add_hom A).symm f = f 1 := rfl\\n\\n@[simp] lemma gmultiples_add_hom_apply [add_comm_group A] (x : A) (n : \\u2124) :\\n gmultiples_add_hom A x n = n \\u2022 x := rfl\\n\\n@[simp] lemma gmultiples_add_hom_symm_apply [add_comm_group A] (f : \\u2124 \\u2192+ A) :\\n (gmultiples_add_hom A).symm f = f 1 := rfl\\n\\n/-!\\n### Commutativity (again)\\n\\nFacts about `semiconj_by` and `commute` that require `gpow` or `gsmul`, or the fact that integer\\nmultiplication equals semiring multiplication.\\n-/\\n\\nnamespace semiconj_by\\n\\nsection\\n\\nvariables [semiring R] {a x y : R}\\n\\n@[simp] lemma cast_nat_mul_right (h : semiconj_by a x y) (n : \\u2115) :\\n semiconj_by a ((n : R) * x) (n * y) :=\\nsemiconj_by.mul_right (nat.commute_cast _ _) h\\n\\n@[simp] lemma cast_nat_mul_left (h : semiconj_by a x y) (n : \\u2115) : semiconj_by ((n : R) * a) x y :=\\nsemiconj_by.mul_left (nat.cast_commute _ _) h\\n\\n@[simp] lemma cast_nat_mul_cast_nat_mul (h : semiconj_by a x y) (m n : \\u2115) :\\n semiconj_by ((m : R) * a) (n * x) (n * y) :=\\n(h.cast_nat_mul_left m).cast_nat_mul_right n\\n\\nend\\n\\nvariables [monoid M] [group G] [ring R]\\n\\n@[simp] lemma units_gpow_right {a : M} {x y : units M} (h : semiconj_by a x y) :\\n \\u2200 m : \\u2124, semiconj_by a (\\u2191(x^m)) (\\u2191(y^m))\\n| (n : \\u2115) := by simp only [gpow_coe_nat, units.coe_pow, h, pow_right]\\n| -[1+n] := by simp only [gpow_neg_succ_of_nat, units.coe_pow, units_inv_right, h, pow_right]\\n\\nvariables {a b x y x' y' : R}\\n\\n@[simp] lemma cast_int_mul_right (h : semiconj_by a x y) (m : \\u2124) :\\n semiconj_by a ((m : \\u2124) * x) (m * y) :=\\nsemiconj_by.mul_right (int.commute_cast _ _) h\\n\\n@[simp] lemma cast_int_mul_left (h : semiconj_by a x y) (m : \\u2124) : semiconj_by ((m : R) * a) x y :=\\nsemiconj_by.mul_left (int.cast_commute _ _) h\\n\\n@[simp] lemma cast_int_mul_cast_int_mul (h : semiconj_by a x y) (m n : \\u2124) :\\n semiconj_by ((m : R) * a) (n * x) (n * y) :=\\n(h.cast_int_mul_left m).cast_int_mul_right n\\n\\nend semiconj_by\\n\\nnamespace commute\\n\\nsection\\n\\nvariables [semiring R] {a b : R}\\n\\n@[simp] theorem cast_nat_mul_right (h : commute a b) (n : \\u2115) : commute a ((n : R) * b) :=\\nh.cast_nat_mul_right n\\n\\n@[simp] theorem cast_nat_mul_left (h : commute a b) (n : \\u2115) : commute ((n : R) * a) b :=\\nh.cast_nat_mul_left n\\n\\n@[simp] theorem cast_nat_mul_cast_nat_mul (h : commute a b) (m n : \\u2115) :\\n commute ((m : R) * a) (n * b) :=\\nh.cast_nat_mul_cast_nat_mul m n\\n\\n@[simp] theorem self_cast_nat_mul (n : \\u2115) : commute a (n * a) :=\\n(commute.refl a).cast_nat_mul_right n\\n\\n@[simp] theorem cast_nat_mul_self (n : \\u2115) : commute ((n : R) * a) a :=\\n(commute.refl a).cast_nat_mul_left n\\n\\n@[simp] theorem self_cast_nat_mul_cast_nat_mul (m n : \\u2115) : commute ((m : R) * a) (n * a) :=\\n(commute.refl a).cast_nat_mul_cast_nat_mul m n\\n\\nend\\n\\nvariables [monoid M] [group G] [ring R]\\n\\n@[simp] lemma units_gpow_right {a : M} {u : units M} (h : commute a u) (m : \\u2124) :\\n commute a (\\u2191(u^m)) :=\\nh.units_gpow_right m\\n\\n@[simp] lemma units_gpow_left {u : units M} {a : M} (h : commute \\u2191u a) (m : \\u2124) :\\n commute (\\u2191(u^m)) a :=\\n(h.symm.units_gpow_right m).symm\\n\\nvariables {a b : R}\\n\\n@[simp] lemma cast_int_mul_right (h : commute a b) (m : \\u2124) : commute a (m * b) :=\\nh.cast_int_mul_right m\\n\\n@[simp] lemma cast_int_mul_left (h : commute a b) (m : \\u2124) : commute ((m : R) * a) b :=\\nh.cast_int_mul_left m\\n\\nlemma cast_int_mul_cast_int_mul (h : commute a b) (m n : \\u2124) : commute ((m : R) * a) (n * b) :=\\nh.cast_int_mul_cast_int_mul m n\\n\\nvariables (a) (m n : \\u2124)\\n\\n@[simp] theorem self_cast_int_mul : commute a (n * a) := (commute.refl a).cast_int_mul_right n\\n\\n@[simp] theorem cast_int_mul_self : commute ((n : R) * a) a := (commute.refl a).cast_int_mul_left n\\n\\ntheorem self_cast_int_mul_cast_int_mul : commute ((m : R) * a) (n * a) :=\\n(commute.refl a).cast_int_mul_cast_int_mul m n\\n\\nend commute\\n\\nsection multiplicative\\n\\nopen multiplicative\\n\\n@[simp] lemma nat.to_add_pow (a : multiplicative \\u2115) (b : \\u2115) : to_add (a ^ b) = to_add a * b :=\\nbegin\\n induction b with b ih,\\n { erw [pow_zero, to_add_one, mul_zero] },\\n { simp [*, pow_succ, add_comm, nat.mul_succ] }\\nend\\n\\n@[simp] lemma nat.of_add_mul (a b : \\u2115) : of_add (a * b) = of_add a ^ b :=\\n(nat.to_add_pow _ _).symm\\n\\n@[simp] lemma int.to_add_pow (a : multiplicative \\u2124) (b : \\u2115) : to_add (a ^ b) = to_add a * b :=\\nby induction b; simp [*, mul_add, pow_succ, add_comm]\\n\\n@[simp] lemma int.to_add_gpow (a : multiplicative \\u2124) (b : \\u2124) : to_add (a ^ b) = to_add a * b :=\\nint.induction_on b (by simp)\\n (by simp [gpow_add, mul_add] {contextual := tt})\\n (by simp [gpow_add, mul_add, sub_eq_add_neg, -int.add_neg_one] {contextual := tt})\\n\\n@[simp] lemma int.of_add_mul (a b : \\u2124) : of_add (a * b) = of_add a ^ b :=\\n(int.to_add_gpow _ _).symm\\n\\nend multiplicative\\n\\nnamespace units\\n\\nvariables [monoid M]\\n\\nlemma conj_pow (u : units M) (x : M) (n : \\u2115) : (\\u2191u * x * \\u2191(u\\u207b\\u00b9))^n = u * x^n * \\u2191(u\\u207b\\u00b9) :=\\n(divp_eq_iff_mul_eq.2 ((u.mk_semiconj_by x).pow_right n).eq.symm).symm\\n\\nlemma conj_pow' (u : units M) (x : M) (n : \\u2115) : (\\u2191(u\\u207b\\u00b9) * x * u)^n = \\u2191(u\\u207b\\u00b9) * x^n * u:=\\n(u\\u207b\\u00b9).conj_pow x n\\n\\nopen opposite\\n\\n/-- Moving to the opposite monoid commutes with taking powers. -/\\n@[simp] lemma op_pow (x : M) (n : \\u2115) : op (x ^ n) = (op x) ^ n :=\\nbegin\\n induction n with n h,\\n { simp },\\n { rw [pow_succ', op_mul, h, pow_succ] }\\nend\\n\\n@[simp] lemma unop_pow (x : M\\u1d52\\u1d56) (n : \\u2115) : unop (x ^ n) = (unop x) ^ n :=\\nbegin\\n induction n with n h,\\n { simp },\\n { rw [pow_succ', unop_mul, h, pow_succ] }\\nend\\n\\nend units\\n\"} {\"text\": \"import Mathlib.Tactic.GuardGoalNums\\n\\nexample : true \\u2227 true := by\\n constructor\\n guard_goal_nums 2\\n all_goals {constructor}\\n\\nexample : (true \\u2227 true) \\u2227 (true \\u2227 true) := by\\n constructor <;> constructor\\n guard_goal_nums 4\\n all_goals {constructor}\\n\"} {\"text\": \"theory deMorgan3\\n imports Main\\nbegin\\n text\\\\<open> Apply style \\\\<close>\\nlemma lem_k_1 : \\\" (\\\\<not>p \\\\<or> \\\\<not>q)\\\\<longrightarrow> \\\\<not>(p \\\\<and> q)\\\"\\n apply (rule impI)\\n apply (erule disjE)\\n apply (rule notI)\\n apply (erule notE)\\n apply (erule conjE)\\n apply assumption\\n apply (rule notI)\\n apply (erule conjE)\\n apply (erule notE)\\n apply assumption\\n done \\nend\"} {\"text\": \"myTestRule {\\n msifilesystem_rename( \\\"/tmp/raw/tests\\\", \\\"/tmp/raw/\\\", \\\"/tmp/processed/\\\" );\\n writeLine(\\\"stdout\\\",\\\"done\\\");\\n}\\nOUTPUT ruleExecOut\\n\\n\"} {\"text\": \"module MachineLearning.NeuralNetwork.TopologyTest\\n(\\n tests\\n)\\n\\nwhere\\n\\nimport Test.Framework (testGroup)\\nimport Test.Framework.Providers.HUnit\\nimport Test.HUnit\\nimport Test.HUnit.Approx\\nimport Test.HUnit.Plus\\nimport qualified Numeric.LinearAlgebra as LA\\nimport MachineLearning.NeuralNetwork.Topology\\nimport qualified MachineLearning.NeuralNetwork.TopologyMaker as TM\\n\\nnnt = TM.makeTopology TM.ASigmoid TM.LLogistic 15 2 [10]\\n\\nflattenTest = do\\n theta <- initializeThetaIO nnt\\n let theta' = flatten $ unflatten nnt theta\\n norm = LA.norm_2 (theta - theta')\\n assertApproxEqual \\\"flatten\\\" 1e-10 0 norm\\n\\ntests = [ testGroup \\\"flatten\\\" [\\n testCase \\\"flatten\\\" flattenTest\\n ]\\n ]\\n\"} {\"text\": \"Require Export SystemFR.Syntax.\\n\\nRequire Export SystemFR.Tactics.\\nRequire Export SystemFR.ListSetLemmas.\\nRequire Export SystemFR.AssocList.\\nRequire Export SystemFR.ListUtils.\\nRequire Export SystemFR.EqualWithRelation.\\nRequire Export SystemFR.EquivalentWithRelation.\\n\\nRequire Import PeanoNat.\\n\\nOpen Scope list_scope.\\n\\nFixpoint idrel (l: list nat) :=\\n match l with\\n | nil => nil\\n | x :: xs => (x,x) :: idrel xs\\n end.\\n\\nLemma idrel_lookup:\\n forall l x,\\n x \\u2208 l ->\\n lookup PeanoNat.Nat.eq_dec (idrel l) x = Some x.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma idrel_lookup_swap:\\n forall l x,\\n x \\u2208 l ->\\n lookup PeanoNat.Nat.eq_dec (swap (idrel l)) x = Some x.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma equal_with_idrel:\\n forall t, equal_with_relation type_var (idrel (pfv t type_var)) t t.\\nProof.\\n intros; apply equal_with_relation_refl2; steps;\\n eauto using idrel_lookup, idrel_lookup_swap.\\nQed.\\n\\nLemma idrel_lookup_fail:\\n forall l x,\\n (x \\u2208 l -> False) ->\\n lookup PeanoNat.Nat.eq_dec (idrel l) x = None.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma idrel_lookup_swap_fail:\\n forall l x,\\n (x \\u2208 l -> False) ->\\n lookup PeanoNat.Nat.eq_dec (swap (idrel l)) x = None.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma support_idrel:\\n forall l, support (idrel l) = l.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma range_idrel:\\n forall l, range (idrel l) = l.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma support_swap:\\n forall l, support (swap l) = range l.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma range_swap:\\n forall l, range (swap l) = support l.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma equivalent_rc_refl:\\n forall rc, equivalent_rc rc rc.\\nProof.\\n unfold equivalent_rc; steps.\\nQed.\\n\\nLemma equivalent_with_idrel:\\n forall T (l: list nat) (x: nat) \\u03c1 t (equiv: T -> T -> Prop),\\n (x \\u2208 l -> False) ->\\n (forall v, equiv v v) ->\\n equivalent_with_relation (idrel l) \\u03c1 ((x,t) :: \\u03c1) equiv.\\nProof.\\n unfold equivalent_with_relation;\\n repeat step || t_lookup ||\\n rewrite support_idrel in * ||\\n rewrite support_swap in * ||\\n rewrite range_idrel in * ||\\n rewrite range_swap in * ||\\n (rewrite idrel_lookup in * by auto) ||\\n (rewrite idrel_lookup_swap_fail in * by auto) ||\\n apply equivalent_with_right.\\nQed.\\n\\nLemma equivalent_with_idrel2:\\n forall T (l: list nat) (x: nat) \\u03c1 t (equiv: T -> T -> Prop),\\n (x \\u2208 l -> False) ->\\n (forall v, equiv v v) ->\\n equivalent_with_relation (idrel l) ((x,t) :: \\u03c1) \\u03c1 equiv.\\nProof.\\n unfold equivalent_with_relation;\\n repeat step || t_lookup ||\\n rewrite support_idrel in * ||\\n rewrite support_swap in * ||\\n rewrite range_idrel in * ||\\n rewrite range_swap in * ||\\n (rewrite idrel_lookup in * by auto) ||\\n (rewrite idrel_lookup_swap_fail in * by auto) ||\\n apply equivalent_with_left.\\nQed.\\n\\nLtac t_idrel :=\\n rewrite support_idrel in * ||\\n rewrite support_swap in * ||\\n rewrite range_idrel in * ||\\n rewrite range_swap in * ||\\n (rewrite idrel_lookup in * by auto) ||\\n (rewrite idrel_lookup_swap_fail in * by auto).\\n\\nLemma equivalent_with_relation_permute:\\n forall T \\u03c11 \\u03c12 v M l (equiv: T -> T -> Prop),\\n ~(M \\u2208 support \\u03c11) ->\\n (forall v, equiv v v) ->\\n equivalent_with_relation\\n ((M, M) :: idrel l)\\n (\\u03c11 ++ (M, v) :: \\u03c12)\\n ((M, v) :: \\u03c11 ++ \\u03c12)\\n equiv\\n.\\nProof.\\n unfold equivalent_with_relation, equivalent_with;\\n repeat match goal with\\n | |- exists r, Some ?R = Some r /\\\\ _ => exists R\\n | |- exists r, _ /\\\\ equivalent_rc r ?R => exists R\\n | H: _ |- _ => rewrite lookup_remove2 in H by steps\\n | _ => rewrite lookup_remove2 by steps\\n | _ => step || t_lookup_rewrite || t_idrel || t_lookup || list_utils ||\\n rewrite obvious_lookup in * by steps ||\\n t_lookupor || t_lookup_same\\n end;\\n eauto.\\nQed.\\n\\nLemma idrel_lookup2:\\n forall x y l eq_dec, lookup eq_dec (idrel l) x = Some y -> x = y /\\\\ x \\u2208 l.\\nProof.\\n induction l; repeat step || eapply_any || instantiate_any.\\nQed.\\n\\nLtac t_idrel_lookup2 :=\\n match goal with\\n | H: lookup _ (idrel ?l) ?x = Some ?y |- _ => pose proof (idrel_lookup2 _ _ _ _ H); clear H\\n end.\\n\\nLemma swap_idrel:\\n forall l, swap (idrel l) = idrel l.\\nProof.\\n induction l; steps.\\nQed.\\n\\nLemma equivalent_with_relation_permute2:\\n forall T \\u03c11 \\u03c12 v X Y l (equiv: T -> T -> Prop),\\n ~(X \\u2208 support \\u03c11) ->\\n (forall v, equiv v v) ->\\n equivalent_with_relation\\n ((Y, X) :: idrel l)\\n ((Y, v) :: \\u03c11 ++ \\u03c12)\\n (\\u03c11 ++ (X, v) :: \\u03c12)\\n equiv\\n.\\nProof.\\n unfold equivalent_with_relation, equivalent_with;\\n repeat match goal with\\n | |- exists r, Some ?R = Some r /\\\\ _ => exists R\\n | |- exists r, _ /\\\\ equivalent_rc r ?R => exists R\\n | H: _ |- _ => rewrite lookup_remove2 in H by steps\\n | _ => rewrite lookup_remove2 by steps\\n | _ => step || t_lookup_rewrite || t_idrel || t_lookup || list_utils ||\\n rewrite obvious_lookup in * by steps ||\\n t_lookupor || t_lookup_same\\n end;\\n eauto.\\nQed.\\n\"} {\"text\": \"From Coq.Unicode Require Import Utf8.\\nFrom Coq.Lists Require Import List.\\nFrom Coq.Relations Require Import Relations.\\nFrom Coq.micromega Require Import Lia.\\n\\nClass valid_language {expr : Type}\\n (is_val : expr \\u2192 Prop)\\n (is_ectx : (expr \\u2192 expr) \\u2192 Prop)\\n (head_step : expr \\u2192 expr \\u2192 Prop) : Type :=\\nValidLang {\\n is_val_no_head_step : \\u2200 v, is_val v \\u2192 \\u2200 e', \\u00ac head_step v e';\\n is_val_under_ectx : \\u2200 e K , is_ectx K \\u2192 is_val (K e) \\u2192 is_val e;\\n is_ectx_id : is_ectx (\\u03bb e, e);\\n is_val_dec : \\u2200 e, is_val e \\u2228 \\u00ac is_val e;\\n ectx_head_step : \\u2200 K e e', is_ectx K \\u2192 head_step (K e) e' \\u2192 (\\u2200 f, K f = f) \\u2228 is_val e;\\n ectx_inj : \\u2200 K e e', is_ectx K \\u2192 K e = K e' \\u2192 e = e';\\n ectx_compose : \\u2200 K K', is_ectx K \\u2192 is_ectx K' \\u2192 is_ectx (\\u03bb e, K (K' e));\\n ectxs_nesting : \\u2200 K e K' e',\\n is_ectx K \\u2192\\n is_ectx K' \\u2192\\n K e = K' e' \\u2192\\n \\u00ac is_val e \\u2192\\n \\u00ac is_val e' \\u2192\\n (\\u2203 K'', is_ectx K'' \\u2227 \\u2200 f, K f = K' (K'' f)) \\u2228 (\\u2203 K'', is_ectx K'' \\u2227 \\u2200 f, K' f = K (K'' f))\\n}.\\n\\nInductive step {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :\\n expr \\u2192 expr \\u2192 Prop :=\\n| Step K e1 e2 : is_ectx K \\u2192 head_step e1 e2 \\u2192 step (K e1) (K e2).\\n\\nDefinition steps {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :=\\n clos_refl_trans _ step.\\n\\nInductive nsteps {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :\\n nat \\u2192 expr \\u2192 expr \\u2192 Prop :=\\n| NSO e : nsteps 0 e e\\n| NSS n e1 e2 e3 : step e1 e2 \\u2192 nsteps n e2 e3 \\u2192 nsteps (S n) e1 e3.\\n\\nDefinition det_head_step\\n {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} e e' :=\\n head_step e e' \\u2227 \\u2200 e'', head_step e e'' \\u2192 e'' = e'.\\n\\nDefinition det_step\\n {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} e e' :=\\n step e e' \\u2227 \\u2200 e'', step e e'' \\u2192 e'' = e'.\\n\\nSection language.\\n Context {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step}.\\n\\n Lemma nsteps_refl e : nsteps 0 e e.\\n Proof. constructor; fail. Qed.\\n\\n Lemma step_nsteps e e' : step e e' \\u2192 nsteps 1 e e'.\\n Proof. econstructor; [eassumption|econstructor]. Qed.\\n\\n Lemma nsteps_trans n n' e e' e'' : nsteps n e e' \\u2192 nsteps n' e' e'' \\u2192 nsteps (n + n') e e''.\\n Proof.\\n induction 1; [trivial; fail|].\\n simpl.\\n econstructor; [eassumption|auto].\\n Qed.\\n\\n Lemma nsteps_take_step n e e' e'' :\\n step e e' \\u2192 nsteps n e' e'' \\u2192 nsteps (S n) e e''.\\n Proof. intros ? ?; eapply (nsteps_trans 1); [apply step_nsteps|]; eauto. Qed.\\n\\n Lemma steps_ind (P : expr \\u2192 expr \\u2192 Prop) :\\n (\\u2200 e, P e e) \\u2192\\n (\\u2200 e e' e'', step e e' \\u2192 steps e' e'' \\u2192 P e' e'' \\u2192 P e e'') \\u2192\\n \\u2200 e e', steps e e' \\u2192 P e e'.\\n Proof.\\n intros Hrfl Hstp e e' Hsteps.\\n apply clos_rt_rt1n_iff in Hsteps.\\n induction Hsteps; [apply Hrfl|].\\n eapply Hstp; [eassumption|apply clos_rt_rt1n_iff; assumption|assumption].\\n Qed.\\n\\n Lemma steps_refl e : steps e e.\\n Proof. constructor; fail. Qed.\\n\\n Lemma step_steps e e' : step e e' \\u2192 steps e e'.\\n Proof. constructor; assumption. Qed.\\n\\n Lemma steps_trans e e' e'' : steps e e' \\u2192 steps e' e'' \\u2192 steps e e''.\\n Proof. econstructor; eauto; fail. Qed.\\n\\n Lemma steps_nsteps e e' : steps e e' \\u2192 \\u2203 n, nsteps n e e'.\\n Proof.\\n induction 1 as [| |? ? ? ? [n Hn] ? [k Hk]];\\n [eexists; eapply step_nsteps; assumption|exists 0; apply nsteps_refl|].\\n eexists (_ + _); eapply nsteps_trans; eauto.\\n Qed.\\n\\n Lemma nsteps_steps n e e' : nsteps n e e' \\u2192 steps e e'.\\n Proof.\\n induction 1; [econstructor; fail|eapply steps_trans; [apply step_steps; eassumption|trivial]].\\n Qed.\\n\\n Lemma val_no_step e : is_val e \\u2192 \\u2200 e', \\u00ac step e e'.\\n Proof.\\n intros He e' Hstp.\\n inversion Hstp as [K e1 e2 HK Hhs]; subst; clear Hstp.\\n apply is_val_under_ectx in He; [|assumption].\\n eapply is_val_no_head_step; eauto.\\n Qed.\\n\\n Lemma val_steps_eq e e' : is_val e \\u2192 steps e e' \\u2192 e = e'.\\n Proof.\\n intros Hiv Hstps; revert Hiv.\\n pattern e; pattern e'.\\n match goal with\\n | |- (\\u03bb e', (\\u03bb e, ?P) _) _ => simpl; apply (steps_ind (\\u03bb e e', P))\\n end; [| |assumption]; clear e' e Hstps.\\n - trivial.\\n - intros ???????.\\n exfalso; eapply val_no_step; eauto.\\n Qed.\\n\\n Lemma head_step_step e e' : head_step e e' \\u2192 step e e'.\\n Proof. intros; eapply (Step (\\u03bb e, e)); [apply is_ectx_id|assumption]. Qed.\\n\\n Lemma ectx_step e e' K : is_ectx K \\u2192 step e e' \\u2192 step (K e) (K e').\\n Proof.\\n intros ?; inversion 1 as [K' e1 e2]; subst.\\n eapply (Step (\\u03bb e, K (K' e))); [apply ectx_compose; assumption|assumption].\\n Qed.\\n\\n Lemma ectx_steps e e' K : is_ectx K \\u2192 steps e e' \\u2192 steps (K e) (K e').\\n Proof.\\n intros HK Hstep.\\n pattern e; pattern e'.\\n match goal with\\n | |- (\\u03bb e2, (\\u03bb e1, ?P) _) _ => simpl; apply (steps_ind (\\u03bb e1 e2, P))\\n end; [| |assumption]; clear e e' Hstep.\\n - intros ?; apply steps_refl.\\n - intros e e' e'' Hstep Hsteps HKsteps.\\n eapply steps_trans; [apply step_steps, ectx_step|]; eassumption.\\n Qed.\\n\\n Lemma steps_eq_or_step_iff e e' : steps e e' \\u2194 e = e' \\u2228 \\u2203 e'', step e e'' \\u2227 steps e'' e'.\\n Proof.\\n split.\\n - intros Hsteps; apply clos_rt_rt1n_iff in Hsteps.\\n inversion Hsteps as [|??? Hsteps']; [eauto; fail|].\\n apply clos_rt_rt1n_iff in Hsteps'; eauto.\\n - intros [->|[? [? ?]]]; apply clos_rt_rt1n_iff;\\n [constructor; fail|econstructor; [|apply clos_rt_rt1n_iff]]; eauto.\\n Qed.\\n\\n Lemma step_under_ectx K e e' :\\n is_ectx K \\u2192 step (K e) e' \\u2192\\n (is_val e) \\u2228 (\\u2203 e'', step e e'' \\u2227 e' = K e'').\\n Proof.\\n intros HK Hstp.\\n destruct (is_val_dec e) as [Hiv|Hniv].\\n - auto.\\n - right.\\n inversion Hstp as [K' e1 e2 HK' Hhs HKe1e]; subst.\\n destruct (ectxs_nesting _ _ _ _ HK' HK HKe1e) as [[K'' [HK''1 HK''2]]|[K'' [HK''1 HK''2]]];\\n [intros ?; contradict Hhs; apply is_val_no_head_step; assumption|assumption| |].\\n + rewrite HK''2 in HKe1e.\\n apply ectx_inj in HKe1e; [|assumption].\\n subst.\\n exists (K'' e2); rewrite HK''2; split; [|reflexivity].\\n constructor; trivial.\\n + rewrite HK''2 in HKe1e.\\n apply ectx_inj in HKe1e; [|assumption].\\n subst.\\n pose proof Hhs as Hhs'.\\n apply ectx_head_step in Hhs as [Hhs|Hhs]; [|tauto|assumption].\\n rewrite Hhs in Hhs'.\\n exists e2; split; [apply head_step_step; assumption|].\\n rewrite HK''2, Hhs; trivial.\\n Qed.\\n\\n Definition Safe (P : expr \\u2192 Prop) (e : expr) :=\\n \\u2200 e', steps e e' \\u2192 (is_val e' \\u2227 P e') \\u2228 \\u2203 e'', step e' e''.\\n\\n Lemma Safe_mono (P Q : expr \\u2192 Prop) e : (\\u2200 v, P v \\u2192 Q v) \\u2192 Safe P e \\u2192 Safe Q e.\\n Proof. unfold Safe; firstorder. Qed.\\n\\n Lemma Safe_val (P : expr \\u2192 Prop) e : is_val e \\u2192 P e \\u2192 Safe P e.\\n Proof.\\n unfold Safe; intros He HPe e' Hstp.\\n left.\\n apply val_steps_eq in Hstp; subst; auto.\\n Qed.\\n\\n Lemma Safe_val_inv (P : expr \\u2192 Prop) e : is_val e \\u2192 Safe P e \\u2192 P e.\\n Proof.\\n unfold Safe; intros He HSf.\\n destruct (HSf e) as [|[e' He']]; [apply steps_refl|tauto|].\\n contradict He'; apply val_no_step; trivial.\\n Qed.\\n\\n Lemma Safe_step (P : expr \\u2192 Prop) e e' : step e e' \\u2192 Safe P e \\u2192 Safe P e'.\\n Proof.\\n intros Hstep HSf ei Hsteps.\\n apply HSf.\\n apply steps_eq_or_step_iff; eauto.\\n Qed.\\n\\n Lemma det_head_step_det_step e e' : det_head_step e e' \\u2192 det_step e e'.\\n Proof.\\n intros [Hhs Hdt]; split; [apply head_step_step; assumption|].\\n intros e'' Hstp.\\n inversion Hstp as [? ? ? ? Hhs']; subst.\\n apply ectx_head_step in Hhs as [Hid|Hvl]; [| |assumption].\\n - rewrite Hid; rewrite Hid in Hdt. apply Hdt; assumption.\\n - contradict Hhs'; apply is_val_no_head_step; trivial.\\n Qed.\\n\\n Lemma Safe_det_step_back (P : expr \\u2192 Prop) e e' : det_step e e' \\u2192 Safe P e' \\u2192 Safe P e.\\n Proof.\\n intros Hdstep HSf ei Hsteps.\\n apply steps_eq_or_step_iff in Hsteps as [->|(e'' & He''1 & He''2)].\\n - right; eexists; apply Hdstep.\\n - apply Hdstep in He''1; subst.\\n apply HSf; assumption.\\n Qed.\\n\\n Lemma Safe_head_step_back (P : expr \\u2192 Prop) e e' : det_head_step e e' \\u2192 Safe P e' \\u2192 Safe P e.\\n Proof.\\n intros.\\n eapply Safe_det_step_back; [apply det_head_step_det_step|]; eassumption.\\n Qed.\\n\\n Lemma steps_under_ectx K e e' :\\n is_ectx K \\u2192 steps (K e) e' \\u2192\\n (\\u2203 e'', e' = K e'' \\u2227 steps e e'') \\u2228 \\u2203 v, is_val v \\u2227 steps e v \\u2227 steps (K v) e'.\\n Proof.\\n intros HK [n Hstps]%steps_nsteps.\\n revert e e' HK Hstps.\\n induction n; intros e e' HK Hstps.\\n - inversion Hstps; subst; left; eexists _; split; [eauto|apply steps_refl].\\n - inversion Hstps as [|? ? ex]; subst.\\n destruct (step_under_ectx K e ex) as [|(e'' & He''1 & He''2)];\\n [assumption|assumption| |subst].\\n + right; eexists e; split; [assumption|].\\n split; [apply steps_refl|eapply nsteps_steps; eassumption].\\n + destruct (IHn e'' e') as [(? & -> &?)|(?&?&?&?)]; [assumption|assumption| |].\\n * left; eexists; split; [reflexivity|eapply steps_trans; [apply step_steps|]; eauto].\\n * right; eexists _; split; [eassumption|].\\n split; [eapply steps_trans; [apply step_steps|]; eauto|assumption].\\n Qed.\\n\\n Lemma Safe_bind (P Q : expr \\u2192 Prop) e K :\\n is_ectx K \\u2192 Safe P e \\u2192 (\\u2200 v, is_val v \\u2192 P v \\u2192 Safe Q (K v)) \\u2192 Safe Q (K e).\\n Proof.\\n intros HK He HKSf e' Hstps.\\n apply steps_under_ectx in Hstps as [(e'' & -> & He'')|(v & Hv & Hv1 & Hv2)]; [| |assumption].\\n - apply He in He'' as [[Hie'' HPe'']|[e3 He3]].\\n + eapply HKSf; [eassumption|eassumption|apply steps_refl].\\n + right; eexists; apply ectx_step; eauto.\\n - apply He in Hv1 as [[]|[]]; [|exfalso; eapply val_no_step; eauto; fail].\\n eapply HKSf; [eassumption|assumption|assumption].\\n Qed.\\n\\n Definition Normalizes (P : expr \\u2192 Prop) (e : expr) := \\u2203 v, is_val v \\u2227 steps e v \\u2227 P v.\\n\\n Lemma Normalizes_mono (P Q : expr \\u2192 Prop) e : (\\u2200 v, P v \\u2192 Q v) \\u2192 Normalizes P e \\u2192 Normalizes Q e.\\n Proof. unfold Safe; firstorder. Qed.\\n\\n Lemma Normalizes_val (P : expr \\u2192 Prop) e : is_val e \\u2192 P e \\u2192 Normalizes P e.\\n Proof.\\n intros ? ?; eexists; repeat split; [eassumption|apply steps_refl|eassumption].\\n Qed.\\n\\n Lemma Normalizses_val_inv (P : expr \\u2192 Prop) e : is_val e \\u2192 Normalizes P e \\u2192 P e.\\n Proof.\\n intros Hiv (e' & He'1 & He'2 & He'3).\\n apply val_steps_eq in He'2; [subst; trivial|assumption].\\n Qed.\\n\\n Lemma Normalizes_step_back (P : expr \\u2192 Prop) e e' : step e e' \\u2192 Normalizes P e' \\u2192 Normalizes P e.\\n Proof.\\n intros Hstep (v & Hv1 & Hv2 & Hv3).\\n exists v; repeat split; [assumption| |assumption].\\n apply steps_eq_or_step_iff; eauto.\\n Qed.\\n\\n Lemma Normalizes_head_step_back (P : expr \\u2192 Prop) e e' :\\n head_step e e' \\u2192 Normalizes P e' \\u2192 Normalizes P e.\\n Proof.\\n intros Hstep (v & Hv1 & Hv2 & Hv3).\\n exists v; repeat split; [assumption| |assumption].\\n apply steps_eq_or_step_iff; eauto using head_step_step.\\n Qed.\\n\\n Lemma Normalizes_det_step (P : expr \\u2192 Prop) e e' :\\n det_step e e' \\u2192 Normalizes P e \\u2192 Normalizes P e'.\\n Proof.\\n intros Hdstep (v & Hv1 & Hv2 & Hv3).\\n exists v; repeat split; [assumption| |assumption].\\n apply steps_eq_or_step_iff in Hv2 as [->|(e'' & He''1 & He''2)].\\n - destruct Hdstep as [Hstp%val_no_step ?]; tauto.\\n - pose proof He''1 as ->%Hdstep; assumption.\\n Qed.\\n\\n Lemma Normalizes_bind (P Q : expr \\u2192 Prop) e K :\\n is_ectx K \\u2192 Normalizes P e \\u2192 (\\u2200 v, is_val v \\u2192 P v \\u2192 Normalizes Q (K v)) \\u2192 Normalizes Q (K e).\\n Proof.\\n intros HK He HKnrm.\\n destruct He as (v & Hv1 & Hv2 & Hv3).\\n destruct (HKnrm v) as (w & Hw1 & Hw2 & Hw3); [assumption|assumption|].\\n exists w; repeat split; [assumption| |assumption].\\n eapply steps_trans; [|eassumption].\\n apply ectx_steps; assumption.\\n Qed.\\n\\n Lemma val_nsteps_eq n e e' : is_val e \\u2192 nsteps n e e' \\u2192 n = 0 \\u2227 e = e'.\\n Proof.\\n inversion 2; subst; [split; reflexivity|].\\n exfalso; eapply val_no_step; eauto.\\n Qed.\\n\\n Lemma nsteps_eq_or_step_iff n e e' :\\n nsteps n e e' \\u2194 (n = 0 \\u2227 e = e') \\u2228 \\u2203 n' e'', n = S n' \\u2227 step e e'' \\u2227 nsteps n' e'' e'.\\n Proof.\\n split.\\n - intros Hsteps.\\n inversion Hsteps; subst.\\n + left; auto.\\n + right; eexists _, _; split; [reflexivity|]; split; [eassumption|eassumption].\\n - intros [[-> ->]|(?&?&->&?&?)]; [constructor|econstructor; eauto].\\n Qed.\\n\\n Lemma ectx_nsteps n e e' K : is_ectx K \\u2192 nsteps n e e' \\u2192 nsteps n (K e) (K e').\\n Proof. induction 2; econstructor; eauto using ectx_step. Qed.\\n\\n Definition SISafe (P : nat \\u2192 expr \\u2192 Prop) (n : nat) (e : expr) :=\\n \\u2200 k e', k \\u2264 n \\u2192 nsteps k e e' \\u2192 (is_val e' \\u2227 P (n - k) e') \\u2228 \\u2203 e'', step e' e''.\\n\\n Lemma SISafe_mono (P Q : nat \\u2192 expr \\u2192 Prop) n e :\\n (\\u2200 n' v, n' \\u2264 n \\u2192 P n' v \\u2192 Q n' v) \\u2192 SISafe P n e \\u2192 SISafe Q n e.\\n Proof.\\n intros HPQ HSf ??? Hstps.\\n apply HSf in Hstps as [?|?]; [|auto; fail|lia].\\n left; split; [tauto|apply HPQ; [lia|tauto]].\\n Qed.\\n\\n Lemma SISafe_down_closed (P : nat \\u2192 expr \\u2192 Prop) n n' e :\\n n' \\u2264 n \\u2192 (\\u2200 k k' e, k' \\u2264 k \\u2192 k \\u2264 n \\u2192 P k e \\u2192 P k' e) \\u2192 SISafe P n e \\u2192 SISafe P n' e.\\n Proof.\\n intros Hle HP Hne z e' Hz Hnstps.\\n destruct (\\u03bb Hle, Hne z e' Hle Hnstps) as [[? ?]|]; [lia| |right; assumption].\\n left; split; [assumption|].\\n eapply HP; [| |eassumption]; [lia|lia].\\n Qed.\\n\\n Lemma SISafe_down_closed' (P : nat \\u2192 expr \\u2192 Prop) n n' e :\\n \\u00ac is_val e \\u2192 n' \\u2264 n \\u2192 (\\u2200 k k' e, k' \\u2264 k \\u2192 k < n \\u2192 P k e \\u2192 P k' e) \\u2192 SISafe P n e \\u2192 SISafe P n' e.\\n Proof.\\n intros Hniv Hle HP Hne z e' Hz Hnstps.\\n destruct (\\u03bb Hle, Hne z e' Hle Hnstps) as [[? ?]|]; [lia| |right; assumption].\\n inversion Hnstps; subst; [tauto|].\\n left; split; [assumption|].\\n eapply HP; [| |eassumption]; [lia|lia].\\n Qed.\\n\\n Lemma SISafe_val (P : nat \\u2192 expr \\u2192 Prop) n e : is_val e \\u2192 P n e \\u2192 SISafe P n e.\\n Proof.\\n intros He HPe k e' Hk Hstp.\\n left.\\n apply val_nsteps_eq in Hstp as [? ?]; subst; [|assumption].\\n replace (n - 0) with n by lia; auto.\\n Qed.\\n\\n Lemma SISafe_val_inv (P : nat \\u2192 expr \\u2192 Prop) n e : is_val e \\u2192 SISafe P n e \\u2192 P n e.\\n Proof.\\n unfold Safe; intros He HSf.\\n destruct (HSf 0 e) as [[Hiv HP]|[e' He']]; [lia|apply nsteps_refl| |].\\n - replace (n - 0) with n in HP by lia; trivial.\\n - contradict He'; apply val_no_step; trivial.\\n Qed.\\n\\n Lemma SISafe_step (P : nat \\u2192 expr \\u2192 Prop) e e' n :\\n step e e' \\u2192 SISafe P (S n) e \\u2192 SISafe P n e'.\\n Proof.\\n intros Hstep HSf k ei Hk Hsteps.\\n apply (HSf (S k)); [lia|].\\n econstructor; eauto.\\n Qed.\\n\\n Lemma SISafe_det_step_back (P : nat \\u2192 expr \\u2192 Prop) e e' n :\\n det_step e e' \\u2192 (0 < n \\u2192 SISafe P (n - 1) e') \\u2192 SISafe P n e.\\n Proof.\\n intros Hdstep HSf k ei Hk Hsteps.\\n apply nsteps_eq_or_step_iff in Hsteps as [[-> ->]|(m & e'' & -> & He''1 & He''2)].\\n - right; eexists; apply Hdstep.\\n - apply Hdstep in He''1; subst.\\n destruct n as [|n]; [lia|].\\n pose proof (\\u03bb H, HSf H m ei) as HSf'. simpl in *.\\n replace (n - 0) with n in HSf' by lia.\\n apply HSf'; [lia|lia|assumption].\\n Qed.\\n\\n Lemma SISafe_head_step_back (P : nat \\u2192 expr \\u2192 Prop) e e' n :\\n det_head_step e e' \\u2192 (0 < n \\u2192 SISafe P (n - 1) e') \\u2192 SISafe P n e.\\n Proof.\\n intros.\\n eapply SISafe_det_step_back; [apply det_head_step_det_step|]; eassumption.\\n Qed.\\n\\n Lemma nsteps_under_ectx n K e e' :\\n is_ectx K \\u2192 nsteps n (K e) e' \\u2192\\n (\\u2203 e'', e' = K e'' \\u2227 nsteps n e e'') \\u2228\\n \\u2203 k v, k \\u2264 n \\u2227 is_val v \\u2227 nsteps k e v \\u2227 nsteps (n - k) (K v) e'.\\n Proof.\\n revert e e'.\\n induction n; intros e e' HK Hstps.\\n - inversion Hstps; subst; left; eexists _; split; [eauto|econstructor].\\n - inversion Hstps as [|? ? ex]; subst.\\n destruct (step_under_ectx K e ex) as [|(e'' & He''1 & He''2)];\\n [assumption|assumption| |subst].\\n + right; eexists 0, e; split; [lia|split]; [assumption|].\\n split; [econstructor|].\\n rewrite PeanoNat.Nat.sub_0_r; trivial.\\n + destruct (IHn e'' e') as [(? & -> &?)|(?&?&?&?&?&?)]; [assumption|assumption| |].\\n * left; eexists; split; [reflexivity|econstructor; eauto].\\n * right; eexists (S _), _; repeat split; [|eassumption| |eassumption]; [lia|].\\n econstructor; eauto.\\n Qed.\\n\\n Lemma SISafe_bind (P Q : nat \\u2192 expr \\u2192 Prop) e K n :\\n is_ectx K \\u2192\\n SISafe P n e \\u2192\\n (\\u2200 k v, k \\u2264 n \\u2192 is_val v \\u2192 P k v \\u2192 SISafe Q k (K v)) \\u2192\\n SISafe Q n (K e).\\n Proof.\\n intros HK He HKSf k e' Hk Hstps.\\n apply nsteps_under_ectx in Hstps as [(e'' & -> & He'')|(m & ? & v & Hv & Hv1 & Hv2)];\\n [| |assumption].\\n - apply He in He'' as [[Hie'' HPe'']|[e3 He3]]; [| |lia].\\n + apply HKSf in HPe''; [|lia|assumption].\\n pose proof (HPe'' 0) as HPe3.\\n replace (n - k - 0) with (n - k) in HPe3 by lia.\\n apply HPe3; [lia|]; apply nsteps_refl.\\n + right; eexists; apply ectx_step; eauto.\\n - apply He in Hv1 as [[? HPkv]|[]]; [|exfalso; eapply val_no_step; eauto; fail|lia].\\n apply HKSf in HPkv; [|lia|assumption].\\n specialize (HPkv (k - m) e'); simpl in *.\\n replace (n - m - (k - m)) with (n - k) in HPkv by lia.\\n apply HPkv; [lia |assumption].\\n Qed.\\n\\n Lemma SISafe_adequacy P e : (\\u2200 n, SISafe (\\u03bb _ v, P v) n e) \\u2192 Safe P e.\\n Proof.\\n intros HSI e' [n Hstps]%steps_nsteps.\\n eapply (HSI n); [|eassumption]; lia.\\n Qed.\\n\\nEnd language.\\n\"} {\"text\": \"lemmas linear_scaleR_left = linear_scale_left\"} {\"text\": \"(** Proof that for every two-parameter uncurried function, there\\n exists an equivalent curried function *)\\n\\nDefinition curry (f : Type * Type -> Type) x y := f (x, y).\\n\\nTheorem curry_exists :\\n forall (f : (Type * Type) -> Type) x y, exists g, f (x, y) = g x y.\\nProof.\\n intros.\\n exists (curry f).\\n unfold curry.\\n reflexivity.\\nQed.\\n\"} {\"text\": \"------------------------------------------------------------------------\\n-- The Agda standard library\\n--\\n-- Basic definitions for morphisms between algebraic structures\\n------------------------------------------------------------------------\\n\\n{-# OPTIONS --without-K --safe #-}\\n\\nopen import Relation.Binary.Core\\n\\nmodule Algebra.Morphism.Definitions\\n {a} (A : Set a) -- The domain of the morphism\\n {b} (B : Set b) -- The codomain of the morphism\\n {\\u2113} (_\\u2248_ : Rel B \\u2113) -- The equality relation over the codomain\\n where\\n\\nopen import Algebra.Core\\nopen import Function.Core\\n\\n------------------------------------------------------------------------\\n-- Basic definitions\\n\\nHomomorphic\\u2080 : (A \\u2192 B) \\u2192 A \\u2192 B \\u2192 Set _\\nHomomorphic\\u2080 \\u27e6_\\u27e7 \\u2219 \\u2218 = \\u27e6 \\u2219 \\u27e7 \\u2248 \\u2218\\n\\nHomomorphic\\u2081 : (A \\u2192 B) \\u2192 Op\\u2081 A \\u2192 Op\\u2081 B \\u2192 Set _\\nHomomorphic\\u2081 \\u27e6_\\u27e7 \\u2219_ \\u2218_ = \\u2200 x \\u2192 \\u27e6 \\u2219 x \\u27e7 \\u2248 (\\u2218 \\u27e6 x \\u27e7)\\n\\nHomomorphic\\u2082 : (A \\u2192 B) \\u2192 Op\\u2082 A \\u2192 Op\\u2082 B \\u2192 Set _\\nHomomorphic\\u2082 \\u27e6_\\u27e7 _\\u2219_ _\\u2218_ = \\u2200 x y \\u2192 \\u27e6 x \\u2219 y \\u27e7 \\u2248 (\\u27e6 x \\u27e7 \\u2218 \\u27e6 y \\u27e7)\\n\\n\\n\\n------------------------------------------------------------------------\\n-- DEPRECATED NAMES\\n------------------------------------------------------------------------\\n-- Please use the new names as continuing support for the old names is\\n-- not guaranteed.\\n\\n-- Version 1.3\\n\\nMorphism : Set _\\nMorphism = A \\u2192 B\\n\\n{-# WARNING_ON_USAGE Morphism\\n\\\"Warning: Morphism was deprecated in v1.3.\\nPlease use the standard function notation (e.g. A \\u2192 B) instead.\\\"\\n#-}\\n\"} {\"text\": \"lemma snd_quot_of_fract_to_fract [simp]: \\\"snd (quot_of_fract (to_fract x)) = 1\\\"\"} {\"text\": \"typealias IntegerVector{I<:Integer} Vector{I}\\ntypealias RealVector{N<:Real} Vector{N}\\ntypealias RealMatrix{N<:Real} Matrix{N}\\n\\ntypealias RealLowerTriangular{T<:Real, S<:AbstractMatrix} LowerTriangular{T, S}\\n\\nmultivecs{T}(::Type{T}, n::Int) = [T[] for _ =1:n]\\n\"} {\"text\": \"open nat\\n\\nexample (P : \\u2115 \\u2192 Prop) (h\\u2080 : P 0) (h\\u2081 : \\u2200 n, P (succ n)) (m : \\u2115) :\\n P m :=\\nbegin\\n cases m with m',\\n exact h\\u2080,\\n exact h\\u2081 m'\\nend\\n\"} {\"text\": \"[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\n\\u22a2 \\u2200 \\u2983X Y : Discrete PUnit\\u2984 (f : X \\u27f6 Y),\\n ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n Y =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n X \\u226b\\n F.map f\\n[PROOFSTEP]\\nintro X Y f\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\nX Y : Discrete PUnit\\nf : X \\u27f6 Y\\n\\u22a2 ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n Y =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n X \\u226b\\n F.map f\\n[PROOFSTEP]\\nmatch X, Y, f with\\n| .mk A, .mk B, .up g => aesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\nX Y : Discrete PUnit\\nf : X \\u27f6 Y\\nA B : PUnit\\ng : PLift ({ as := A }.as = { as := B }.as)\\n\\u22a2 ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map { down := g } \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n { as := B } =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } =>\\n \\ud835\\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\\n { as := A } \\u226b\\n F.map { down := g }\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cone F\\nj j' : J\\nf : j \\u27f6 j'\\n\\u22a2 NatTrans.app c.\\u03c0 j \\u226b F.map f = NatTrans.app c.\\u03c0 j'\\n[PROOFSTEP]\\nrw [\\u2190 c.\\u03c0.naturality f]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cone F\\nj j' : J\\nf : j \\u27f6 j'\\n\\u22a2 ((const J).obj c.pt).map f \\u226b NatTrans.app c.\\u03c0 j' = NatTrans.app c.\\u03c0 j'\\n[PROOFSTEP]\\napply id_comp\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\n\\u22a2 \\u2200 \\u2983X Y : Discrete PUnit\\u2984 (f : X \\u27f6 Y),\\n F.map f \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n Y =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n X \\u226b\\n ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f\\n[PROOFSTEP]\\nintro X Y f\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\nX Y : Discrete PUnit\\nf : X \\u27f6 Y\\n\\u22a2 F.map f \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n Y =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n X \\u226b\\n ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f\\n[PROOFSTEP]\\nmatch X, Y, f with\\n| .mk A, .mk B, .up g => aesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : Discrete PUnit \\u2964 C\\nX Y : Discrete PUnit\\nf : X \\u27f6 Y\\nA B : PUnit\\ng : PLift ({ as := A }.as = { as := B }.as)\\n\\u22a2 F.map { down := g } \\u226b\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n { as := B } =\\n (fun x =>\\n match x with\\n | { as := PUnit.unit } => \\ud835\\udfd9 (F.obj { as := PUnit.unit }))\\n { as := A } \\u226b\\n ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map { down := g }\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\nj j' : J\\nf : j \\u27f6 j'\\n\\u22a2 F.map f \\u226b NatTrans.app c.\\u03b9 j' = NatTrans.app c.\\u03b9 j\\n[PROOFSTEP]\\nrw [c.\\u03b9.naturality f]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\nj j' : J\\nf : j \\u27f6 j'\\n\\u22a2 NatTrans.app c.\\u03b9 j \\u226b ((const J).obj c.pt).map f = NatTrans.app c.\\u03b9 j\\n[PROOFSTEP]\\napply comp_id\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\n\\u22a2 ((fun c => { fst := op c.pt, snd := c.\\u03c0 }) \\u226b fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) = \\ud835\\udfd9 (Cone F)\\n[PROOFSTEP]\\nfunext X\\n[GOAL]\\ncase h\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nX : Cone F\\n\\u22a2 ((fun c => { fst := op c.pt, snd := c.\\u03c0 }) \\u226b fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) X = \\ud835\\udfd9 (Cone F) X\\n[PROOFSTEP]\\ncases X\\n[GOAL]\\ncase h.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\npt\\u271d : C\\n\\u03c0\\u271d : (const J).obj pt\\u271d \\u27f6 F\\n\\u22a2 ((fun c => { fst := op c.pt, snd := c.\\u03c0 }) \\u226b fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) { pt := pt\\u271d, \\u03c0 := \\u03c0\\u271d } =\\n \\ud835\\udfd9 (Cone F) { pt := pt\\u271d, \\u03c0 := \\u03c0\\u271d }\\n[PROOFSTEP]\\nrfl\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\n\\u22a2 ((fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) \\u226b fun c => { fst := op c.pt, snd := c.\\u03c0 }) =\\n \\ud835\\udfd9 ((X : C\\u1d52\\u1d56) \\u00d7 (Functor.cones F).obj X)\\n[PROOFSTEP]\\nfunext X\\n[GOAL]\\ncase h\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nX : (X : C\\u1d52\\u1d56) \\u00d7 (Functor.cones F).obj X\\n\\u22a2 ((fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) \\u226b fun c => { fst := op c.pt, snd := c.\\u03c0 }) X =\\n \\ud835\\udfd9 ((X : C\\u1d52\\u1d56) \\u00d7 (Functor.cones F).obj X) X\\n[PROOFSTEP]\\ncases X\\n[GOAL]\\ncase h.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nfst\\u271d : C\\u1d52\\u1d56\\nsnd\\u271d : (Functor.cones F).obj fst\\u271d\\n\\u22a2 ((fun c => { pt := c.fst.unop, \\u03c0 := c.snd }) \\u226b fun c => { fst := op c.pt, snd := c.\\u03c0 }) { fst := fst\\u271d, snd := snd\\u271d } =\\n \\ud835\\udfd9 ((X : C\\u1d52\\u1d56) \\u00d7 (Functor.cones F).obj X) { fst := fst\\u271d, snd := snd\\u271d }\\n[PROOFSTEP]\\nrfl\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\n\\u22a2 ((fun c => { fst := c.pt, snd := c.\\u03b9 }) \\u226b fun c => { pt := c.fst, \\u03b9 := c.snd }) = \\ud835\\udfd9 (Cocone F)\\n[PROOFSTEP]\\nfunext X\\n[GOAL]\\ncase h\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nX : Cocone F\\n\\u22a2 ((fun c => { fst := c.pt, snd := c.\\u03b9 }) \\u226b fun c => { pt := c.fst, \\u03b9 := c.snd }) X = \\ud835\\udfd9 (Cocone F) X\\n[PROOFSTEP]\\ncases X\\n[GOAL]\\ncase h.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\npt\\u271d : C\\n\\u03b9\\u271d : F \\u27f6 (const J).obj pt\\u271d\\n\\u22a2 ((fun c => { fst := c.pt, snd := c.\\u03b9 }) \\u226b fun c => { pt := c.fst, \\u03b9 := c.snd }) { pt := pt\\u271d, \\u03b9 := \\u03b9\\u271d } =\\n \\ud835\\udfd9 (Cocone F) { pt := pt\\u271d, \\u03b9 := \\u03b9\\u271d }\\n[PROOFSTEP]\\nrfl\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\n\\u22a2 ((fun c => { pt := c.fst, \\u03b9 := c.snd }) \\u226b fun c => { fst := c.pt, snd := c.\\u03b9 }) =\\n \\ud835\\udfd9 ((X : C) \\u00d7 (Functor.cocones F).obj X)\\n[PROOFSTEP]\\nfunext X\\n[GOAL]\\ncase h\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nX : (X : C) \\u00d7 (Functor.cocones F).obj X\\n\\u22a2 ((fun c => { pt := c.fst, \\u03b9 := c.snd }) \\u226b fun c => { fst := c.pt, snd := c.\\u03b9 }) X =\\n \\ud835\\udfd9 ((X : C) \\u00d7 (Functor.cocones F).obj X) X\\n[PROOFSTEP]\\ncases X\\n[GOAL]\\ncase h.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF\\u271d F : J \\u2964 C\\nfst\\u271d : C\\nsnd\\u271d : (Functor.cocones F).obj fst\\u271d\\n\\u22a2 ((fun c => { pt := c.fst, \\u03b9 := c.snd }) \\u226b fun c => { fst := c.pt, snd := c.\\u03b9 }) { fst := fst\\u271d, snd := snd\\u271d } =\\n \\ud835\\udfd9 ((X : C) \\u00d7 (Functor.cocones F).obj X) { fst := fst\\u271d, snd := snd\\u271d }\\n[PROOFSTEP]\\nrfl\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cone F\\nf g : c \\u27f6 c'\\nw : f.Hom = g.Hom\\n\\u22a2 f = g\\n[PROOFSTEP]\\ncases f\\n[GOAL]\\ncase mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cone F\\ng : c \\u27f6 c'\\nHom\\u271d : c.pt \\u27f6 c'.pt\\nw\\u271d : \\u2200 (j : J), Hom\\u271d \\u226b NatTrans.app c'.\\u03c0 j = NatTrans.app c.\\u03c0 j\\nw : (mk Hom\\u271d).Hom = g.Hom\\n\\u22a2 mk Hom\\u271d = g\\n[PROOFSTEP]\\ncases g\\n[GOAL]\\ncase mk.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cone F\\nHom\\u271d\\u00b9 : c.pt \\u27f6 c'.pt\\nw\\u271d\\u00b9 : \\u2200 (j : J), Hom\\u271d\\u00b9 \\u226b NatTrans.app c'.\\u03c0 j = NatTrans.app c.\\u03c0 j\\nHom\\u271d : c.pt \\u27f6 c'.pt\\nw\\u271d : \\u2200 (j : J), Hom\\u271d \\u226b NatTrans.app c'.\\u03c0 j = NatTrans.app c.\\u03c0 j\\nw : (mk Hom\\u271d\\u00b9).Hom = (mk Hom\\u271d).Hom\\n\\u22a2 mk Hom\\u271d\\u00b9 = mk Hom\\u271d\\n[PROOFSTEP]\\ncongr\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF K : J \\u2964 C\\nc d : Cone K\\nf : c \\u27f6 d\\ni : IsIso f.Hom\\n\\u22a2 f \\u226b ConeMorphism.mk (inv f.Hom) = \\ud835\\udfd9 c \\u2227 ConeMorphism.mk (inv f.Hom) \\u226b f = \\ud835\\udfd9 d\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\ne : K \\u224c J\\ns : Cone (e.functor \\u22d9 F)\\n\\u22a2 \\u2200 (j : K),\\n NatTrans.app\\n (((whiskering e.inverse \\u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \\u22d9 whiskering e.functor).obj s).\\u03c0 j =\\n (Iso.refl\\n (((whiskering e.inverse \\u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \\u22d9 whiskering e.functor).obj\\n s).pt).hom \\u226b\\n NatTrans.app ((\\ud835\\udfed (Cone (e.functor \\u22d9 F))).obj s).\\u03c0 j\\n[PROOFSTEP]\\nintro k\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\ne : K \\u224c J\\ns : Cone (e.functor \\u22d9 F)\\nk : K\\n\\u22a2 NatTrans.app\\n (((whiskering e.inverse \\u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \\u22d9 whiskering e.functor).obj s).\\u03c0 k =\\n (Iso.refl\\n (((whiskering e.inverse \\u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \\u22d9 whiskering e.functor).obj\\n s).pt).hom \\u226b\\n NatTrans.app ((\\ud835\\udfed (Cone (e.functor \\u22d9 F))).obj s).\\u03c0 k\\n[PROOFSTEP]\\nsimpa [e.counit_app_functor] using s.w (e.unitInv.app k)\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cone F\\n\\u22a2 \\u2200 \\u2983X Y : J\\u2984 (f : X \\u27f6 Y),\\n ((const J).obj (G.obj A.pt)).map f \\u226b (fun j => G.map (NatTrans.app A.\\u03c0 j)) Y =\\n (fun j => G.map (NatTrans.app A.\\u03c0 j)) X \\u226b (F \\u22d9 G).map f\\n[PROOFSTEP]\\nintros\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cone F\\nX\\u271d Y\\u271d : J\\nf\\u271d : X\\u271d \\u27f6 Y\\u271d\\n\\u22a2 ((const J).obj (G.obj A.pt)).map f\\u271d \\u226b (fun j => G.map (NatTrans.app A.\\u03c0 j)) Y\\u271d =\\n (fun j => G.map (NatTrans.app A.\\u03c0 j)) X\\u271d \\u226b (F \\u22d9 G).map f\\u271d\\n[PROOFSTEP]\\nerw [\\u2190 G.map_comp]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cone F\\nX\\u271d Y\\u271d : J\\nf\\u271d : X\\u271d \\u27f6 Y\\u271d\\n\\u22a2 ((const J).obj (G.obj A.pt)).map f\\u271d \\u226b (fun j => G.map (NatTrans.app A.\\u03c0 j)) Y\\u271d =\\n G.map (NatTrans.app A.\\u03c0 X\\u271d \\u226b F.map f\\u271d)\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nX\\u271d Y\\u271d : Cone F\\nf : X\\u271d \\u27f6 Y\\u271d\\nj : J\\n\\u22a2 G.map f.Hom \\u226b\\n NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03c0 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03c0 j) }) Y\\u271d).\\u03c0 j =\\n NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03c0 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03c0 j) }) X\\u271d).\\u03c0 j\\n[PROOFSTEP]\\nsimp [-ConeMorphism.w, \\u2190 f.w j]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d\\u00b9 : Full G\\ninst\\u271d : Faithful G\\nX\\u271d Y\\u271d : Cone F\\nt : (functoriality F G).obj X\\u271d \\u27f6 (functoriality F G).obj Y\\u271d\\nj : J\\n\\u22a2 G.map (G.preimage t.Hom \\u226b NatTrans.app Y\\u271d.\\u03c0 j) = G.map (NatTrans.app X\\u271d.\\u03c0 j)\\n[PROOFSTEP]\\nsimpa using t.w j\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nc c' : Cone F\\nf g : c \\u27f6 c'\\ne : (functoriality F G).map f = (functoriality F G).map g\\n\\u22a2 f = g\\n[PROOFSTEP]\\napply ConeMorphism.ext f g\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nc c' : Cone F\\nf g : c \\u27f6 c'\\ne : (functoriality F G).map f = (functoriality F G).map g\\n\\u22a2 f.Hom = g.Hom\\n[PROOFSTEP]\\nlet f := ConeMorphism.mk.inj e\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nc c' : Cone F\\nf\\u271d g : c \\u27f6 c'\\ne : (functoriality F G).map f\\u271d = (functoriality F G).map g\\nf : G.map f\\u271d.Hom = G.map g.Hom := ConeMorphism.mk.inj e\\n\\u22a2 f\\u271d.Hom = g.Hom\\n[PROOFSTEP]\\napply G.map_injective f\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d : ReflectsIsomorphisms F\\nK : J \\u2964 C\\n\\u22a2 ReflectsIsomorphisms (functoriality K F)\\n[PROOFSTEP]\\nconstructor\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d : ReflectsIsomorphisms F\\nK : J \\u2964 C\\n\\u22a2 \\u2200 {A B : Cone K} (f : A \\u27f6 B) [inst : IsIso ((functoriality K F).map f)], IsIso f\\n[PROOFSTEP]\\nintro A B f _\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\nhaveI : IsIso (F.map f.Hom) := (Cones.forget (K \\u22d9 F)).map_isIso ((Cones.functoriality K F).map f)\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\nthis : IsIso (F.map f.Hom)\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\nhaveI := ReflectsIsomorphisms.reflects F f.Hom\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\nthis\\u271d : IsIso (F.map f.Hom)\\nthis : IsIso f.Hom\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\napply cone_iso_of_hom_iso\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cocone F\\nf g : c \\u27f6 c'\\nw : f.Hom = g.Hom\\n\\u22a2 f = g\\n[PROOFSTEP]\\ncases f\\n[GOAL]\\ncase mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cocone F\\ng : c \\u27f6 c'\\nHom\\u271d : c.pt \\u27f6 c'.pt\\nw\\u271d : \\u2200 (j : J), NatTrans.app c.\\u03b9 j \\u226b Hom\\u271d = NatTrans.app c'.\\u03b9 j\\nw : (mk Hom\\u271d).Hom = g.Hom\\n\\u22a2 mk Hom\\u271d = g\\n[PROOFSTEP]\\ncases g\\n[GOAL]\\ncase mk.mk\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc c' : Cocone F\\nHom\\u271d\\u00b9 : c.pt \\u27f6 c'.pt\\nw\\u271d\\u00b9 : \\u2200 (j : J), NatTrans.app c.\\u03b9 j \\u226b Hom\\u271d\\u00b9 = NatTrans.app c'.\\u03b9 j\\nHom\\u271d : c.pt \\u27f6 c'.pt\\nw\\u271d : \\u2200 (j : J), NatTrans.app c.\\u03b9 j \\u226b Hom\\u271d = NatTrans.app c'.\\u03b9 j\\nw : (mk Hom\\u271d\\u00b9).Hom = (mk Hom\\u271d).Hom\\n\\u22a2 mk Hom\\u271d\\u00b9 = mk Hom\\u271d\\n[PROOFSTEP]\\ncongr\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF K : J \\u2964 C\\nc d : Cocone K\\nf : c \\u27f6 d\\ni : IsIso f.Hom\\n\\u22a2 f \\u226b CoconeMorphism.mk (inv f.Hom) = \\ud835\\udfd9 c \\u2227 CoconeMorphism.mk (inv f.Hom) \\u226b f = \\ud835\\udfd9 d\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\ne : K \\u224c J\\ns : Cocone (e.functor \\u22d9 F)\\nk : K\\n\\u22a2 NatTrans.app\\n (((whiskering e.inverse \\u22d9\\n precompose\\n ((leftUnitor F).inv \\u226b whiskerRight e.counitIso.inv F \\u226b (associator e.inverse e.functor F).inv)) \\u22d9\\n whiskering e.functor).obj\\n s).\\u03b9\\n k \\u226b\\n (Iso.refl\\n (((whiskering e.inverse \\u22d9\\n precompose\\n ((leftUnitor F).inv \\u226b whiskerRight e.counitIso.inv F \\u226b (associator e.inverse e.functor F).inv)) \\u22d9\\n whiskering e.functor).obj\\n s).pt).hom =\\n NatTrans.app ((\\ud835\\udfed (Cocone (e.functor \\u22d9 F))).obj s).\\u03b9 k\\n[PROOFSTEP]\\nsimpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cocone F\\n\\u22a2 \\u2200 \\u2983X Y : J\\u2984 (f : X \\u27f6 Y),\\n (F \\u22d9 G).map f \\u226b (fun j => G.map (NatTrans.app A.\\u03b9 j)) Y =\\n (fun j => G.map (NatTrans.app A.\\u03b9 j)) X \\u226b ((const J).obj (G.obj A.pt)).map f\\n[PROOFSTEP]\\nintros\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cocone F\\nX\\u271d Y\\u271d : J\\nf\\u271d : X\\u271d \\u27f6 Y\\u271d\\n\\u22a2 (F \\u22d9 G).map f\\u271d \\u226b (fun j => G.map (NatTrans.app A.\\u03b9 j)) Y\\u271d =\\n (fun j => G.map (NatTrans.app A.\\u03b9 j)) X\\u271d \\u226b ((const J).obj (G.obj A.pt)).map f\\u271d\\n[PROOFSTEP]\\nerw [\\u2190 G.map_comp]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nA : Cocone F\\nX\\u271d Y\\u271d : J\\nf\\u271d : X\\u271d \\u27f6 Y\\u271d\\n\\u22a2 G.map (F.map f\\u271d \\u226b NatTrans.app A.\\u03b9 Y\\u271d) =\\n (fun j => G.map (NatTrans.app A.\\u03b9 j)) X\\u271d \\u226b ((const J).obj (G.obj A.pt)).map f\\u271d\\n[PROOFSTEP]\\naesop_cat\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nX\\u271d Y\\u271d : Cocone F\\nf : X\\u271d \\u27f6 Y\\u271d\\n\\u22a2 \\u2200 (j : J),\\n NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03b9 j) }) X\\u271d).\\u03b9 j \\u226b\\n G.map f.Hom =\\n NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03b9 j) }) Y\\u271d).\\u03b9 j\\n[PROOFSTEP]\\nintros\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\nX\\u271d Y\\u271d : Cocone F\\nf : X\\u271d \\u27f6 Y\\u271d\\nj\\u271d : J\\n\\u22a2 NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03b9 j) }) X\\u271d).\\u03b9 j\\u271d \\u226b\\n G.map f.Hom =\\n NatTrans.app ((fun A => { pt := G.obj A.pt, \\u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\\u03b9 j) }) Y\\u271d).\\u03b9 j\\u271d\\n[PROOFSTEP]\\nrw [\\u2190 Functor.map_comp, CoconeMorphism.w]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d\\u00b9 : Full G\\ninst\\u271d : Faithful G\\nX\\u271d Y\\u271d : Cocone F\\nt : (functoriality F G).obj X\\u271d \\u27f6 (functoriality F G).obj Y\\u271d\\nj : J\\n\\u22a2 G.map (NatTrans.app X\\u271d.\\u03b9 j \\u226b G.preimage t.Hom) = G.map (NatTrans.app Y\\u271d.\\u03b9 j)\\n[PROOFSTEP]\\nsimpa using t.w j\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nX Y : Cocone F\\nf g : X \\u27f6 Y\\ne : (functoriality F G).map f = (functoriality F G).map g\\n\\u22a2 f = g\\n[PROOFSTEP]\\napply CoconeMorphism.ext\\n[GOAL]\\ncase w\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nX Y : Cocone F\\nf g : X \\u27f6 Y\\ne : (functoriality F G).map f = (functoriality F G).map g\\n\\u22a2 f.Hom = g.Hom\\n[PROOFSTEP]\\nlet h := CoconeMorphism.mk.inj e\\n[GOAL]\\ncase w\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ninst\\u271d : Faithful G\\nX Y : Cocone F\\nf g : X \\u27f6 Y\\ne : (functoriality F G).map f = (functoriality F G).map g\\nh : G.map f.Hom = G.map g.Hom := CoconeMorphism.mk.inj e\\n\\u22a2 f.Hom = g.Hom\\n[PROOFSTEP]\\napply G.map_injective h\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nG : C \\u2964 D\\ne : C \\u224c D\\nf : (F \\u22d9 e.functor) \\u22d9 e.inverse \\u2245 F :=\\n associator F e.functor e.inverse \\u226a\\u226b isoWhiskerLeft F e.unitIso.symm \\u226a\\u226b rightUnitor F\\nc : Cocone (F \\u22d9 e.functor)\\nj : J\\n\\u22a2 NatTrans.app\\n (((functoriality (F \\u22d9 e.functor) e.inverse \\u22d9 (precomposeEquivalence f.symm).functor) \\u22d9\\n functoriality F e.functor).obj\\n c).\\u03b9\\n j \\u226b\\n (e.counitIso.app c.pt).hom =\\n NatTrans.app ((\\ud835\\udfed (Cocone (F \\u22d9 e.functor))).obj c).\\u03b9 j\\n[PROOFSTEP]\\nsimp [\\u2190 Equivalence.counitInv_app_functor]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d : ReflectsIsomorphisms F\\nK : J \\u2964 C\\n\\u22a2 ReflectsIsomorphisms (functoriality K F)\\n[PROOFSTEP]\\nconstructor\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2074 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u00b3 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b2 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b9 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d : ReflectsIsomorphisms F\\nK : J \\u2964 C\\n\\u22a2 \\u2200 {A B : Cocone K} (f : A \\u27f6 B) [inst : IsIso ((functoriality K F).map f)], IsIso f\\n[PROOFSTEP]\\nintro A B f _\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cocone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\nhaveI : IsIso (F.map f.Hom) := (Cocones.forget (K \\u22d9 F)).map_isIso ((Cocones.functoriality K F).map f)\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cocone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\nthis : IsIso (F.map f.Hom)\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\nhaveI := ReflectsIsomorphisms.reflects F f.Hom\\n[GOAL]\\ncase reflects\\nJ : Type u\\u2081\\ninst\\u271d\\u2075 : Category.{v\\u2081, u\\u2081} J\\nK\\u271d : Type u\\u2082\\ninst\\u271d\\u2074 : Category.{v\\u2082, u\\u2082} K\\u271d\\nC : Type u\\u2083\\ninst\\u271d\\u00b3 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d\\u00b2 : Category.{v\\u2084, u\\u2084} D\\nF\\u271d : J \\u2964 C\\nG F : C \\u2964 D\\ninst\\u271d\\u00b9 : ReflectsIsomorphisms F\\nK : J \\u2964 C\\nA B : Cocone K\\nf : A \\u27f6 B\\ninst\\u271d : IsIso ((functoriality K F).map f)\\nthis\\u271d : IsIso (F.map f.Hom)\\nthis : IsIso f.Hom\\n\\u22a2 IsIso f\\n[PROOFSTEP]\\napply cocone_iso_of_hom_iso\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : Cocone F\\nf : X \\u27f6 Y\\nj : J\\u1d52\\u1d56\\n\\u22a2 f.Hom.op \\u226b NatTrans.app (Cocone.op X).\\u03c0 j = NatTrans.app (Cocone.op Y).\\u03c0 j\\n[PROOFSTEP]\\napply Quiver.Hom.unop_inj\\n[GOAL]\\ncase a\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : Cocone F\\nf : X \\u27f6 Y\\nj : J\\u1d52\\u1d56\\n\\u22a2 (f.Hom.op \\u226b NatTrans.app (Cocone.op X).\\u03c0 j).unop = (NatTrans.app (Cocone.op Y).\\u03c0 j).unop\\n[PROOFSTEP]\\ndsimp\\n[GOAL]\\ncase a\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : Cocone F\\nf : X \\u27f6 Y\\nj : J\\u1d52\\u1d56\\n\\u22a2 NatTrans.app X.\\u03b9 j.unop \\u226b f.Hom = NatTrans.app Y.\\u03b9 j.unop\\n[PROOFSTEP]\\napply CoconeMorphism.w\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : (Cone F.op)\\u1d52\\u1d56\\nf : X \\u27f6 Y\\nj : J\\n\\u22a2 NatTrans.app ((fun c => Cone.unop c.unop) X).\\u03b9 j \\u226b f.unop.Hom.unop = NatTrans.app ((fun c => Cone.unop c.unop) Y).\\u03b9 j\\n[PROOFSTEP]\\napply Quiver.Hom.op_inj\\n[GOAL]\\ncase a\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : (Cone F.op)\\u1d52\\u1d56\\nf : X \\u27f6 Y\\nj : J\\n\\u22a2 (NatTrans.app ((fun c => Cone.unop c.unop) X).\\u03b9 j \\u226b f.unop.Hom.unop).op =\\n (NatTrans.app ((fun c => Cone.unop c.unop) Y).\\u03b9 j).op\\n[PROOFSTEP]\\ndsimp\\n[GOAL]\\ncase a\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : (Cone F.op)\\u1d52\\u1d56\\nf : X \\u27f6 Y\\nj : J\\n\\u22a2 f.unop.Hom \\u226b NatTrans.app X.unop.\\u03c0 (op j) = NatTrans.app Y.unop.\\u03c0 (op j)\\n[PROOFSTEP]\\napply ConeMorphism.w\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : (Cone F.op)\\u1d52\\u1d56\\n\\u22a2 (Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \\u22d9\\n Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n c \\u2245\\n (\\ud835\\udfed (Cone F.op)\\u1d52\\u1d56).obj c\\n[PROOFSTEP]\\ninduction c\\n[GOAL]\\ncase h\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX\\u271d : Cone F.op\\n\\u22a2 (Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \\u22d9\\n Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n (op X\\u271d) \\u2245\\n (\\ud835\\udfed (Cone F.op)\\u1d52\\u1d56).obj (op X\\u271d)\\n[PROOFSTEP]\\napply Iso.op\\n[GOAL]\\ncase h.\\u03b1\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX\\u271d : Cone F.op\\n\\u22a2 X\\u271d \\u2245\\n Cocone.op\\n ((Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop }).obj\\n (op X\\u271d))\\n[PROOFSTEP]\\nexact Cones.ext (Iso.refl _)\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nX Y : (Cone F.op)\\u1d52\\u1d56\\nf : X \\u27f6 Y\\n\\u22a2 ((Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \\u22d9\\n Functor.mk\\n { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\\n f \\u226b\\n ((fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c) Y).hom).unop.Hom =\\n (((fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c) X).hom \\u226b\\n (\\ud835\\udfed (Cone F.op)\\u1d52\\u1d56).map f).unop.Hom\\n[PROOFSTEP]\\nsimp\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\n\\u22a2 (Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\\n (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\\ud835\\udfed (Cocone F)).obj c).pt)).hom c) \\u226b\\n NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\\n ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj c) =\\n \\ud835\\udfd9 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj c)\\n[PROOFSTEP]\\napply Quiver.Hom.unop_inj\\n[GOAL]\\ncase a\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\n\\u22a2 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\\n (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\\ud835\\udfed (Cocone F)).obj c).pt)).hom c) \\u226b\\n NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\\n ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n c)).unop =\\n (\\ud835\\udfd9\\n ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n c)).unop\\n[PROOFSTEP]\\napply ConeMorphism.ext\\n[GOAL]\\ncase a.w\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\n\\u22a2 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\\n (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\\ud835\\udfed (Cocone F)).obj c).pt)).hom c) \\u226b\\n NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\\n ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n c)).unop.Hom =\\n (\\ud835\\udfd9\\n ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\\n c)).unop.Hom\\n[PROOFSTEP]\\ndsimp\\n[GOAL]\\ncase a.w\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\nc : Cocone F\\n\\u22a2 \\ud835\\udfd9 (op c.pt) \\u226b \\ud835\\udfd9 (op c.pt) = \\ud835\\udfd9 (op c.pt)\\n[PROOFSTEP]\\napply comp_id\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\u1d52\\u1d56\\nc : Cone F.leftOp\\nj : J\\n\\u22a2 NatTrans.app (coconeOfConeLeftOp c).\\u03b9 j = (NatTrans.app c.\\u03c0 (op j)).op\\n[PROOFSTEP]\\ndsimp only [coconeOfConeLeftOp]\\n[GOAL]\\nJ : Type u\\u2081\\ninst\\u271d\\u00b3 : Category.{v\\u2081, u\\u2081} J\\nK : Type u\\u2082\\ninst\\u271d\\u00b2 : Category.{v\\u2082, u\\u2082} K\\nC : Type u\\u2083\\ninst\\u271d\\u00b9 : Category.{v\\u2083, u\\u2083} C\\nD : Type u\\u2084\\ninst\\u271d : Category.{v\\u2084, u\\u2084} D\\nF : J \\u2964 C\\u1d52\\u1d56\\nc : Cone F.leftOp\\nj : J\\n\\u22a2 NatTrans.app (NatTrans.removeLeftOp c.\\u03c0) j = (NatTrans.app c.\\u03c0 (op j)).op\\n[PROOFSTEP]\\nsimp\\n\"} {\"text\": \"lemma interior_UNIV [simp]: \\\"interior UNIV = UNIV\\\"\"} {\"text\": \"Check Engine Light - What Does It Mean?\\nThe Check Engine Light (CEL) is an integral part of your vehicle\\u2019s Onboard Diagnostics System. The problem is that an illuminated CEL can mean pretty much anything: Your gas cap could be loose or, in a worst case scenario, your engine could be malfunctioning.\\nReally, the CEL is merely an indicator something in or on the vehicle is (most likely) not performing as it should. Once the vehicle\\u2019s electronic control system finds a problem it cannot adjust it will illuminate the warning light and store a code in its memory indicating the problem.\\nIn 1996 vehicle manufacturers were required to adopt standardized diagnostic trouble codes, and nowadays mechanics can quickly diagnose problems simply by inserting a device into the vehicle that reads these codes (called a \\u2018Code Reader\\u2019). In fact, mechanically inclined readers can even purchase a Code Reader at a hardware store and insert and read the vehicles code themselves.\\nHowever, there a few things to consider before you purchase a code reader: For example, the problem isn\\u2019t always what\\u2019s indicated in the code. The code could indicate a faulty battery, when in fact the wires connected to the battery have simply been frayed over time. Purchasing a new battery might also be a good idea, but the CEL likely won\\u2019t turn off until the faulty wires are also replaced.\\nIn truth, your dealer or mechanic is best suited to fix your CEL. They have invested thousands in equipment to be able to properly service your vehicle and no one knows your vehicle better than a certified mechanic.\\nBest of all, the ODB scan is (likely) covered under your factory warranty, so you won\\u2019t pay a cent. Those not covered under warranty will pay $125 at WallceChev, which includes a full scan, diagnostic assessment, and work order. We\\u2019ll also fully explain the problem, what caused it and the steps to get you back on the road, safely.\\nIgnoring the problem can also be a bad idea: We frequently see vehicles with repairs that could be avoided had the issue been diagnosed earlier. A healthy car is a happy car!\\nNow that you know how to turn off the CEL\\u2026 do you know what could cause your Check Engline Light to switch on?\"} {\"text\": \"(* Author: Lukas Bulwahn <lukas.bulwahn-at-gmail.com> *)\\n\\nsection \\\\<open>Cardinality of Number Partitions\\\\<close>\\n\\ntheory Card_Number_Partitions\\nimports Number_Partition\\nbegin\\n\\nsubsection \\\\<open>The Partition Function\\\\<close>\\n\\nfun Partition :: \\\"nat \\\\<Rightarrow> nat \\\\<Rightarrow> nat\\\"\\nwhere\\n \\\"Partition 0 0 = 1\\\"\\n| \\\"Partition 0 (Suc k) = 0\\\"\\n| \\\"Partition (Suc m) 0 = 0\\\"\\n| \\\"Partition (Suc m) (Suc k) = Partition m k + Partition (m - k) (Suc k)\\\"\\n\\nlemma Partition_less:\\n assumes \\\"m < k\\\"\\n shows \\\"Partition m k = 0\\\"\\nusing assms by (induct m k rule: Partition.induct) auto\\n\\nlemma Partition_sum_Partition_diff:\\n assumes \\\"k \\\\<le> m\\\"\\n shows \\\"Partition m k = (\\\\<Sum>i\\\\<le>k. Partition (m - k) i)\\\"\\nusing assms by (induct m k rule: Partition.induct) auto\\n\\nlemma Partition_parts1:\\n \\\"Partition (Suc m) (Suc 0) = 1\\\"\\nby (induct m) auto\\n\\nlemma Partition_diag:\\n \\\"Partition (Suc m) (Suc m) = 1\\\"\\nby (induct m) auto\\n\\nlemma Partition_diag1:\\n \\\"Partition (Suc (Suc m)) (Suc m) = 1\\\"\\nby (induct m) auto\\n\\nlemma Partition_parts2:\\n shows \\\"Partition m 2 = m div 2\\\"\\nproof (induct m rule: nat_less_induct)\\n fix m\\n assume hypothesis: \\\"\\\\<forall>n<m. Partition n 2 = n div 2\\\"\\n have \\\"(m = 0 \\\\<or> m = 1) \\\\<or> m \\\\<ge> 2\\\" by auto\\n from this show \\\"Partition m 2 = m div 2\\\"\\n proof\\n assume \\\"m = 0 \\\\<or> m = 1\\\"\\n from this show ?thesis by (auto simp add: numerals(2))\\n next\\n assume \\\"2 \\\\<le> m\\\"\\n from this obtain m' where m': \\\"m = Suc (Suc m')\\\" by (metis add_2_eq_Suc le_Suc_ex)\\n from hypothesis this have \\\"Partition m' 2 = m' div 2\\\" by simp\\n from this m' show ?thesis\\n using Partition_parts1 Partition.simps(4)[of \\\"Suc m'\\\" \\\"Suc 0\\\"] div2_Suc_Suc\\n by (simp add: numerals(2) del: Partition.simps)\\n qed\\nqed\\n\\nsubsection \\\\<open>Cardinality of Number Partitions\\\\<close>\\n\\nlemma set_rewrite1:\\n \\\"{p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k \\\\<and> p 1 \\\\<noteq> 0}\\n = (\\\\<lambda>p. p(1 := p 1 + 1)) ` {p. p partitions m \\\\<and> sum p {..m} = k}\\\" (is \\\"?S = ?T\\\")\\nproof\\n {\\n fix p\\n assume assms: \\\"p partitions Suc m\\\" \\\"sum p {..Suc m} = Suc k\\\" \\\"0 < p 1\\\"\\n have \\\"p(1 := p 1 - 1) partitions m\\\"\\n using assms by (metis partitions_remove1 diff_Suc_1)\\n moreover have \\\"(\\\\<Sum>i\\\\<le>m. (p(1 := p 1 - 1)) i) = k\\\"\\n using assms by (metis count_remove1 diff_Suc_1)\\n ultimately have \\\"p(1 := p 1 - 1) \\\\<in> {p. p partitions m \\\\<and> sum p {..m} = k}\\\" by simp\\n moreover have \\\"p = p(1 := p 1 - 1, 1 := (p(1 := p 1 - 1)) 1 + 1)\\\"\\n using \\\\<open>0 < p 1\\\\<close> by auto\\n ultimately have \\\"p \\\\<in> (\\\\<lambda>p. p(1 := p 1 + 1)) ` {p. p partitions m \\\\<and> sum p {..m} = k}\\\" by blast\\n }\\n from this show \\\"?S \\\\<subseteq> ?T\\\" by blast\\nnext\\n {\\n fix p\\n assume assms: \\\"p partitions m\\\" \\\"sum p {..m} = k\\\"\\n have \\\"(p(1 := p 1 + 1)) partitions Suc m\\\" (is ?g1)\\n using assms by (metis partitions_insert1 Suc_eq_plus1 zero_less_one)\\n moreover have \\\"sum (p(1 := p 1 + 1)) {..Suc m} = Suc k\\\" (is ?g2)\\n using assms by (metis count_insert1 Suc_eq_plus1)\\n moreover have \\\"(p(1 := p 1 + 1)) 1 \\\\<noteq> 0\\\" (is ?g3) by auto\\n ultimately have \\\"?g1 \\\\<and> ?g2 \\\\<and> ?g3\\\" by simp\\n }\\n from this show \\\"?T \\\\<subseteq> ?S\\\" by auto\\nqed\\n\\nlemma set_rewrite2:\\n \\\"{p. p partitions m \\\\<and> sum p {..m} = k \\\\<and> p 1 = 0}\\n = (\\\\<lambda>p. (\\\\<lambda>i. p (i - 1))) ` {p. p partitions (m - k) \\\\<and> sum p {..m - k} = k}\\\"\\n (is \\\"?S = ?T\\\")\\nproof\\n {\\n fix p\\n assume assms: \\\"p partitions m\\\" \\\"sum p {..m} = k\\\" \\\"p 1 = 0\\\"\\n have \\\"(\\\\<lambda>i. p (i + 1)) partitions m - k\\\"\\n using assms partitions_decrease1 by blast\\n moreover from assms have \\\"sum (\\\\<lambda>i. p (i + 1)) {..m - k} = k\\\"\\n using assms count_decrease1 by blast\\n ultimately have \\\"(\\\\<lambda>i. p (i + 1)) \\\\<in> {p. p partitions m - k \\\\<and> sum p {..m - k} = k}\\\" by simp\\n moreover have \\\"p = (\\\\<lambda>i. p ((i - 1) + 1))\\\"\\n proof (rule ext)\\n fix i show \\\"p i = p (i - 1 + 1)\\\"\\n using assms by (cases i) (auto elim!: partitionsE)\\n qed\\n ultimately have \\\"p \\\\<in> (\\\\<lambda>p. (\\\\<lambda>i. p (i - 1))) ` {p. p partitions m - k \\\\<and> sum p {..m - k} = k}\\\" by auto\\n }\\n from this show \\\"?S \\\\<subseteq> ?T\\\" by auto\\nnext\\n {\\n fix p\\n assume assms: \\\"p partitions m - k\\\" \\\"sum p {..m - k} = k\\\"\\n from assms have \\\"(\\\\<lambda>i. p (i - 1)) partitions m\\\" (is ?g1)\\n using partitions_increase1 by blast\\n moreover from assms have \\\"(\\\\<Sum>i\\\\<le>m. p (i - 1)) = k\\\" (is ?g2)\\n using count_increase1 by blast\\n moreover from assms have \\\"p 0 = 0\\\" (is ?g3)\\n by (auto elim!: partitionsE)\\n ultimately have \\\"?g1 \\\\<and> ?g2 \\\\<and> ?g3\\\" by simp\\n }\\n from this show \\\"?T \\\\<subseteq> ?S\\\" by auto\\nqed\\n\\ntheorem card_partitions_k_parts:\\n \\\"card {p. p partitions n \\\\<and> (\\\\<Sum>i\\\\<le>n. p i) = k} = Partition n k\\\"\\nproof (induct n k rule: Partition.induct)\\n case 1\\n have eq: \\\"{p. p = (\\\\<lambda>x. 0) \\\\<and> p 0 = 0} = {(\\\\<lambda>x. 0)}\\\" by auto\\n show \\\"card {p. p partitions 0 \\\\<and> sum p {..0} = 0} = Partition 0 0\\\"\\n by (simp add: partitions_zero eq)\\nnext\\n case (2 k)\\n have eq: \\\"{p. p = (\\\\<lambda>x. 0) \\\\<and> p 0 = Suc k} = {}\\\" by auto\\n show \\\"card {p. p partitions 0 \\\\<and> sum p {..0} = Suc k} = Partition 0 (Suc k)\\\"\\n by (simp add: partitions_zero eq)\\nnext\\n case (3 m)\\n have eq: \\\"{p. p partitions Suc m \\\\<and> sum p {..Suc m} = 0} = {}\\\"\\n by (fastforce elim!: partitionsE simp add: le_Suc_eq)\\n from this show \\\"card {p. p partitions Suc m \\\\<and> sum p {..Suc m} = 0} = Partition (Suc m) 0\\\"\\n by (simp only: Partition.simps card_empty)\\nnext\\n case (4 m k)\\n let ?set1 = \\\"{p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k \\\\<and> p 1 \\\\<noteq> 0}\\\"\\n let ?set2 = \\\"{p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k \\\\<and> p 1 = 0}\\\"\\n have \\\"finite {p. p partitions Suc m}\\\"\\n by (simp add: finite_partitions)\\n from this have finite_sets: \\\"finite ?set1\\\" \\\"finite ?set2\\\" by simp+\\n have set_eq: \\\"{p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k} = ?set1 \\\\<union> ?set2\\\" by auto\\n have disjoint: \\\"?set1 \\\\<inter> ?set2 = {}\\\" by auto\\n have inj1: \\\"inj_on (\\\\<lambda>p. p(1 := p 1 + 1)) {p. p partitions m \\\\<and> sum p {..m} = k}\\\"\\n by (auto intro!: inj_onI) (metis diff_Suc_1 fun_upd_idem_iff fun_upd_upd)\\n have inj2: \\\"inj_on (\\\\<lambda>p i. p (i - 1)) {p. p partitions m - k \\\\<and> sum p {..m - k} = Suc k}\\\"\\n by (auto intro!: inj_onI simp add: fun_eq_iff) (metis add_diff_cancel_right')\\n have card1: \\\"card ?set1 = Partition m k\\\"\\n using inj1 4(1) by (simp only: set_rewrite1 card_image)\\n have card2: \\\"card ?set2 = Partition (m - k) (Suc k)\\\"\\n using inj2 4(2) by (simp only: set_rewrite2 card_image diff_Suc_Suc)\\n have \\\"card {p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k} = Partition m k + Partition (m - k) (Suc k)\\\"\\n using finite_sets disjoint by (simp only: set_eq card_Un_disjoint card1 card2)\\n from this show \\\"card {p. p partitions Suc m \\\\<and> sum p {..Suc m} = Suc k} = Partition (Suc m) (Suc k)\\\"\\n by auto\\nqed\\n\\ntheorem card_partitions:\\n \\\"card {p. p partitions n} = (\\\\<Sum>k\\\\<le>n. Partition n k)\\\"\\nproof -\\n have seteq: \\\"{p. p partitions n} = \\\\<Union>((\\\\<lambda>k. {p. p partitions n \\\\<and> (\\\\<Sum>i\\\\<le>n. p i) = k}) ` {..n})\\\"\\n by (auto intro: partitions_parts_bounded)\\n have finite: \\\"\\\\<And>k. finite {p. p partitions n \\\\<and> sum p {..n} = k}\\\"\\n by (simp add: finite_partitions)\\n have \\\"card {p. p partitions n} = card (\\\\<Union>((\\\\<lambda>k. {p. p partitions n \\\\<and> (\\\\<Sum>i\\\\<le>n. p i) = k}) ` {..n}))\\\"\\n using finite by (simp add: seteq)\\n also have \\\"... = (\\\\<Sum>x\\\\<le>n. card {p. p partitions n \\\\<and> sum p {..n} = x})\\\"\\n using finite by (subst card_UN_disjoint) auto\\n also have \\\"... = (\\\\<Sum>k\\\\<le>n. Partition n k)\\\"\\n by (simp add: card_partitions_k_parts)\\n finally show ?thesis .\\nqed\\n\\nlemma card_partitions_atmost_k_parts:\\n \\\"card {p. p partitions n \\\\<and> sum p {..n} \\\\<le> k} = Partition (n + k) k\\\"\\nproof -\\n have \\\"card {p. p partitions n \\\\<and> sum p {..n} \\\\<le> k} =\\n card (\\\\<Union>((\\\\<lambda>k'. {p. p partitions n \\\\<and> sum p {..n} = k'}) ` {..k}))\\\"\\n proof -\\n have \\\"{p. p partitions n \\\\<and> sum p {..n} \\\\<le> k} =\\n (\\\\<Union>k'\\\\<le>k. {p. p partitions n \\\\<and> sum p {..n} = k'})\\\" by auto\\n from this show ?thesis by simp\\n qed\\n also have \\\"card (\\\\<Union>((\\\\<lambda>k'. {p. p partitions n \\\\<and> sum p {..n} = k'}) ` {..k})) =\\n sum (\\\\<lambda>k'. card {p. p partitions n \\\\<and> sum p {..n} = k'}) {..k}\\\"\\n using finite_partitions_k_parts by (subst card_UN_disjoint) auto\\n also have \\\"\\\\<dots> = sum (\\\\<lambda>k'. Partition n k') {..k}\\\"\\n using card_partitions_k_parts by simp\\n also have \\\"\\\\<dots> = Partition (n + k) k\\\"\\n using Partition_sum_Partition_diff by simp\\n finally show ?thesis .\\nqed\\n\\nsubsection \\\\<open>Cardinality of Number Partitions as Multisets of Natural Numbers\\\\<close>\\n\\nlemma bij_betw_multiset_number_partition_with_size:\\n \\\"bij_betw count {N. number_partition n N \\\\<and> size N = k} {p. p partitions n \\\\<and> sum p {..n} = k}\\\"\\nproof (rule bij_betw_byWitness[where f'=\\\"Abs_multiset\\\"])\\n show \\\"\\\\<forall>N\\\\<in>{N. number_partition n N \\\\<and> size N = k}. Abs_multiset (count N) = N\\\"\\n using count_inverse by blast\\n show \\\"\\\\<forall>p\\\\<in>{p. p partitions n \\\\<and> sum p {..n} = k}. count (Abs_multiset p) = p\\\"\\n by (auto simp add: multiset_def partitions_imp_finite_elements)\\n show \\\"count ` {N. number_partition n N \\\\<and> size N = k} \\\\<subseteq> {p. p partitions n \\\\<and> sum p {..n} = k}\\\"\\n by (auto simp add: count_partitions_iff size_nat_multiset_eq) \\n show \\\"Abs_multiset ` {p. p partitions n \\\\<and> sum p {..n} = k} \\\\<subseteq> {N. number_partition n N \\\\<and> size N = k}\\\"\\n using partitions_iff_Abs_multiset size_nat_multiset_eq partitions_imp_multiset by fastforce\\nqed\\n\\nlemma bij_betw_multiset_number_partition_with_atmost_size:\\n \\\"bij_betw count {N. number_partition n N \\\\<and> size N \\\\<le> k} {p. p partitions n \\\\<and> sum p {..n} \\\\<le> k}\\\"\\nproof (rule bij_betw_byWitness[where f'=\\\"Abs_multiset\\\"])\\n show \\\"\\\\<forall>N\\\\<in>{N. number_partition n N \\\\<and> size N \\\\<le> k}. Abs_multiset (count N) = N\\\"\\n using count_inverse by blast\\n show \\\"\\\\<forall>p\\\\<in>{p. p partitions n \\\\<and> sum p {..n} \\\\<le> k}. count (Abs_multiset p) = p\\\"\\n by (auto simp add: multiset_def partitions_imp_finite_elements)\\n show \\\"count ` {N. number_partition n N \\\\<and> size N \\\\<le> k} \\\\<subseteq> {p. p partitions n \\\\<and> sum p {..n} \\\\<le> k}\\\"\\n by (auto simp add: count_partitions_iff size_nat_multiset_eq)\\n show \\\"Abs_multiset ` {p. p partitions n \\\\<and> sum p {..n} \\\\<le> k} \\\\<subseteq> {N. number_partition n N\\\\<and> size N \\\\<le> k}\\\"\\n using partitions_iff_Abs_multiset size_nat_multiset_eq partitions_imp_multiset by fastforce\\nqed\\n\\ntheorem card_number_partitions_with_atmost_k_parts:\\n shows \\\"card {N. number_partition n N \\\\<and> size N \\\\<le> x} = Partition (n + x) x\\\"\\nproof -\\n have \\\"bij_betw count {N. number_partition n N \\\\<and> size N \\\\<le> x} {p. p partitions n \\\\<and> sum p {..n} \\\\<le> x}\\\"\\n by (rule bij_betw_multiset_number_partition_with_atmost_size)\\n from this have \\\"card {N. number_partition n N \\\\<and> size N \\\\<le> x} = card {p. p partitions n \\\\<and> sum p {..n} \\\\<le> x}\\\"\\n by (rule bij_betw_same_card)\\n also have \\\"card {p. p partitions n \\\\<and> sum p {..n} \\\\<le> x} = Partition (n + x) x\\\"\\n by (rule card_partitions_atmost_k_parts)\\n finally show ?thesis .\\nqed\\n\\ntheorem card_partitions_with_k_parts:\\n \\\"card {N. number_partition n N \\\\<and> size N = k} = Partition n k\\\"\\nproof -\\n have \\\"bij_betw count {N. number_partition n N \\\\<and> size N = k} {p. p partitions n \\\\<and> sum p {..n} = k}\\\"\\n by (rule bij_betw_multiset_number_partition_with_size)\\n from this have \\\"card {N. number_partition n N \\\\<and> size N = k} = card {p. p partitions n \\\\<and> sum p {..n} = k}\\\"\\n by (rule bij_betw_same_card)\\n also have \\\"\\\\<dots> = Partition n k\\\" by (rule card_partitions_k_parts)\\n finally show ?thesis .\\nqed\\n\\nsubsection \\\\<open>Cardinality of Number Partitions with only 1-parts\\\\<close>\\n\\nlemma number_partition1_eq_replicate_mset:\\n \\\"{N. (\\\\<forall>n. n\\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N} = {replicate_mset n 1}\\\"\\nproof\\n show \\\"{N. (\\\\<forall>n. n \\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N} \\\\<subseteq> {replicate_mset n 1}\\\"\\n proof\\n fix N\\n assume N: \\\"N \\\\<in> {N. (\\\\<forall>n. n \\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N}\\\"\\n have \\\"N = replicate_mset n 1\\\"\\n proof (rule multiset_eqI)\\n fix i\\n have \\\"count N 1 = sum_mset N\\\"\\n proof cases\\n assume \\\"N = {#}\\\"\\n from this show ?thesis by auto\\n next\\n assume \\\"N \\\\<noteq> {#}\\\"\\n from this N have \\\"1 \\\\<in># N\\\" by blast\\n from this N show ?thesis\\n by (auto simp add: sum_mset_sum_count sum.remove[where x=\\\"1\\\"] simp del: One_nat_def)\\n qed\\n from N this show \\\"count N i = count (replicate_mset n 1) i\\\"\\n unfolding number_partition_def by (auto intro: count_inI)\\n qed\\n from this show \\\"N \\\\<in> {replicate_mset n 1}\\\" by simp\\n qed\\nnext\\n show \\\"{replicate_mset n 1} \\\\<subseteq> {N. (\\\\<forall>n. n \\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N}\\\"\\n unfolding number_partition_def by auto\\nqed\\n\\n\\n\\nlemma card_number_partitions_with_only_parts_1_eq_0:\\n assumes \\\"x < n\\\"\\n shows \\\"card {N. (\\\\<forall>n. n\\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N \\\\<and> size N \\\\<le> x} = 0\\\" (is \\\"card ?N = _\\\")\\nproof -\\n have \\\"\\\\<forall>N \\\\<in> {N. (\\\\<forall>n. n \\\\<in># N \\\\<longrightarrow> n = 1) \\\\<and> number_partition n N}. size N = n\\\"\\n unfolding number_partition1_eq_replicate_mset by simp\\n from this number_partition1_eq_replicate_mset\\\\<open>x < n\\\\<close> have \\\"?N = {}\\\" by auto\\n from this show ?thesis by (simp only: card_empty)\\nqed\\n\\nend\\n\"} {\"text\": \"lemmas swap_apply1 = swap_apply(1)\"} {\"text\": \"(* Practice of Natural Deduction *)\\n(* http://rainyday.blog.so-net.ne.jp/2017-09-24 *)\\n\\ntheory NaturalDeduction\\n imports Main\\nbegin\\n\\ntheorem Example_1_4:\\n (*fixes P Q*)\\n assumes 1: \\\"P \\\\<and> Q\\\"\\n assumes 2: \\\"R\\\"\\n shows \\\"Q \\\\<and> R\\\"\\nproof -\\n have 3: \\\"Q\\\" using 1 by (rule conjunct2)\\n show 4: \\\"Q \\\\<and> R\\\" using 3 2 by (rule conjI)\\nqed\\n\\nfind_theorems \\\"\\\\<not>\\\\<not> _ \\\\<Longrightarrow> _\\\" (* notnotD *)\\ntheorem notnotI: \\\"P \\\\<Longrightarrow> \\\\<not>\\\\<not> P\\\" by auto\\n\\ntheorem Example_1_5:\\n assumes 1: \\\"P\\\"\\n assumes 2: \\\"\\\\<not>\\\\<not> (Q \\\\<and> R)\\\"\\n shows \\\"\\\\<not>\\\\<not> P \\\\<and> R\\\"\\nproof -\\n have 3: \\\"\\\\<not>\\\\<not> P\\\" using 1 by (rule notnotI)\\n have 4: \\\"Q \\\\<and> R\\\" using 2 by (rule notnotD)\\n have 5: \\\"R\\\" using 4 by (rule conjunct2)\\n show 6: \\\"\\\\<not>\\\\<not> P \\\\<and> R\\\" using 3 5 by (rule conjI)\\nqed\\n\\ntheorem mp: \\\"(P\\\\<Longrightarrow>Q) \\\\<Longrightarrow> P \\\\<Longrightarrow> Q\\\" by auto\\ntheorem mt: \\\"(P\\\\<Longrightarrow>Q) \\\\<Longrightarrow> \\\\<not> Q \\\\<Longrightarrow> \\\\<not> P\\\" by auto\\n\\ntheorem Example_1_7:\\n assumes 1: \\\"P \\\\<Longrightarrow> (Q \\\\<Longrightarrow> R)\\\"\\n assumes 2: \\\"P\\\"\\n assumes 3: \\\"\\\\<not> R\\\"\\n shows \\\"\\\\<not> Q\\\"\\nproof -\\n have 4: \\\"Q \\\\<Longrightarrow> R\\\" using 1 2 by (rule mp)\\n show 5: \\\"\\\\<not> Q\\\" using 4 3 by (rule mt)\\nqed\\n\\ntheorem Example_1_9:\\n assumes 1: \\\"\\\\<not> Q \\\\<Longrightarrow> \\\\<not> P\\\"\\n shows \\\"P \\\\<Longrightarrow> \\\\<not>\\\\<not> Q\\\"\\nproof -\\n assume 2: \\\"P\\\"\\n have 3: \\\"\\\\<not>\\\\<not> P\\\" using 2 by (rule notnotI)\\n show 4: \\\"\\\\<not>\\\\<not> Q\\\" using 1 3 by (rule mt)\\nqed\\n\\ntheorem Example_1_11:\\n shows \\\"(Q \\\\<Longrightarrow> R) \\\\<Longrightarrow> (( \\\\<not> Q \\\\<Longrightarrow> \\\\<not> P) \\\\<Longrightarrow> (P \\\\<Longrightarrow> R))\\\"\\nproof -\\n assume 1: \\\"Q \\\\<Longrightarrow> R\\\"\\n show \\\"(\\\\<not> Q \\\\<Longrightarrow> \\\\<not> P) \\\\<Longrightarrow> (P \\\\<Longrightarrow> R)\\\"\\n proof -\\n assume 2: \\\"\\\\<not> Q \\\\<Longrightarrow> \\\\<not> P\\\"\\n show \\\"P \\\\<Longrightarrow> R\\\"\\n proof -\\n assume 3: \\\"P\\\"\\n have 4: \\\"\\\\<not>\\\\<not> P\\\" using 3 by (rule notnotI)\\n have 5: \\\"\\\\<not>\\\\<not> Q\\\" using 2 4 by (rule mt)\\n have 6: \\\"Q\\\" using 5 by (rule notnotD)\\n show 7: \\\"R\\\" using 1 6 by (rule mp)\\n qed\\n qed\\nqed\\n\\ntheorem Example_1_11':\\n shows \\\"(Q \\\\<Longrightarrow> R) \\\\<Longrightarrow> ((\\\\<not> Q \\\\<Longrightarrow> \\\\<not> P) \\\\<Longrightarrow> (P \\\\<Longrightarrow> R))\\\"\\nproof-\\n assume 1: \\\"Q \\\\<Longrightarrow> R\\\"\\n assume 2: \\\"\\\\<not> Q \\\\<Longrightarrow> \\\\<not> P\\\"\\n assume 3: \\\"P\\\"\\n have 4: \\\"\\\\<not>\\\\<not> P\\\" using 3 by (rule notnotI)\\n have 5: \\\"\\\\<not>\\\\<not> Q\\\" using 2 4 by (rule mt)\\n have 6: \\\"Q\\\" using 5 by (rule notnotD)\\n show 7: \\\"R\\\" using 1 6 by (rule mp)\\nqed\\n\\nfind_theorems \\\"_ \\\\<Longrightarrow> _ \\\\<or> _\\\" (* disjI1 , disjI2 *)\\ntheorem disjE: \\\"P \\\\<or> Q \\\\<Longrightarrow> (P \\\\<Longrightarrow> R) \\\\<Longrightarrow> (Q \\\\<Longrightarrow> R) \\\\<Longrightarrow> R\\\" by auto\\n\\ntheorem Example_1_16:\\n assumes 1: \\\"Q \\\\<Longrightarrow> R\\\"\\n shows \\\"P \\\\<or> Q \\\\<Longrightarrow> P \\\\<or> R\\\"\\nproof -\\n assume 2: \\\"P \\\\<or> Q\\\"\\n show \\\"P \\\\<or> R\\\"\\n proof -\\n have 34: \\\"P \\\\<Longrightarrow> P \\\\<or> R\\\"\\n proof -\\n assume 3: \\\"P\\\"\\n show 4: \\\"P \\\\<or> R\\\" using 3 by (rule disjI1)\\n qed\\n have 57: \\\"Q \\\\<Longrightarrow> P \\\\<or> R\\\"\\n proof -\\n assume 5: \\\"Q\\\"\\n have 6: \\\"R\\\" using 1 5 by (rule mp)\\n show 7: \\\"P \\\\<or> R\\\" using 6 by (rule disjI2)\\n qed\\n show \\\"P \\\\<or> R\\\" using 2 34 57 by (rule disjE)\\n qed\\nqed\\n\\ntheorem Example_copy:\\n shows \\\"P \\\\<Longrightarrow> (Q \\\\<Longrightarrow> P)\\\"\\nproof -\\n assume 1: \\\"P\\\"\\n show \\\"Q \\\\<Longrightarrow> P\\\"\\n proof -\\n assume 2: \\\"Q\\\"\\n show 3: \\\"P\\\" using 1 by assumption\\n qed\\nqed\\n\\ntheorem Example_1_21:\\n assumes 1: \\\"P \\\\<Longrightarrow> Q\\\"\\n assumes 2: \\\"P \\\\<Longrightarrow> \\\\<not>Q\\\"\\n shows \\\"\\\\<not> P\\\"\\nproof -\\n have 36: \\\"P \\\\<Longrightarrow> False\\\"\\n proof -\\n assume 3: \\\"P\\\"\\n have 4: \\\"Q\\\" using 1 3 by (rule mp)\\n have 5: \\\"\\\\<not> Q\\\" using 2 3 by (rule mp)\\n show 6: \\\"False\\\" using 5 4 by (rule notE)\\n qed\\n show \\\"\\\\<not> P\\\" using 36 by (rule notI)\\nqed\\n\\nend\\n\"} {\"text\": \"import data.real.irrational\\nimport topology.basic\\nimport algebra.order.floor\\n\\n\\n--OUTPUT 1\\ntheorem irrational_orbit_dense {\\u03b1 : \\u211d} (h\\u03b1_irrat : irrational \\u03b1) : closure ((\\u03bb m : \\u2124, int.fract (\\u03b1 * \\u2191m)) '' (@set.univ \\u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\\u03b1 : \\u211d) (h\\u03b1 : \\u00ac is_rat \\u03b1) : \\u2200 y \\u2208 Icc 0 1, \\u2203 x \\u2208 Icc 0 1, x \\u2260 y \\u2227 x \\u2208 {i \\u2022 \\u03b1 | i \\u2208 \\u2124} :=\\nbegin\\n assume y h,\\n have h1 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 {i \\u2022 \\u03b1} \\u2260 {j \\u2022 \\u03b1}, from by {\\n assume i j h2,\\n assume h3 : {i \\u2022 \\u03b1} = {j \\u2022 \\u03b1},\\n have h4 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = {i \\u2022 \\u03b1}, from by {rw h3},\\n have h5 : j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor = {j \\u2022 \\u03b1}, from by {rw h3},\\n have h6 : \\u03b1 = (i \\u2022 \\u03b1).floor - (j \\u2022 \\u03b1).floor / (i - j), from by {rw [h4,h5], ring},\\n have h7 : \\u03b1 \\u2208 \\u211a, from by {apply quotient.exact h6},\\n exact h\\u03b1 h7,\\n },\\n have h2 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 \\u2260 j \\u2022 \\u03b1, from by {\\n assume i j h3,\\n assume h4 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1,\\n have h5 : i = j, from by {rw [h4,mul_eq_mul_iff_left h\\u03b1]},\\n exact h3 h5,\\n },\\n have h3 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor \\u2260 j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {\\n assume i j h4,\\n assume h5 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor,\\n have h6 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1, from by {rw h5, ring},\\n exact h2 i j h4 h6,\\n },\\n have h4 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 {i \\u2022 \\u03b1} \\u2260 {j \\u2022 \\u03b1}, from by {\\n assume i j h5,\\n assume h6 : {i \\u2022 \\u03b1} = {j \\u2022 \\u03b1},\\n have h7 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = {i \\u2022 \\u03b1}, from by {rw h6},\\n have h8 : j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor = {j \\u2022 \\u03b1}, from by {rw h6},\\n have h9 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {rw [h7,h8]},\\n exact h3 i j h5 h9,\\n },\\n have h5 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 \\u2260 j \\u2022 \\u03b1, from by {\\n assume i j h6,\\n assume h7 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1,\\n have h8 : i = j, from by {rw [h7,mul_eq_mul_iff_left h\\u03b1]},\\n exact h6 h8,\\n },\\n have h6 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor \\u2260 j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {\\n assume i j h7,\\n assume h8 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor,\\n have h9 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1, from by {rw h8, ring},\\n exact h5 i j h7 h9,\\n },\\n have h7 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 {i \\u2022 \\u03b1} \\u2260 {j \\u2022 \\u03b1}, from by {\\n assume i j h8,\\n assume h9 : {i \\u2022 \\u03b1} = {j \\u2022 \\u03b1},\\n have h10 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = {i \\u2022 \\u03b1}, from by {rw h9},\\n have h11 : j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor = {j \\u2022 \\u03b1}, from by {rw h9},\\n have h12 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {rw [h10,h11]},\\n exact h6 i j h8 h12,\\n },\\n have h8 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 \\u2260 j \\u2022 \\u03b1, from by {\\n assume i j h9,\\n assume h10 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1,\\n have h11 : i = j, from by {rw [h10,mul_eq_mul_iff_left h\\u03b1]},\\n exact h9 h11,\\n },\\n have h9 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor \\u2260 j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {\\n assume i j h10,\\n assume h11 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor,\\n have h12 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1, from by {rw h11, ring},\\n exact h8 i j h10 h12,\\n },\\n have h10 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 {i \\u2022 \\u03b1} \\u2260 {j \\u2022 \\u03b1}, from by {\\n assume i j h11,\\n assume h12 : {i \\u2022 \\u03b1} = {j \\u2022 \\u03b1},\\n have h13 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = {i \\u2022 \\u03b1}, from by {rw h12},\\n have h14 : j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor = {j \\u2022 \\u03b1}, from by {rw h12},\\n have h15 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {rw [h13,h14]},\\n exact h9 i j h11 h15,\\n },\\n have h11 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 \\u2260 j \\u2022 \\u03b1, from by {\\n assume i j h12,\\n assume h13 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1,\\n have h14 : i = j, from by {rw [h13,mul_eq_mul_iff_left h\\u03b1]},\\n exact h12 h14,\\n },\\n have h12 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor \\u2260 j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {\\n assume i j h13,\\n assume h14 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor,\\n have h15 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1, from by {rw h14, ring},\\n exact h11 i j h13 h15,\\n },\\n have h13 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 {i \\u2022 \\u03b1} \\u2260 {j \\u2022 \\u03b1}, from by {\\n assume i j h14,\\n assume h15 : {i \\u2022 \\u03b1} = {j \\u2022 \\u03b1},\\n have h16 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = {i \\u2022 \\u03b1}, from by {rw h15},\\n have h17 : j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor = {j \\u2022 \\u03b1}, from by {rw h15},\\n have h18 : i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor = j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {rw [h16,h17]},\\n exact h12 i j h14 h18,\\n },\\n have h14 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 \\u2260 j \\u2022 \\u03b1, from by {\\n assume i j h15,\\n assume h16 : i \\u2022 \\u03b1 = j \\u2022 \\u03b1,\\n have h17 : i = j, from by {rw [h16,mul_eq_mul_iff_left h\\u03b1]},\\n exact h15 h17,\\n },\\n have h15 : \\u2200 i j : \\u2124, i \\u2260 j \\u2192 i \\u2022 \\u03b1 - (i \\u2022 \\u03b1).floor \\u2260 j \\u2022 \\u03b1 - (j \\u2022 \\u03b1).floor, from by {\\n assume i j h16,\\n assume h17 : i \\u2022 \\u03b1 - (i \\u2022\\nend --Needs more than 2000 tokens!\\n\\n/- FEW SHOT PROMPTS TO CODEX(START)\\n/--`theorem`\\nPower Set is Closed under Intersection\\nLet $S$ be a set.\\n\\nLet $\\\\powerset S$ be the power set of $S$.\\n\\n\\nThen:\\n:$\\\\forall A, B \\\\in \\\\powerset S: A \\\\cap B \\\\in \\\\powerset S$\\n`proof`\\nLet $A, B \\\\in \\\\powerset S$.\\n\\nThen by the definition of power set, $A \\\\subseteq S$ and $B \\\\subseteq S$.\\n\\nFrom Intersection is Subset we have that $A \\\\cap B \\\\subseteq A$.\\n\\nIt follows from Subset Relation is Transitive that $A \\\\cap B \\\\subseteq S$.\\n\\nThus $A \\\\cap B \\\\in \\\\powerset S$ and closure is proved.\\n{{qed}}\\n-/\\ntheorem power_set_intersection_closed {\\u03b1 : Type*} (S : set \\u03b1) : \\u2200 A B \\u2208 \\ud835\\udcab S, (A \\u2229 B) \\u2208 \\ud835\\udcab S :=\\nbegin\\n -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\\n assume (A : set \\u03b1) (hA : A \\u2208 \\ud835\\udcab S) (B : set \\u03b1) (hB : B \\u2208 \\ud835\\udcab S),\\n -- Then $A \\u2286 S$ and $B \\u2286 S$, by power set definition\\n have h1 : (A \\u2286 S) \\u2227 (B \\u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\\n -- Then $(A \\u2229 B) \\u2286 A$, by intersection of set is a subset\\n have h2 : (A \\u2229 B) \\u2286 A, from by apply set.inter_subset_left,\\n -- Then $(A \\u2229 B) \\u2286 S$, by subset relation is transitive \\n have h3 : (A \\u2229 B) \\u2286 S, from by {apply set.subset.trans h2 h1.left},\\n -- Hence $(A \\u2229 B) \\u2208 \\ud835\\udcab S$, by power set definition\\n show (A \\u2229 B) \\u2208 \\ud835\\udcab S, from by {apply set.mem_powerset h3},\\nend\\n\\n/--`theorem`\\nSquare of Sum\\n :$\\\\forall x, y \\\\in \\\\R: \\\\paren {x + y}^2 = x^2 + 2 x y + y^2$\\n`proof`\\nFollows from the distribution of multiplication over addition:\\n\\n{{begin-eqn}}\\n{{eqn | l = \\\\left({x + y}\\\\right)^2\\n | r = \\\\left({x + y}\\\\right) \\\\cdot \\\\left({x + y}\\\\right)\\n}}\\n{{eqn | r = x \\\\cdot \\\\left({x + y}\\\\right) + y \\\\cdot \\\\left({x + y}\\\\right)\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x \\\\cdot x + x \\\\cdot y + y \\\\cdot x + y \\\\cdot y\\n | c = Real Multiplication Distributes over Addition\\n}}\\n{{eqn | r = x^2 + 2xy + y^2\\n | c = \\n}}\\n{{end-eqn}}\\n{{qed}}\\n-/\\ntheorem square_of_sum (x y : \\u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \\nbegin\\n -- expand the power\\n calc (x + y)^2 = (x+y)*(x+y) : by rw sq\\n -- distributive property of multiplication over addition gives:\\n ... = x*(x+y) + y*(x+y) : by rw add_mul\\n -- applying the above property further gives:\\n ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\\n -- rearranging the terms using commutativity and adding gives:\\n ... = x^2 + 2*x*y + y^2 : by {repeat {rw \\u2190 sq}, rw mul_comm y x, ring}\\nend\\n\\n/--`theorem`\\nIdentity of Group is Unique\\nLet $\\\\struct {G, \\\\circ}$ be a group. Then there is a unique identity element $e \\\\in G$.\\n`proof`\\nFrom Group has Latin Square Property, there exists a unique $x \\\\in G$ such that:\\n:$a x = b$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = b$\\n\\nSetting $b = a$, this becomes:\\n\\nThere exists a unique $x \\\\in G$ such that:\\n:$a x = a$\\n\\nand there exists a unique $y \\\\in G$ such that:\\n:$y a = a$\\n\\nThese $x$ and $y$ are both $e$, by definition of identity element.\\n{{qed}}\\n-/\\ntheorem group_identity_unique {G : Type*} [group G] : \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a :=\\nbegin\\n -- Group has Latin Square Property\\n have h1 : \\u2200 a b : G, \\u2203! x : G, a * x = b, from by {\\n assume a b : G, use a\\u207b\\u00b9 * b, obviously, },\\n have h2 : \\u2200 a b : G, \\u2203! y : G, y * a = b, from by {\\n assume a b : G, use b * a\\u207b\\u00b9, obviously, }, \\n\\n -- Setting $b = a$, this becomes:\\n have h3 : \\u2200 a : G, \\u2203! x : G, a * x = a, from \\n assume a : G, h1 a a,\\n have h4 : \\u2200 a : G, \\u2203! y : G, y * a = a, from\\n assume a : G, h2 a a,\\n\\n -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\\n have h5 : \\u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\\n exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\\n (mul_one a),\\n have h6 : \\u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\\n exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \\n\\n show \\u2203! e : G, \\u2200 a : G, e * a = a \\u2227 a * e = a, from by {\\n use (1 : G),\\n have h7 : \\u2200 e : G, (\\u2200 a : G, e * a = a \\u2227 a * e = a) \\u2192 e = 1, from by {\\n assume (e : G) (hident : \\u2200 a : G, e * a = a \\u2227 a * e = a),\\n have h8 : \\u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\\n exists_unique.unique (h3 a) (hident a).right\\n (classical.some_spec (exists_unique.exists (h3 a))), \\n have h9 : \\u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\\n exists_unique.unique (h4 a) (hident a).left\\n (classical.some_spec (exists_unique.exists (h4 a))),\\n show e = (1 : G), from eq.trans (h9 e) (h6 _), \\n },\\n exact \\u27e8by obviously, h7\\u27e9,\\n }\\nend\\n\\n/--`theorem`\\nSqueeze Theorem for Real Numbers\\nLet $\\\\sequence {x_n}$, $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ be sequences in $\\\\R$.\\n\\nLet $\\\\sequence {y_n}$ and $\\\\sequence {z_n}$ both be convergent to the following limit:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l, \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$\\n\\nSuppose that:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\n\\nThen:\\n:$x_n \\\\to l$ as $n \\\\to \\\\infty$\\nthat is:\\n:$\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} x_n = l$\\n\\n`proof`\\nFrom Negative of Absolute Value:\\n:$\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n\\nLet $\\\\epsilon > 0$.\\n\\nWe need to prove that:\\n:$\\\\exists N: \\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that:\\n:$\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n\\nAs $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that:\\n:$\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n\\n\\nLet $N = \\\\max \\\\set {N_1, N_2}$.\\n\\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n:$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n\\nBut:\\n:$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n\\nSo:\\n:$\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n\\nand so:\\n:$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n\\nSo:\\n:$\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n\\nHence the result.\\n{{qed}}\\n\\n-/\\ntheorem squeeze_theorem_real_numbers (x y z : \\u2115 \\u2192 \\u211d) (l : \\u211d) : \\nlet seq_limit : (\\u2115 \\u2192 \\u211d) \\u2192 \\u211d \\u2192 Prop := \\u03bb (u : \\u2115 \\u2192 \\u211d) (l : \\u211d), \\u2200 \\u03b5 > 0, \\u2203 N, \\u2200 n > N, |u n - l| < \\u03b5 in\\n seq_limit y l \\u2192 seq_limit z l \\u2192 (\\u2200 n : \\u2115, (y n) \\u2264 (x n) \\u2227 (x n) \\u2264 (z n)) \\u2192 seq_limit x l :=\\nbegin\\n assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \\u2200 (n : \\u2115), y n \\u2264 x n \\u2227 x n \\u2264 z n) (\\u03b5), \\n\\n --From Negative of Absolute Value: $\\\\size {x - l} < \\\\epsilon \\\\iff l - \\\\epsilon < x < l + \\\\epsilon$\\n have h5 : \\u2200 x, |x - l| < \\u03b5 \\u2194 (((l - \\u03b5) < x) \\u2227 (x < (l + \\u03b5))), \\n from by \\n {\\n intro x0,\\n have h6 : |x0 - l| < \\u03b5 \\u2194 ((x0 - l) < \\u03b5) \\u2227 ((l - x0) < \\u03b5), \\n from abs_sub_lt_iff, rw h6,\\n split, \\n rintro \\u27e8 S_1, S_2 \\u27e9, \\n split; linarith, \\n rintro \\u27e8 S_3, S_4 \\u27e9, \\n split; linarith,\\n },\\n \\n --Let $\\\\epsilon > 0$.\\n assume (h7 : \\u03b5 > 0),\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} y_n = l$ we know that $\\\\exists N_1: \\\\forall n > N_1: \\\\size {y_n - l} < \\\\epsilon$\\n cases h2 \\u03b5 h7 with N1 h8,\\n\\n --As $\\\\ds \\\\lim_{n \\\\mathop \\\\to \\\\infty} z_n = l$ we know that $\\\\exists N_2: \\\\forall n > N_2: \\\\size {z_n - l} < \\\\epsilon$\\n cases h3 \\u03b5 h7 with N2 h9,\\n \\n --Let $N = \\\\max \\\\set {N_1, N_2}$.\\n let N := max N1 N2,\\n use N,\\n\\n --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\\n have h10 : \\u2200 n > N, n > N1 \\u2227 n > N2 := by {\\n assume n h,\\n split,\\n exact lt_of_le_of_lt (le_max_left N1 N2) h, \\n exact lt_of_le_of_lt (le_max_right N1 N2) h,\\n },\\n \\n --$\\\\forall n > N: l - \\\\epsilon < y_n < l + \\\\epsilon$\\n --$\\\\forall n > N: l - \\\\epsilon < z_n < l + \\\\epsilon$\\n --$\\\\forall n \\\\in \\\\N: y_n \\\\le x_n \\\\le z_n$\\n --So $\\\\forall n > N: l - \\\\epsilon < y_n \\\\le x_n \\\\le z_n < l + \\\\epsilon$\\n have h11 : \\u2200 n > N, (((l - \\u03b5) < (y n)) \\u2227 ((y n) \\u2264 (x n))) \\u2227 (((x n) \\u2264 (z n)) \\u2227 ((z n) < l+\\u03b5)), \\n from by {\\n intros n h12,\\n split,\\n {\\n\\n have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\\n split,\\n exact h13.left,\\n exact (h4 n).left,\\n },\\n { \\n have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\\n split,\\n exact (h4 n).right,\\n exact h14.right,\\n },\\n \\n },\\n\\n --$\\\\forall n > N: l - \\\\epsilon < x_n < l + \\\\epsilon$\\n have h15 : \\u2200 n > N, ((l - \\u03b5) < (x n)) \\u2227 ((x n) < (l+\\u03b5)), \\n from by {\\n intros n1 h16, cases (h11 n1 h16);\\n split; linarith,\\n },\\n\\n --So $\\\\forall n > N: \\\\size {x_n - l} < \\\\epsilon$\\n --Hence the result\\n show \\u2200 (n : \\u2115), n > N \\u2192 |x n - l| < \\u03b5, \\n from by {\\n intros n h17,\\n cases h5 (x n) with h18 h19,\\n apply h19, exact h15 n h17,\\n },\\nend\\n\\n/--`theorem`\\nDensity of irrational orbit\\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\\n`proof`\\nLet $\\\\alpha$ be an irrational number. Then for distinct $i, j \\\\in \\\\mathbb{Z}$, we must have $\\\\{i \\\\alpha\\\\} \\\\neq\\\\{j \\\\alpha\\\\}$. If this were not true, then\\n$$\\ni \\\\alpha-\\\\lfloor i \\\\alpha\\\\rfloor=\\\\{i \\\\alpha\\\\}=\\\\{j \\\\alpha\\\\}=j \\\\alpha-\\\\lfloor j \\\\alpha\\\\rfloor,\\n$$\\nwhich yields the false statement $\\\\alpha=\\\\frac{\\\\lfloor i \\\\alpha\\\\rfloor-\\\\lfloor j \\\\alpha\\\\rfloor}{i-j} \\\\in \\\\mathbb{Q}$. Hence,\\n$$\\nS:=\\\\{\\\\{i \\\\alpha\\\\} \\\\mid i \\\\in \\\\mathbb{Z}\\\\}\\n$$\\nis an infinite subset of $\\\\left[0,1\\\\right]$.\\n\\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\\n\\nTo show that $S$ is dense in $[0, 1]$, consider $y \\\\in[0,1]$, and $\\\\epsilon>0$. Then by selecting $x \\\\in S$ such that $\\\\{x\\\\}<\\\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\\\cdot\\\\{x\\\\} \\\\leq y<(N+1) \\\\cdot\\\\{x\\\\}$, we get: $|y-\\\\{N x\\\\}|<\\\\epsilon$.\\n\\nQED\\n-/\\ntheorem \\nFEW SHOT PROMPTS TO CODEX(END)-/\\n\"} {\"text\": \"/-\\nCopyright (c) 2020 Ruben Van de Velde. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\n-/\\nimport Mathlib.Data.Int.Order.Units\\nimport Mathlib.NumberTheory.Zsqrtd.Basic\\nimport Mathlib.RingTheory.Prime\\nimport Flt.Primes\\n\\ntheorem Zsqrtd.exists {d : \\u2124} (a : \\u2124\\u221ad) (him : a.im \\u2260 0) :\\n \\u2203 c : \\u2124\\u221ad, a.norm = c.norm \\u2227 0 \\u2264 c.re \\u2227 c.im \\u2260 0 :=\\n by\\n cases' le_or_lt a.re 0 with hre hre\\n \\u00b7 use -a\\n simp only [hre, him, Zsqrtd.norm_neg, eq_self_iff_true, Zsqrtd.neg_im, Zsqrtd.neg_re,\\n and_self_iff, neg_nonneg, Ne.def, not_false_iff, neg_eq_zero]\\n \\u00b7 use a\\n simp only [hre.le, him, eq_self_iff_true, and_self_iff, Ne.def, not_false_iff]\\n#align zsqrtd.exists Zsqrtd.exists\\n\\n-- Edwards p49 step (2')\\ntheorem factors2 {a : \\u2124\\u221a(-3)} (heven : Even a.norm) : \\u2203 b : \\u2124\\u221a(-3), a.norm = 4 * b.norm :=\\n by\\n have hparity : Even a.re \\u2194 Even a.im := by\\n simpa [two_ne_zero, Zsqrtd.norm_def, parity_simps] using heven\\n simp only [iff_iff_and_or_not_and_not, \\u2190 Int.odd_iff_not_even] at hparity\\n obtain \\u27e8\\u27e8c, hc\\u27e9, \\u27e8d, hd\\u27e9\\u27e9 | \\u27e8hre, him\\u27e9 := hparity\\n \\u00b7 use \\u27e8c, d\\u27e9\\n simp only [Zsqrtd.norm_def, hc, hd]\\n ring\\n \\u00b7 cases' Int.four_dvd_add_or_sub_of_odd hre him with h4 h4\\n \\u00b7 obtain \\u27e8v, hv\\u27e9 := h4\\n use \\u27e8v - a.im, v\\u27e9\\n rw [eq_comm, \\u2190 sub_eq_iff_eq_add] at hv\\n simp only [Zsqrtd.norm_def, \\u2190 hv]\\n ring\\n \\u00b7 obtain \\u27e8v, hv\\u27e9 := h4\\n use \\u27e8v + a.im, v\\u27e9\\n rw [sub_eq_iff_eq_add] at hv\\n simp only [Zsqrtd.norm_def, hv]\\n ring\\n#align factors2 factors2\\n\\ntheorem Spts.mul_of_dvd' {a p : \\u2124\\u221a(-3)} (hdvd : p.norm \\u2223 a.norm) (hpprime : Prime p.norm) :\\n \\u2203 u : \\u2124\\u221a(-3), a = p * u \\u2228 a = star p * u :=\\n by\\n obtain \\u27e8f, hf\\u27e9 := hdvd\\n have h0 : p.norm \\u2223 p.re * a.im - a.re * p.im \\u2228 p.norm \\u2223 p.re * a.im + a.re * p.im :=\\n by\\n apply hpprime.dvd_or_dvd\\n convert dvd_mul_right p.norm (a.im ^ 2 - p.im ^ 2 * f) using 1\\n trans a.im ^ 2 * p.norm - p.im ^ 2 * (p.norm * f)\\n \\u00b7 rw [\\u2190 hf, Zsqrtd.norm_def, Zsqrtd.norm_def]\\n ring\\n \\u00b7 rw [Zsqrtd.norm_def]\\n ring\\n obtain \\u27e8A, HA\\u27e9 : \\u2203 A : Units \\u2124, p.norm \\u2223 p.re * a.im + A * a.re * p.im := by\\n cases' h0 with h0 h0 <;> [(use -1), (use 1)] <;> convert h0 using 1 <;>\\n simp only [Units.val_neg, Units.val_one, neg_mul, one_mul]\\n ring\\n have HAsq : (A : \\u2124) ^ 2 = 1 := by\\n calc\\n (A : \\u2124) ^ 2 = ((A ^ 2 : Units \\u2124) : \\u2124) := (Units.val_pow_eq_pow_val _ _).symm\\n _ = ((1 : Units \\u2124) : \\u2124) := (congr_arg _ (Int.units_sq A))\\n _ = 1 := Units.val_one\\n \\n \\u00b7 set X : \\u2124\\u221a(-3) := \\u27e8p.re * a.re - A * 3 * p.im * a.im, p.re * a.im + A * a.re * p.im\\u27e9 with HX\\n obtain \\u27e8U, HU\\u27e9 : (p.norm : \\u2124\\u221a(-3)) \\u2223 X :=\\n by\\n rw [Zsqrtd.coe_int_dvd_iff]\\n refine' \\u27e8_, HA\\u27e9\\n apply @Prime.dvd_of_dvd_pow _ _ _ hpprime _ 2\\n have : X.re ^ 2 = X.norm - 3 * X.im ^ 2 :=\\n by\\n rw [Zsqrtd.norm_def]\\n ring\\n rw [this]\\n apply dvd_sub\\n \\u00b7 use a.norm\\n trans\\n (p.re * a.re) ^ 2 + (A : \\u2124) ^ 2 * (3 * p.im * a.im) ^ 2 +\\n 3 * ((p.re * a.im) ^ 2 + (A : \\u2124) ^ 2 * (a.re * p.im) ^ 2)\\n \\u00b7 simp only [Zsqrtd.norm_def]\\n ring\\n \\u00b7 simp only [Zsqrtd.norm_def, HAsq]\\n ring\\n \\u00b7 apply dvd_mul_of_dvd_right\\n exact dvd_pow HA two_ne_zero\\n use U\\n suffices a = \\u27e8p.re, -A * p.im\\u27e9 * U by\\n apply Or.imp _ _ (Int.units_eq_one_or A).symm <;> rintro rfl <;> simpa [Zsqrtd.ext] using this\\n apply Zsqrtd.eq_of_smul_eq_smul_left hpprime.ne_zero\\n have : p.norm = p.re ^ 2 + 3 * (A : \\u2124) ^ 2 * p.im ^ 2 :=\\n by\\n rw [Zsqrtd.norm_def, HAsq]\\n ring\\n rw [mul_comm _ U, \\u2190 mul_assoc, \\u2190 HU, HX]\\n simp only [Zsqrtd.ext, neg_mul, add_zero, Zsqrtd.coe_int_re, MulZeroClass.zero_mul, mul_neg,\\n Zsqrtd.mul_im, Zsqrtd.mul_re, neg_neg, MulZeroClass.mul_zero, neg_zero, Zsqrtd.coe_int_im,\\n this]\\n constructor <;> ring\\n#align spts.mul_of_dvd' Spts.mul_of_dvd'\\n\\n-- Edwards p49 step (3')\\ntheorem Spts.mul_of_dvd'' {a p : \\u2124\\u221a(-3)} (hdvd : p.norm \\u2223 a.norm) (hpprime : Prime p.norm) :\\n \\u2203 u : \\u2124\\u221a(-3), (a = p * u \\u2228 a = star p * u) \\u2227 a.norm = p.norm * u.norm :=\\n by\\n obtain \\u27e8u, hu\\u27e9 := Spts.mul_of_dvd' hdvd hpprime\\n refine' \\u27e8u, hu, _\\u27e9\\n obtain rfl | rfl := hu\\n \\u00b7 rw [Zsqrtd.norm_mul]\\n \\u00b7 rw [Zsqrtd.norm_mul, Zsqrtd.norm_conj]\\n#align spts.mul_of_dvd'' Spts.mul_of_dvd''\\n\\n-- Edwards p49 step (4'), contraposed\\ntheorem factors' (a : \\u2124\\u221a(-3)) (f : \\u2124) (g : \\u2124) (hodd : Odd f) (hgpos : g \\u2260 0)\\n (hfactor : f * g = a.norm)\\n (hnotform : \\u2200 f' : \\u2124, f' \\u2223 g \\u2192 Odd f' \\u2192 \\u2203 p : \\u2124\\u221a(-3), abs f' = p.norm) :\\n \\u2203 p : \\u2124\\u221a(-3), abs f = p.norm :=\\n by\\n induction' hg : g.natAbs using Nat.strong_induction_on with g'' IH generalizing a g\\n subst g''\\n dsimp at IH\\n by_cases H : Even (Zsqrtd.norm a)\\n \\u00b7 obtain \\u27e8c, hc\\u27e9 := factors2 H\\n have : 4 \\u2223 g := by\\n apply IsCoprime.dvd_of_dvd_mul_left\\n \\u00b7 show IsCoprime _ f\\n rw [Int.odd_iff_not_even, even_iff_two_dvd, \\u2190 Int.prime_two.coprime_iff_not_dvd] at hodd\\n convert hodd.pow_left\\n rw [sq]\\n norm_num\\n \\u00b7 rw [hfactor, hc]\\n exact dvd_mul_right _ _\\n obtain \\u27e8g', rfl\\u27e9 := this\\n have hg'pos : g' \\u2260 0 := right_ne_zero_of_mul hgpos\\n refine' IH g'.natAbs _ c g' hg'pos _ _ rfl\\n \\u00b7 rw [Int.natAbs_mul]\\n apply lt_mul_of_one_lt_left (Int.natAbs_pos.mpr hg'pos)\\n norm_num\\n \\u00b7 rw [\\u2190 mul_right_inj' (four_ne_zero' \\u2124), \\u2190 hc, \\u2190 hfactor, mul_left_comm]\\n \\u00b7 intro f' hf'dvd hf'odd\\n refine' hnotform f' _ hf'odd\\n exact hf'dvd.mul_left _\\n \\u00b7 by_cases h : |g| = 1\\n \\u00b7 apply_fun abs at hfactor\\n rw [abs_mul, h, mul_one, abs_of_nonneg (Zsqrtd.norm_nonneg (by norm_num) a)] at hfactor\\n exact \\u27e8_, hfactor\\u27e9\\n \\u00b7 rw [Int.abs_eq_natAbs, \\u2190 Int.ofNat_one, Int.coe_nat_inj'] at h\\n obtain \\u27e8p, pprime, pdvd\\u27e9 := Int.exists_prime_and_dvd h\\n have : p \\u2223 a.norm := by\\n rw [\\u2190 hfactor]\\n exact pdvd.mul_left _\\n have podd : Odd p :=\\n Int.odd_iff_not_even.mpr\\n (by\\n intro X\\n apply H\\n apply even_iff_two_dvd.mpr\\n apply dvd_trans _ this\\n apply even_iff_two_dvd.mp X)\\n obtain \\u27e8A, HA\\u27e9 := hnotform p pdvd podd\\n have pprime' := pprime.abs\\n rw [HA] at pprime'\\n have pdvd' : A.norm \\u2223 a.norm := by\\n rw [\\u2190 hfactor, \\u2190 HA, abs_dvd]\\n exact dvd_mul_of_dvd_right pdvd _\\n obtain \\u27e8c, -, hcd\\u27e9 := Spts.mul_of_dvd'' pdvd' pprime'\\n obtain \\u27e8q, rfl\\u27e9 := pdvd\\n have hqpos : q \\u2260 0 := right_ne_zero_of_mul hgpos\\n have : (p.sign * q).natAbs = q.natAbs := by\\n rw [Int.natAbs_mul, Int.natAbs_sign_of_nonzero pprime.ne_zero, one_mul]\\n refine' IH q.natAbs _ c (p.sign * q) _ _ _ this\\n \\u00b7 rw [Int.natAbs_mul]\\n apply lt_mul_of_one_lt_left (Int.natAbs_pos.mpr hqpos)\\n rw [Int.prime_iff_natAbs_prime] at pprime\\n exact pprime.one_lt\\n \\u00b7 rwa [\\u2190 Int.natAbs_eq_zero, this, Int.natAbs_eq_zero]\\n \\u00b7\\n rw [\\u2190 mul_right_inj' pprime'.ne_zero, \\u2190 hcd, mul_left_comm, \\u2190 hfactor, \\u2190 HA, \\u2190\\n mul_assoc (|p|), mul_comm (|p|), Int.sign_mul_abs]\\n \\u00b7 intro f' hf'dvd hf'odd\\n refine' hnotform f' _ hf'odd\\n rw [\\u2190 Int.dvd_natAbs, this, Int.dvd_natAbs] at hf'dvd\\n exact hf'dvd.mul_left _\\n#align factors' factors'\\n\\ntheorem Zqrtd.factor_div (a : \\u2124\\u221a(-3)) {x : \\u2124} (hodd : Odd x) :\\n \\u2203 c m : \\u2124\\u221a(-3), a = c + m * x \\u2227 c.norm < x ^ 2 :=\\n by\\n obtain \\u27e8m, c, ha, hc\\u27e9 := Int.factor_div a.re x hodd\\n obtain \\u27e8n, d, hb, hd\\u27e9 := Int.factor_div a.im x hodd\\n set c' : \\u2124\\u221a(-3) := \\u27e8c, d\\u27e9\\n refine' \\u27e8c', \\u27e8m, n\\u27e9, _, _\\u27e9\\n \\u00b7\\n simp only [Zsqrtd.ext, ha, hb, add_zero, Zsqrtd.coe_int_re, eq_self_iff_true, Zsqrtd.mul_im,\\n zero_add, Zsqrtd.add_im, and_self_iff, Zsqrtd.mul_re, MulZeroClass.mul_zero, Zsqrtd.add_re,\\n Zsqrtd.coe_int_im]\\n \\u00b7 rw [\\u2190 mul_lt_mul_left (by norm_num : (0 : \\u2124) < 4)]\\n calc\\n 4 * c'.norm = (2 * c) ^ 2 + 3 * (2 * d) ^ 2 :=\\n by\\n rw [Zsqrtd.norm_def]\\n ring\\n _ < x ^ 2 + 3 * x ^ 2 := (add_lt_add ?_ ?_)\\n _ = 4 * x ^ 2 := by ring\\n \\n \\u00b7 rw [mul_pow, \\u2190 Int.natAbs_pow_two c, \\u2190 Int.natAbs_pow_two x, \\u2190 mul_pow]\\n norm_cast\\n exact Nat.pow_lt_pow_of_lt_left hc zero_lt_two\\n \\u00b7 rw [mul_pow, \\u2190 Int.natAbs_pow_two d, \\u2190 Int.natAbs_pow_two x, \\u2190 mul_pow,\\n mul_lt_mul_left (by norm_num : (0 : \\u2124) < 3)]\\n norm_cast\\n exact Nat.pow_lt_pow_of_lt_left hd zero_lt_two\\n#align zqrtd.factor_div Zqrtd.factor_div\\n\\ntheorem Zqrtd.factor_div' (a : \\u2124\\u221a(-3)) {x : \\u2124} (hodd : Odd x) (h : 1 < |x|)\\n (hcoprime : IsCoprime a.re a.im) (hfactor : x \\u2223 a.norm) :\\n \\u2203 c m : \\u2124\\u221a(-3),\\n a = c + m * x \\u2227 c.norm < x ^ 2 \\u2227 c \\u2260 0 \\u2227 \\u2203 y, c.norm = x * y \\u2227 y.natAbs < x.natAbs :=\\n by\\n obtain \\u27e8c, m, rfl, h2\\u27e9 := Zqrtd.factor_div a hodd\\n refine' \\u27e8c, m, rfl, h2, _, _\\u27e9\\n \\u00b7 rintro rfl\\n apply h.ne'\\n rw [\\u2190 Int.isUnit_iff_abs_eq]\\n apply hcoprime.isUnit_of_dvd' <;>\\n simp only [zero_add, mul_comm m, Zsqrtd.smul_re, Zsqrtd.smul_im, dvd_mul_right]\\n \\u00b7 obtain \\u27e8y, hy\\u27e9 : x \\u2223 c.norm :=\\n by\\n set e : \\u2124 := m.re ^ 2 * x + 2 * m.re * c.re + 3 * m.im ^ 2 * x + 6 * m.im * c.im with he\\n convert dvd_sub hfactor (dvd_mul_right x e)\\n rw [he, Zsqrtd.norm_def, Zsqrtd.norm_def]\\n simp only [Zsqrtd.coe_int_re, Zsqrtd.mul_im, Zsqrtd.add_im, Zsqrtd.mul_re, Zsqrtd.add_re,\\n Zsqrtd.coe_int_im]\\n ring\\n refine' \\u27e8y, hy, _\\u27e9\\n have h0'' : 0 < x.natAbs := by\\n zify\\n exact zero_lt_one.trans h\\n rw [\\u2190 mul_lt_mul_left h0'', \\u2190 pow_two, \\u2190 Int.natAbs_mul, \\u2190 hy]\\n zify\\n rwa [\\u2190 Int.coe_natAbs x, Int.natAbs_pow_two x, \\u2190 Int.coe_natAbs,\\n Int.natAbs_of_nonneg (Zsqrtd.norm_nonneg (by norm_num) c)]\\n#align zqrtd.factor_div' Zqrtd.factor_div'\\n\\n-- Edwards p50 step (5')\\ntheorem factors (a : \\u2124\\u221a(-3)) (x : \\u2124) (hcoprime : IsCoprime a.re a.im) (hodd : Odd x)\\n (hfactor : x \\u2223 a.norm) : \\u2203 c : \\u2124\\u221a(-3), abs x = c.norm :=\\n by\\n induction' hx' : x.natAbs using Nat.strong_induction_on with x' IH generalizing a x\\n subst hx'\\n have hneg1 : 1 \\u2264 a.norm := by\\n rw [\\u2190 Int.sub_one_lt_iff, sub_self]\\n apply lt_of_le_of_ne (Zsqrtd.norm_nonneg (by norm_num) a)\\n rw [Ne.def, eq_comm, Zsqrtd.norm_eq_zero_iff (by norm_num : (-3 : \\u2124) < 0)]\\n rintro rfl\\n rw [Zsqrtd.zero_im, Zsqrtd.zero_re] at hcoprime\\n exact not_isCoprime_zero_zero hcoprime\\n have h0 : x \\u2260 0 := by\\n rintro rfl\\n simp only [even_zero, not_true, Int.odd_iff_not_even] at hodd\\n have h0' : 1 \\u2264 abs x := by rwa [\\u2190 Int.sub_one_lt_iff, sub_self, abs_pos]\\n cases' h0'.eq_or_lt with h h\\n \\u00b7 rw [\\u2190 h]\\n refine' \\u27e8\\u27e81, 0\\u27e9, _\\u27e9\\n norm_num [Zsqrtd.norm_def]\\n obtain \\u27e8c', m, rfl, -, h1, \\u27e8y, hy, h3\\u27e9\\u27e9 := Zqrtd.factor_div' a hodd h hcoprime hfactor\\n have h4 : c'.norm \\u2260 0 := by rwa [Ne.def, Zsqrtd.norm_eq_zero_iff (by norm_num) c']\\n set g := Int.gcd c'.re c'.im with hg\\n have hgpos : 0 < g := by rwa [hg, Zsqrtd.gcd_pos_iff]\\n obtain \\u27e8C', HC', HCDcoprime\\u27e9 := Zsqrtd.exists_coprime_of_gcd_pos hgpos\\n have h5 : x * y = (g : \\u2124) ^ 2 * C'.norm := by\\n rw [\\u2190 hy, HC', Zsqrtd.norm_mul, Zsqrtd.norm_int_cast, \\u2190 pow_two]\\n obtain \\u27e8z, hz\\u27e9 : (g : \\u2124) ^ 2 \\u2223 y :=\\n by\\n have : (g : \\u2124) ^ 2 \\u2223 x * y := by\\n rw [h5]\\n exact dvd_mul_right _ _\\n apply IsCoprime.dvd_of_dvd_mul_left _ this\\n apply isCoprime_of_prime_dvd\\n \\u00b7 contrapose! h0\\n exact h0.2\\n intro p hpprime hpdvdleft hpdvdright\\n have : \\u2191p \\u2223 c' + m * x := by\\n rw [HC']\\n exact\\n dvd_add\\n (dvd_mul_of_dvd_left\\n ((Zsqrtd.coe_int_dvd_coe_int _ _).mpr (hpprime.dvd_of_dvd_pow hpdvdleft)) _)\\n (dvd_mul_of_dvd_right ((Zsqrtd.coe_int_dvd_coe_int _ _).mpr hpdvdright) _)\\n have := Zsqrtd.coprime_of_dvd_coprime hcoprime this\\n simp only [Zsqrtd.coe_int_re, isCoprime_zero_right, Zsqrtd.coe_int_im, hpprime.not_unit] at this\\n have h6 : x * z = C'.norm :=\\n by\\n have hgnezero := Int.coe_nat_ne_zero_iff_pos.mpr hgpos\\n apply Int.eq_of_mul_eq_mul_left (pow_ne_zero 2 hgnezero)\\n rw [\\u2190 h5, hz, mul_left_comm]\\n have h8 : z \\u2260 0 := by\\n apply right_ne_zero_of_mul\\n apply right_ne_zero_of_mul\\n rwa [h6, \\u2190 h5, \\u2190 hy]\\n refine' factors' _ x z hodd h8 h6 _\\n intro w hwdvd hwodd\\n refine' IH w.natAbs _ C' w HCDcoprime hwodd _ rfl\\n \\u00b7\\n calc\\n w.natAbs \\u2264 z.natAbs :=\\n Nat.le_of_dvd (Int.natAbs_pos.mpr h8) (Int.natAbs_dvd_natAbs.mpr hwdvd)\\n _ \\u2264 y.natAbs := by\\n rw [hz, Int.natAbs_mul]\\n exact Nat.le_mul_of_pos_left (pow_pos hgpos 2)\\n _ < x.natAbs := h3\\n \\n \\u00b7 rw [\\u2190 h6]\\n exact dvd_mul_of_dvd_right hwdvd x\\n#align factors factors\\n\\ntheorem Spts.eq_one {a : \\u2124\\u221a(-3)} (h : a.norm = 1) : abs a.re = 1 \\u2227 a.im = 0 :=\\n by\\n suffices H : abs a.re = 1\\n \\u00b7 refine' \\u27e8H, _\\u27e9\\n rw [Zsqrtd.norm_def, mul_assoc, \\u2190 Int.natAbs_mul_self' a.re, \\u2190 Int.abs_eq_natAbs, H, one_mul,\\n neg_mul, sub_neg_eq_add, add_right_eq_self, mul_eq_zero, mul_self_eq_zero] at h\\n exact h.resolve_left three_ne_zero\\n contrapose! h\\n cases' lt_or_gt_of_ne h with H H\\n \\u00b7 have : a.re = 0 := by rwa [\\u2190 Int.abs_lt_one_iff]\\n simp only [Zsqrtd.norm_def, this, MulZeroClass.zero_mul, zero_sub, neg_mul, neg_neg]\\n by_cases hb : a.im = 0\\n \\u00b7 simp only [hb, not_false_iff, zero_ne_one, MulZeroClass.mul_zero]\\n \\u00b7 have : 1 \\u2264 abs a.im := by rwa [\\u2190 Int.abs_lt_one_iff, not_lt] at hb\\n have : 1 \\u2264 a.im ^ 2 := by\\n rw [\\u2190 sq_abs]\\n exact pow_le_pow_of_le_left zero_le_one this 2\\n linarith\\n \\u00b7 apply ne_of_gt\\n rw [Zsqrtd.norm_def, neg_mul, neg_mul, sub_neg_eq_add]\\n apply lt_add_of_lt_of_nonneg\\n \\u00b7 rw [\\u2190 sq, \\u2190 sq_abs]\\n exact pow_lt_pow_of_lt_left H zero_le_one zero_lt_two\\n \\u00b7 rw [mul_assoc]\\n exact mul_nonneg zero_lt_three.le (mul_self_nonneg _)\\n#align spts.eq_one Spts.eq_one\\n\\ntheorem Spts.eq_one' {a : \\u2124\\u221a(-3)} (h : a.norm = 1) : a = 1 \\u2228 a = -1 := by\\n simp only [Zsqrtd.ext, Zsqrtd.one_re, Zsqrtd.one_im, Zsqrtd.neg_im, Zsqrtd.neg_re, neg_zero, \\u2190\\n or_and_right, \\u2190 abs_eq (zero_le_one' \\u2124), Spts.eq_one h, eq_self_iff_true, and_self_iff]\\n#align spts.eq_one' Spts.eq_one'\\n\\ntheorem Spts.ne_zero_of_coprime' (a : \\u2124\\u221a(-3)) (hcoprime : IsCoprime a.re a.im) : a.norm \\u2260 0 :=\\n by\\n contrapose! hcoprime with H\\n obtain \\u27e8rfl, rfl\\u27e9 := (Zsqrtd.norm_eq_zero_iff (by norm_num) _).mp H\\n exact not_isCoprime_zero_zero\\n#align spts.ne_zero_of_coprime' Spts.ne_zero_of_coprime'\\n\\ntheorem Spts.pos_of_coprime' {a : \\u2124\\u221a(-3)} (hcoprime : IsCoprime a.re a.im) : 0 < a.norm :=\\n by\\n apply lt_of_le_of_ne\\n \\u00b7 apply Zsqrtd.norm_nonneg\\n norm_num\\n \\u00b7 apply Ne.symm -- Porting note: `symm` fails\\n exact Spts.ne_zero_of_coprime' _ hcoprime\\n#align spts.pos_of_coprime' Spts.pos_of_coprime'\\n\\ntheorem Spts.one_lt_of_im_ne_zero (a : \\u2124\\u221a(-3)) (hb : a.im \\u2260 0) : 1 < a.norm :=\\n by\\n apply lt_of_le_of_ne\\n \\u00b7 rw [\\u2190 Int.sub_one_lt_iff, sub_self]\\n apply lt_of_le_of_ne (Zsqrtd.norm_nonneg (by norm_num) a)\\n contrapose! hb\\n rw [eq_comm, Zsqrtd.norm_eq_zero_iff (by norm_num) a] at hb\\n rw [hb, Zsqrtd.zero_im]\\n \\u00b7 intro H\\n exact hb (Spts.eq_one H.symm).2\\n#align spts.one_lt_of_im_ne_zero Spts.one_lt_of_im_ne_zero\\n\\ntheorem Spts.not_two (a : \\u2124\\u221a(-3)) : a.norm \\u2260 2 :=\\n by\\n rw [Zsqrtd.norm_def]\\n obtain him | him := eq_or_ne a.im 0\\n \\u00b7 rw [him, MulZeroClass.mul_zero, sub_zero, \\u2190 Int.natAbs_mul_self, \\u2190 sq]\\n norm_cast\\n apply (Nat.pow_left_strictMono one_le_two).monotone.ne_of_lt_of_lt_nat 1 <;> norm_num\\n \\u00b7 apply ne_of_gt\\n apply lt_add_of_nonneg_of_lt (mul_self_nonneg a.re)\\n rw [\\u2190 Int.add_one_le_iff]\\n rw [mul_assoc, neg_mul_eq_neg_mul, neg_neg]\\n refine' le_mul_of_one_le_right zero_lt_three.le _\\n rwa [\\u2190 Int.sub_one_lt_iff, sub_self, mul_self_pos]\\n#align spts.not_two Spts.not_two\\n\\ntheorem Spts.four {p : \\u2124\\u221a(-3)} (hfour : p.norm = 4) (hq : p.im \\u2260 0) : abs p.re = 1 \\u2227 abs p.im = 1 :=\\n by\\n suffices p.re ^ 2 = 1 \\u2227 p.im ^ 2 = 1 by\\n apply And.imp _ _ this <;>\\n \\u00b7 intro h\\n rwa [\\u2190 sq_eq_sq (abs_nonneg (_ : \\u2124)) zero_le_one, one_pow, sq_abs]\\n have hq : p.im ^ 2 = 1 := by\\n apply le_antisymm\\n \\u00b7 contrapose! hfour with hq'\\n apply ne_of_gt\\n rw [\\u2190 Int.add_one_le_iff] at hq'\\n calc\\n 4 < 3 * 2 := by norm_num\\n _ \\u2264 3 * p.im ^ 2 := (Int.mul_le_mul_of_nonneg_left hq' (by norm_num))\\n _ \\u2264 p.re ^ 2 + 3 * p.im ^ 2 := (le_add_of_nonneg_left (pow_two_nonneg p.re))\\n _ = p.norm := by\\n rw [Zsqrtd.norm_def]\\n ring\\n \\n \\u00b7 rw [\\u2190 Int.sub_one_lt_iff, sub_self]\\n exact sq_pos_of_ne_zero _ hq\\n refine' \\u27e8_, hq\\u27e9\\n calc\\n p.re ^ 2 = p.re ^ 2 + 3 * p.im ^ 2 - 3 := by rw [hq, mul_one, add_sub_cancel]\\n _ = p.norm - 3 := by\\n rw [Zsqrtd.norm_def]\\n ring\\n _ = 1 := by\\n rw [hfour]\\n norm_num\\n \\n#align spts.four Spts.four\\n\\ntheorem Spts.four_of_coprime {p : \\u2124\\u221a(-3)} (hcoprime : IsCoprime p.re p.im) (hfour : p.norm = 4) :\\n abs p.re = 1 \\u2227 abs p.im = 1 := by\\n apply Spts.four hfour\\n rintro him\\n rw [him, isCoprime_zero_right, Int.isUnit_iff_abs_eq] at hcoprime\\n rw [Zsqrtd.norm_def, him, MulZeroClass.mul_zero, sub_zero, \\u2190 sq, \\u2190 sq_abs, hcoprime] at hfour\\n norm_num at hfour\\n#align spts.four_of_coprime Spts.four_of_coprime\\n\"} {\"text\": \"[GOAL]\\n\\u22a2 StrictConvexOn \\u211d univ exp\\n[PROOFSTEP]\\napply strictConvexOn_of_slope_strict_mono_adjacent convex_univ\\n[GOAL]\\n\\u22a2 \\u2200 {x y z : \\u211d}, x \\u2208 univ \\u2192 z \\u2208 univ \\u2192 x < y \\u2192 y < z \\u2192 (exp y - exp x) / (y - x) < (exp z - exp y) / (z - y)\\n[PROOFSTEP]\\nrintro x y z - - hxy hyz\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 (exp y - exp x) / (y - x) < (exp z - exp y) / (z - y)\\n[PROOFSTEP]\\ntrans exp y\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 (exp y - exp x) / (y - x) < exp y\\n[PROOFSTEP]\\nhave h1 : 0 < y - x := by linarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 0 < y - x\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\n\\u22a2 (exp y - exp x) / (y - x) < exp y\\n[PROOFSTEP]\\nhave h2 : x - y < 0 := by linarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\n\\u22a2 x - y < 0\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 (exp y - exp x) / (y - x) < exp y\\n[PROOFSTEP]\\nrw [div_lt_iff h1]\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y - exp x < exp y * (y - x)\\n[PROOFSTEP]\\ncalc\\n exp y - exp x = exp y - exp y * exp (x - y) := by rw [\\u2190 exp_add]; ring_nf\\n _ = exp y * (1 - exp (x - y)) := by ring\\n _ < exp y * -(x - y) := by gcongr; linarith [add_one_lt_exp_of_nonzero h2.ne]\\n _ = exp y * (y - x) := by ring\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y - exp x = exp y - exp y * exp (x - y)\\n[PROOFSTEP]\\nrw [\\u2190 exp_add]\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y - exp x = exp y - exp (y + (x - y))\\n[PROOFSTEP]\\nring_nf\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y - exp y * exp (x - y) = exp y * (1 - exp (x - y))\\n[PROOFSTEP]\\nring\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y * (1 - exp (x - y)) < exp y * -(x - y)\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase bc\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 1 - exp (x - y) < -(x - y)\\n[PROOFSTEP]\\nlinarith [add_one_lt_exp_of_nonzero h2.ne]\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < y - x\\nh2 : x - y < 0\\n\\u22a2 exp y * -(x - y) = exp y * (y - x)\\n[PROOFSTEP]\\nring\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 exp y < (exp z - exp y) / (z - y)\\n[PROOFSTEP]\\nhave h1 : 0 < z - y := by linarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 0 < z - y\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp y < (exp z - exp y) / (z - y)\\n[PROOFSTEP]\\nrw [lt_div_iff h1]\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp y * (z - y) < exp z - exp y\\n[PROOFSTEP]\\ncalc\\n exp y * (z - y) < exp y * (exp (z - y) - 1) := by\\n gcongr _ * ?_\\n linarith [add_one_lt_exp_of_nonzero h1.ne']\\n _ = exp (z - y) * exp y - exp y := by ring\\n _ \\u2264 exp z - exp y := by rw [\\u2190 exp_add]; ring_nf; rfl\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp y * (z - y) < exp y * (exp (z - y) - 1)\\n[PROOFSTEP]\\ngcongr _ * ?_\\n[GOAL]\\ncase bc\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 z - y < exp (z - y) - 1\\n[PROOFSTEP]\\nlinarith [add_one_lt_exp_of_nonzero h1.ne']\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp y * (exp (z - y) - 1) = exp (z - y) * exp y - exp y\\n[PROOFSTEP]\\nring\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp (z - y) * exp y - exp y \\u2264 exp z - exp y\\n[PROOFSTEP]\\nrw [\\u2190 exp_add]\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp (z - y + y) - exp y \\u2264 exp z - exp y\\n[PROOFSTEP]\\nring_nf\\n[GOAL]\\nx y z : \\u211d\\nhxy : x < y\\nhyz : y < z\\nh1 : 0 < z - y\\n\\u22a2 exp z - exp y \\u2264 exp z - exp y\\n[PROOFSTEP]\\nrfl\\n[GOAL]\\nn : \\u2115\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ n\\n[PROOFSTEP]\\ninduction' n with k IH\\n[GOAL]\\ncase zero\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ Nat.zero\\n[PROOFSTEP]\\nexact convexOn_const (1 : \\u211d) (convex_Ici _)\\n[GOAL]\\ncase succ\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ Nat.succ k\\n[PROOFSTEP]\\nrefine' \\u27e8convex_Ici _, _\\u27e9\\n[GOAL]\\ncase succ\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\n\\u22a2 \\u2200 \\u2983x : \\u211d\\u2984,\\n x \\u2208 Ici 0 \\u2192\\n \\u2200 \\u2983y : \\u211d\\u2984,\\n y \\u2208 Ici 0 \\u2192\\n \\u2200 \\u2983a b : \\u211d\\u2984,\\n 0 \\u2264 a \\u2192\\n 0 \\u2264 b \\u2192\\n a + b = 1 \\u2192\\n (fun x => x ^ Nat.succ k) (a \\u2022 x + b \\u2022 y) \\u2264\\n a \\u2022 (fun x => x ^ Nat.succ k) x + b \\u2022 (fun x => x ^ Nat.succ k) y\\n[PROOFSTEP]\\nrintro a (ha : 0 \\u2264 a) b (hb : 0 \\u2264 b) \\u03bc \\u03bd h\\u03bc h\\u03bd h\\n[GOAL]\\ncase succ\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (fun x => x ^ Nat.succ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ Nat.succ k) a + \\u03bd \\u2022 (fun x => x ^ Nat.succ k) b\\n[PROOFSTEP]\\nhave H := IH.2 ha hb h\\u03bc h\\u03bd h\\n[GOAL]\\ncase succ\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\n\\u22a2 (fun x => x ^ Nat.succ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ Nat.succ k) a + \\u03bd \\u2022 (fun x => x ^ Nat.succ k) b\\n[PROOFSTEP]\\nhave : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd :=\\n by\\n cases' le_or_lt a b with hab hab\\n \\u00b7 have : a ^ k \\u2264 b ^ k := by gcongr\\n have : 0 \\u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\\n positivity\\n \\u00b7 have : b ^ k \\u2264 a ^ k := by gcongr\\n have : 0 \\u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\\n positivity\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\ncases' le_or_lt a b with hab hab\\n[GOAL]\\ncase inl\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : a \\u2264 b\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\nhave : a ^ k \\u2264 b ^ k := by gcongr\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : a \\u2264 b\\n\\u22a2 a ^ k \\u2264 b ^ k\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase inl\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : a \\u2264 b\\nthis : a ^ k \\u2264 b ^ k\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\nhave : 0 \\u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : a \\u2264 b\\nthis : a ^ k \\u2264 b ^ k\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a)\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase inl\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : a \\u2264 b\\nthis\\u271d : a ^ k \\u2264 b ^ k\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a)\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase inr\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : b < a\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\nhave : b ^ k \\u2264 a ^ k := by gcongr\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : b < a\\n\\u22a2 b ^ k \\u2264 a ^ k\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase inr\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : b < a\\nthis : b ^ k \\u2264 a ^ k\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\nhave : 0 \\u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : b < a\\nthis : b ^ k \\u2264 a ^ k\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a)\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase inr\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nhab : b < a\\nthis\\u271d : b ^ k \\u2264 a ^ k\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a)\\n\\u22a2 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase succ\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (fun x => x ^ Nat.succ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ Nat.succ k) a + \\u03bd \\u2022 (fun x => x ^ Nat.succ k) b\\n[PROOFSTEP]\\ncalc\\n (\\u03bc * a + \\u03bd * b) ^ k.succ = (\\u03bc * a + \\u03bd * b) * (\\u03bc * a + \\u03bd * b) ^ k := pow_succ _ _\\n _ \\u2264 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) := by gcongr; exact H\\n _ \\u2264 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd := by linarith\\n _ = (\\u03bc + \\u03bd) * (\\u03bc * a ^ k.succ + \\u03bd * b ^ k.succ) := by rw [Nat.succ_eq_add_one]; ring\\n _ = \\u03bc * a ^ k.succ + \\u03bd * b ^ k.succ := by rw [h]; ring\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a + \\u03bd * b) ^ k \\u2264 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k)\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase h\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) ^ k \\u2264 \\u03bc * a ^ k + \\u03bd * b ^ k\\n[PROOFSTEP]\\nexact H\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) \\u2264\\n (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd =\\n (\\u03bc + \\u03bd) * (\\u03bc * a ^ Nat.succ k + \\u03bd * b ^ Nat.succ k)\\n[PROOFSTEP]\\nrw [Nat.succ_eq_add_one]\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) * (\\u03bc * a ^ k + \\u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd =\\n (\\u03bc + \\u03bd) * (\\u03bc * a ^ (k + 1) + \\u03bd * b ^ (k + 1))\\n[PROOFSTEP]\\nring\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc + \\u03bd) * (\\u03bc * a ^ Nat.succ k + \\u03bd * b ^ Nat.succ k) = \\u03bc * a ^ Nat.succ k + \\u03bd * b ^ Nat.succ k\\n[PROOFSTEP]\\nrw [h]\\n[GOAL]\\nk : \\u2115\\nIH : ConvexOn \\u211d (Ici 0) fun x => x ^ k\\na : \\u211d\\nha : 0 \\u2264 a\\nb : \\u211d\\nhb : 0 \\u2264 b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nH : (fun x => x ^ k) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ k) a + \\u03bd \\u2022 (fun x => x ^ k) b\\nthis : 0 \\u2264 (b ^ k - a ^ k) * (b - a) * \\u03bc * \\u03bd\\n\\u22a2 1 * (\\u03bc * a ^ Nat.succ k + \\u03bd * b ^ Nat.succ k) = \\u03bc * a ^ Nat.succ k + \\u03bd * b ^ Nat.succ k\\n[PROOFSTEP]\\nring\\n[GOAL]\\nn : \\u2115\\nhn : Even n\\n\\u22a2 ConvexOn \\u211d univ fun x => x ^ n\\n[PROOFSTEP]\\nrefine' \\u27e8convex_univ, _\\u27e9\\n[GOAL]\\nn : \\u2115\\nhn : Even n\\n\\u22a2 \\u2200 \\u2983x : \\u211d\\u2984,\\n x \\u2208 univ \\u2192\\n \\u2200 \\u2983y : \\u211d\\u2984,\\n y \\u2208 univ \\u2192\\n \\u2200 \\u2983a b : \\u211d\\u2984,\\n 0 \\u2264 a \\u2192\\n 0 \\u2264 b \\u2192 a + b = 1 \\u2192 (fun x => x ^ n) (a \\u2022 x + b \\u2022 y) \\u2264 a \\u2022 (fun x => x ^ n) x + b \\u2022 (fun x => x ^ n) y\\n[PROOFSTEP]\\nrintro a - b - \\u03bc \\u03bd h\\u03bc h\\u03bd h\\n[GOAL]\\nn : \\u2115\\nhn : Even n\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (fun x => x ^ n) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ n) a + \\u03bd \\u2022 (fun x => x ^ n) b\\n[PROOFSTEP]\\nobtain \\u27e8k, rfl\\u27e9 :=\\n hn.exists_two_nsmul\\n _\\n -- Porting note: added type ascription to LHS\\n[GOAL]\\ncase intro\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\n\\u22a2 (fun x => x ^ (2 \\u2022 k)) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ (2 \\u2022 k)) a + \\u03bd \\u2022 (fun x => x ^ (2 \\u2022 k)) b\\n[PROOFSTEP]\\nhave : (0 : \\u211d) \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd := by positivity\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\n\\u22a2 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase intro\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 (fun x => x ^ (2 \\u2022 k)) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => x ^ (2 \\u2022 k)) a + \\u03bd \\u2022 (fun x => x ^ (2 \\u2022 k)) b\\n[PROOFSTEP]\\ncalc\\n (\\u03bc * a + \\u03bd * b) ^ (2 * k) = ((\\u03bc * a + \\u03bd * b) ^ 2) ^ k := by rw [pow_mul]\\n _ \\u2264 ((\\u03bc + \\u03bd) * (\\u03bc * a ^ 2 + \\u03bd * b ^ 2)) ^ k := by gcongr; linarith\\n _ = (\\u03bc * a ^ 2 + \\u03bd * b ^ 2) ^ k := by rw [h]; ring\\n _ \\u2264 \\u03bc * (a ^ 2) ^ k + \\u03bd * (b ^ 2) ^ k := ?_\\n _ \\u2264 \\u03bc * a ^ (2 * k) + \\u03bd * b ^ (2 * k) := by ring_nf;\\n rfl\\n -- Porting note: `rw [mem_Ici]` was `dsimp`\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) ^ (2 * k) = ((\\u03bc * a + \\u03bd * b) ^ 2) ^ k\\n[PROOFSTEP]\\nrw [pow_mul]\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 ((\\u03bc * a + \\u03bd * b) ^ 2) ^ k \\u2264 ((\\u03bc + \\u03bd) * (\\u03bc * a ^ 2 + \\u03bd * b ^ 2)) ^ k\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase hab\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a + \\u03bd * b) ^ 2 \\u2264 (\\u03bc + \\u03bd) * (\\u03bc * a ^ 2 + \\u03bd * b ^ 2)\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 ((\\u03bc + \\u03bd) * (\\u03bc * a ^ 2 + \\u03bd * b ^ 2)) ^ k = (\\u03bc * a ^ 2 + \\u03bd * b ^ 2) ^ k\\n[PROOFSTEP]\\nrw [h]\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 (1 * (\\u03bc * a ^ 2 + \\u03bd * b ^ 2)) ^ k = (\\u03bc * a ^ 2 + \\u03bd * b ^ 2) ^ k\\n[PROOFSTEP]\\nring\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 \\u03bc * (a ^ 2) ^ k + \\u03bd * (b ^ 2) ^ k \\u2264 \\u03bc * a ^ (2 * k) + \\u03bd * b ^ (2 * k)\\n[PROOFSTEP]\\nring_nf\\n[GOAL]\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 \\u03bc * a ^ (k * 2) + \\u03bd * b ^ (k * 2) \\u2264 \\u03bc * a ^ (k * 2) + \\u03bd * b ^ (k * 2)\\n[PROOFSTEP]\\nrfl\\n -- Porting note: `rw [mem_Ici]` was `dsimp`\\n[GOAL]\\ncase intro\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 (\\u03bc * a ^ 2 + \\u03bd * b ^ 2) ^ k \\u2264 \\u03bc * (a ^ 2) ^ k + \\u03bd * (b ^ 2) ^ k\\n[PROOFSTEP]\\nrefine' (convexOn_pow k).2 _ _ h\\u03bc h\\u03bd h\\n[GOAL]\\ncase intro.refine'_1\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 a ^ 2 \\u2208 Ici 0\\n[PROOFSTEP]\\nrw [mem_Ici]\\n[GOAL]\\ncase intro.refine'_2\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 b ^ 2 \\u2208 Ici 0\\n[PROOFSTEP]\\nrw [mem_Ici]\\n[GOAL]\\ncase intro.refine'_1\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 0 \\u2264 a ^ 2\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase intro.refine'_2\\na b \\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nk : \\u2115\\nhn : Even (2 \\u2022 k)\\nthis : 0 \\u2264 (a - b) ^ 2 * \\u03bc * \\u03bd\\n\\u22a2 0 \\u2264 b ^ 2\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\nn : \\u2115\\n\\u22a2 ConvexOn \\u211d (Ioi 0) fun x => x ^ \\u2191n\\n[PROOFSTEP]\\nsimp_rw [zpow_ofNat]\\n[GOAL]\\nn : \\u2115\\n\\u22a2 ConvexOn \\u211d (Ioi 0) fun x => x ^ n\\n[PROOFSTEP]\\nexact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)\\n[GOAL]\\nn : \\u2115\\n\\u22a2 ConvexOn \\u211d (Ioi 0) fun x => x ^ -[n+1]\\n[PROOFSTEP]\\nsimp_rw [zpow_negSucc]\\n[GOAL]\\nn : \\u2115\\n\\u22a2 ConvexOn \\u211d (Ioi 0) fun x => (x ^ (n + 1))\\u207b\\u00b9\\n[PROOFSTEP]\\nrefine' \\u27e8convex_Ioi _, _\\u27e9\\n[GOAL]\\nn : \\u2115\\n\\u22a2 \\u2200 \\u2983x : \\u211d\\u2984,\\n x \\u2208 Ioi 0 \\u2192\\n \\u2200 \\u2983y : \\u211d\\u2984,\\n y \\u2208 Ioi 0 \\u2192\\n \\u2200 \\u2983a b : \\u211d\\u2984,\\n 0 \\u2264 a \\u2192\\n 0 \\u2264 b \\u2192\\n a + b = 1 \\u2192\\n (fun x => (x ^ (n + 1))\\u207b\\u00b9) (a \\u2022 x + b \\u2022 y) \\u2264\\n a \\u2022 (fun x => (x ^ (n + 1))\\u207b\\u00b9) x + b \\u2022 (fun x => (x ^ (n + 1))\\u207b\\u00b9) y\\n[PROOFSTEP]\\nrintro a (ha : 0 < a) b (hb : 0 < b) \\u03bc \\u03bd h\\u03bc h\\u03bd h\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (fun x => (x ^ (n + 1))\\u207b\\u00b9) (\\u03bc \\u2022 a + \\u03bd \\u2022 b) \\u2264 \\u03bc \\u2022 (fun x => (x ^ (n + 1))\\u207b\\u00b9) a + \\u03bd \\u2022 (fun x => (x ^ (n + 1))\\u207b\\u00b9) b\\n[PROOFSTEP]\\nfield_simp [ha.ne', hb.ne']\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 1 / (\\u03bc * a + \\u03bd * b) ^ (n + 1) \\u2264 (\\u03bc * b ^ (n + 1) + \\u03bd * a ^ (n + 1)) / (a ^ (n + 1) * b ^ (n + 1))\\n[PROOFSTEP]\\nrw [div_le_div_iff]\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) \\u2264 (\\u03bc * b ^ (n + 1) + \\u03bd * a ^ (n + 1)) * (\\u03bc * a + \\u03bd * b) ^ (n + 1)\\n[PROOFSTEP]\\ncalc\\n (1 : \\u211d) * (a ^ (n + 1) * b ^ (n + 1)) = ((\\u03bc + \\u03bd) ^ 2 * (a * b)) ^ (n + 1) := by rw [h]; ring\\n _ \\u2264 ((\\u03bc * b + \\u03bd * a) * (\\u03bc * a + \\u03bd * b)) ^ (n + 1) := ?_\\n _ = (\\u03bc * b + \\u03bd * a) ^ (n + 1) * (\\u03bc * a + \\u03bd * b) ^ (n + 1) := by rw [mul_pow]\\n _ \\u2264 (\\u03bc * b ^ (n + 1) + \\u03bd * a ^ (n + 1)) * (\\u03bc * a + \\u03bd * b) ^ (n + 1) := ?_\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) = ((\\u03bc + \\u03bd) ^ 2 * (a * b)) ^ (n + 1)\\n[PROOFSTEP]\\nrw [h]\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) = (1 ^ 2 * (a * b)) ^ (n + 1)\\n[PROOFSTEP]\\nring\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 ((\\u03bc * b + \\u03bd * a) * (\\u03bc * a + \\u03bd * b)) ^ (n + 1) = (\\u03bc * b + \\u03bd * a) ^ (n + 1) * (\\u03bc * a + \\u03bd * b) ^ (n + 1)\\n[PROOFSTEP]\\nrw [mul_pow]\\n[GOAL]\\ncase calc_1\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 ((\\u03bc + \\u03bd) ^ 2 * (a * b)) ^ (n + 1) \\u2264 ((\\u03bc * b + \\u03bd * a) * (\\u03bc * a + \\u03bd * b)) ^ (n + 1)\\n[PROOFSTEP]\\ngcongr(?_ : \\u211d) ^ _\\n[GOAL]\\ncase calc_1.hab\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (\\u03bc + \\u03bd) ^ 2 * (a * b) \\u2264 (\\u03bc * b + \\u03bd * a) * (\\u03bc * a + \\u03bd * b)\\n[PROOFSTEP]\\nhave : (0 : \\u211d) \\u2264 \\u03bc * \\u03bd * (a - b) ^ 2 := by positivity\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 0 \\u2264 \\u03bc * \\u03bd * (a - b) ^ 2\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase calc_1.hab\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nthis : 0 \\u2264 \\u03bc * \\u03bd * (a - b) ^ 2\\n\\u22a2 (\\u03bc + \\u03bd) ^ 2 * (a * b) \\u2264 (\\u03bc * b + \\u03bd * a) * (\\u03bc * a + \\u03bd * b)\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\ncase calc_2\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (\\u03bc * b + \\u03bd * a) ^ (n + 1) * (\\u03bc * a + \\u03bd * b) ^ (n + 1) \\u2264\\n (\\u03bc * b ^ (n + 1) + \\u03bd * a ^ (n + 1)) * (\\u03bc * a + \\u03bd * b) ^ (n + 1)\\n[PROOFSTEP]\\ngcongr\\n[GOAL]\\ncase calc_2.h\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 (\\u03bc * b + \\u03bd * a) ^ (n + 1) \\u2264 \\u03bc * b ^ (n + 1) + \\u03bd * a ^ (n + 1)\\n[PROOFSTEP]\\napply (convexOn_pow (n + 1)).2 hb.le ha.le h\\u03bc h\\u03bd h\\n[GOAL]\\ncase b0\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 0 < (\\u03bc * a + \\u03bd * b) ^ (n + 1)\\n[PROOFSTEP]\\nhave : 0 < \\u03bc * a + \\u03bd * b := by cases le_or_lt a b <;> nlinarith\\n[GOAL]\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 0 < \\u03bc * a + \\u03bd * b\\n[PROOFSTEP]\\ncases le_or_lt a b\\n[GOAL]\\ncase inl\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nh\\u271d : a \\u2264 b\\n\\u22a2 0 < \\u03bc * a + \\u03bd * b\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase inr\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nh\\u271d : b < a\\n\\u22a2 0 < \\u03bc * a + \\u03bd * b\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase b0\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\nthis : 0 < \\u03bc * a + \\u03bd * b\\n\\u22a2 0 < (\\u03bc * a + \\u03bd * b) ^ (n + 1)\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase d0\\nn : \\u2115\\na : \\u211d\\nha : 0 < a\\nb : \\u211d\\nhb : 0 < b\\n\\u03bc \\u03bd : \\u211d\\nh\\u03bc : 0 \\u2264 \\u03bc\\nh\\u03bd : 0 \\u2264 \\u03bd\\nh : \\u03bc + \\u03bd = 1\\n\\u22a2 0 < a ^ (n + 1) * b ^ (n + 1)\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\n\\u22a2 StrictConcaveOn \\u211d (Ioi 0) log\\n[PROOFSTEP]\\napply strictConcaveOn_of_slope_strict_anti_adjacent (convex_Ioi (0 : \\u211d))\\n[GOAL]\\n\\u22a2 \\u2200 {x y z : \\u211d}, x \\u2208 Ioi 0 \\u2192 z \\u2208 Ioi 0 \\u2192 x < y \\u2192 y < z \\u2192 (log z - log y) / (z - y) < (log y - log x) / (y - x)\\n[PROOFSTEP]\\nrintro x y z (hx : 0 < x) (hz : 0 < z) hxy hyz\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 (log z - log y) / (z - y) < (log y - log x) / (y - x)\\n[PROOFSTEP]\\nhave hy : 0 < y := hx.trans hxy\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 (log z - log y) / (z - y) < (log y - log x) / (y - x)\\n[PROOFSTEP]\\ntrans y\\u207b\\u00b9\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 (log z - log y) / (z - y) < y\\u207b\\u00b9\\n[PROOFSTEP]\\nhave h : 0 < z - y := by linarith\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 0 < z - y\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\n\\u22a2 (log z - log y) / (z - y) < y\\u207b\\u00b9\\n[PROOFSTEP]\\nrw [div_lt_iff h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\n\\u22a2 log z - log y < y\\u207b\\u00b9 * (z - y)\\n[PROOFSTEP]\\nhave hyz' : 0 < z / y := by positivity\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\n\\u22a2 0 < z / y\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\nhyz' : 0 < z / y\\n\\u22a2 log z - log y < y\\u207b\\u00b9 * (z - y)\\n[PROOFSTEP]\\nhave hyz'' : z / y \\u2260 1 := by\\n contrapose! h\\n rw [div_eq_one_iff_eq hy.ne'] at h \\n simp [h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\nhyz' : 0 < z / y\\n\\u22a2 z / y \\u2260 1\\n[PROOFSTEP]\\ncontrapose! h\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhyz' : 0 < z / y\\nh : z / y = 1\\n\\u22a2 z - y \\u2264 0\\n[PROOFSTEP]\\nrw [div_eq_one_iff_eq hy.ne'] at h \\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhyz' : 0 < z / y\\nh : z = y\\n\\u22a2 z - y \\u2264 0\\n[PROOFSTEP]\\nsimp [h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\nhyz' : 0 < z / y\\nhyz'' : z / y \\u2260 1\\n\\u22a2 log z - log y < y\\u207b\\u00b9 * (z - y)\\n[PROOFSTEP]\\ncalc\\n log z - log y = log (z / y) := by rw [\\u2190 log_div hz.ne' hy.ne']\\n _ < z / y - 1 := (log_lt_sub_one_of_pos hyz' hyz'')\\n _ = y\\u207b\\u00b9 * (z - y) := by field_simp [hy.ne']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\nhyz' : 0 < z / y\\nhyz'' : z / y \\u2260 1\\n\\u22a2 log z - log y = log (z / y)\\n[PROOFSTEP]\\nrw [\\u2190 log_div hz.ne' hy.ne']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < z - y\\nhyz' : 0 < z / y\\nhyz'' : z / y \\u2260 1\\n\\u22a2 z / y - 1 = y\\u207b\\u00b9 * (z - y)\\n[PROOFSTEP]\\nfield_simp [hy.ne']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 y\\u207b\\u00b9 < (log y - log x) / (y - x)\\n[PROOFSTEP]\\nhave h : 0 < y - x := by linarith\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 0 < y - x\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\n\\u22a2 y\\u207b\\u00b9 < (log y - log x) / (y - x)\\n[PROOFSTEP]\\nrw [lt_div_iff h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\n\\u22a2 y\\u207b\\u00b9 * (y - x) < log y - log x\\n[PROOFSTEP]\\nhave hxy' : 0 < x / y := by positivity\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\n\\u22a2 0 < x / y\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\n\\u22a2 y\\u207b\\u00b9 * (y - x) < log y - log x\\n[PROOFSTEP]\\nhave hxy'' : x / y \\u2260 1 := by\\n contrapose! h\\n rw [div_eq_one_iff_eq hy.ne'] at h \\n simp [h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\n\\u22a2 x / y \\u2260 1\\n[PROOFSTEP]\\ncontrapose! h\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhxy' : 0 < x / y\\nh : x / y = 1\\n\\u22a2 y - x \\u2264 0\\n[PROOFSTEP]\\nrw [div_eq_one_iff_eq hy.ne'] at h \\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhxy' : 0 < x / y\\nh : x = y\\n\\u22a2 y - x \\u2264 0\\n[PROOFSTEP]\\nsimp [h]\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\nhxy'' : x / y \\u2260 1\\n\\u22a2 y\\u207b\\u00b9 * (y - x) < log y - log x\\n[PROOFSTEP]\\ncalc\\n y\\u207b\\u00b9 * (y - x) = 1 - x / y := by field_simp [hy.ne']\\n _ < -log (x / y) := by linarith [log_lt_sub_one_of_pos hxy' hxy'']\\n _ = -(log x - log y) := by rw [log_div hx.ne' hy.ne']\\n _ = log y - log x := by ring\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\nhxy'' : x / y \\u2260 1\\n\\u22a2 y\\u207b\\u00b9 * (y - x) = 1 - x / y\\n[PROOFSTEP]\\nfield_simp [hy.ne']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\nhxy'' : x / y \\u2260 1\\n\\u22a2 1 - x / y < -log (x / y)\\n[PROOFSTEP]\\nlinarith [log_lt_sub_one_of_pos hxy' hxy'']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\nhxy'' : x / y \\u2260 1\\n\\u22a2 -log (x / y) = -(log x - log y)\\n[PROOFSTEP]\\nrw [log_div hx.ne' hy.ne']\\n[GOAL]\\nx y z : \\u211d\\nhx : 0 < x\\nhz : 0 < z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nh : 0 < y - x\\nhxy' : 0 < x / y\\nhxy'' : x / y \\u2260 1\\n\\u22a2 -(log x - log y) = log y - log x\\n[PROOFSTEP]\\nring\\n[GOAL]\\ns : \\u211d\\nhs : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\n\\u22a2 1 + p * s < (1 + s) ^ p\\n[PROOFSTEP]\\nrcases eq_or_lt_of_le hs with (rfl | hs)\\n[GOAL]\\ncase inl\\np : \\u211d\\nhp : 1 < p\\nhs : -1 \\u2264 -1\\nhs' : -1 \\u2260 0\\n\\u22a2 1 + p * -1 < (1 + -1) ^ p\\n[PROOFSTEP]\\nhave : p \\u2260 0 := by positivity\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nhs : -1 \\u2264 -1\\nhs' : -1 \\u2260 0\\n\\u22a2 p \\u2260 0\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase inl\\np : \\u211d\\nhp : 1 < p\\nhs : -1 \\u2264 -1\\nhs' : -1 \\u2260 0\\nthis : p \\u2260 0\\n\\u22a2 1 + p * -1 < (1 + -1) ^ p\\n[PROOFSTEP]\\nsimpa [zero_rpow this]\\n[GOAL]\\ncase inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\n\\u22a2 1 + p * s < (1 + s) ^ p\\n[PROOFSTEP]\\nhave hs1 : 0 < 1 + s := by linarith\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\n\\u22a2 0 < 1 + s\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\ncase inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\n\\u22a2 1 + p * s < (1 + s) ^ p\\n[PROOFSTEP]\\ncases' le_or_lt (1 + p * s) 0 with hs2 hs2\\n[GOAL]\\ncase inr.inl\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 1 + p * s \\u2264 0\\n\\u22a2 1 + p * s < (1 + s) ^ p\\n[PROOFSTEP]\\nexact hs2.trans_lt (rpow_pos_of_pos hs1 _)\\n[GOAL]\\ncase inr.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\n\\u22a2 1 + p * s < (1 + s) ^ p\\n[PROOFSTEP]\\nrw [rpow_def_of_pos hs1, \\u2190 exp_log hs2]\\n[GOAL]\\ncase inr.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\n\\u22a2 exp (log (1 + p * s)) < exp (log (1 + s) * p)\\n[PROOFSTEP]\\napply exp_strictMono\\n[GOAL]\\ncase inr.inr.a\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\nhave hp : 0 < p := by positivity\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\n\\u22a2 0 < p\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\ncase inr.inr.a\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\nhave hs3 : 1 + s \\u2260 1 := by contrapose! hs'; linarith\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\n\\u22a2 1 + s \\u2260 1\\n[PROOFSTEP]\\ncontrapose! hs'\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs' : 1 + s = 1\\n\\u22a2 s = 0\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\ncase inr.inr.a\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\nhave hs4 : 1 + p * s \\u2260 1 := by contrapose! hs'; nlinarith\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\n\\u22a2 1 + p * s \\u2260 1\\n[PROOFSTEP]\\ncontrapose! hs'\\n[GOAL]\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs' : 1 + p * s = 1\\n\\u22a2 s = 0\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase inr.inr.a\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs' : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\ncases' lt_or_gt_of_ne hs' with hs' hs'\\n[GOAL]\\ncase inr.inr.a.inl\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\nrw [\\u2190 div_lt_iff hp, \\u2190 div_lt_div_right_of_neg hs']\\n -- Porting note: previously we could write `zero_lt_one` inline,\\n -- but now Lean doesn't guess we are talking about `1` fast enough.\\n[GOAL]\\ncase inr.inr.a.inl\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\n\\u22a2 log (1 + s) / s < log (1 + p * s) / p / s\\n[PROOFSTEP]\\nhaveI : (1 : \\u211d) \\u2208 Ioi 0 := zero_lt_one\\n[GOAL]\\ncase inr.inr.a.inl\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + s) / s < log (1 + p * s) / p / s\\n[PROOFSTEP]\\nconvert strictConcaveOn_log_Ioi.secant_strict_mono this hs2 hs1 hs4 hs3 _ using 1\\n[GOAL]\\ncase h.e'_3\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + s) / s = (log (1 + s) - log 1) / (1 + s - 1)\\n[PROOFSTEP]\\nfield_simp [log_one]\\n[GOAL]\\ncase h.e'_4\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + p * s) / p / s = (log (1 + p * s) - log 1) / (1 + p * s - 1)\\n[PROOFSTEP]\\nfield_simp [log_one]\\n[GOAL]\\ncase inr.inr.a.inl\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s < 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 1 + p * s < 1 + s\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ncase inr.inr.a.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\n\\u22a2 log (1 + p * s) < log (1 + s) * p\\n[PROOFSTEP]\\nrw [\\u2190 div_lt_iff hp, \\u2190 div_lt_div_right hs']\\n -- Porting note: previously we could write `zero_lt_one` inline,\\n -- but now Lean doesn't guess we are talking about `1` fast enough.\\n[GOAL]\\ncase inr.inr.a.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\n\\u22a2 log (1 + p * s) / p / s < log (1 + s) / s\\n[PROOFSTEP]\\nhaveI : (1 : \\u211d) \\u2208 Ioi 0 := zero_lt_one\\n[GOAL]\\ncase inr.inr.a.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + p * s) / p / s < log (1 + s) / s\\n[PROOFSTEP]\\nconvert strictConcaveOn_log_Ioi.secant_strict_mono this hs1 hs2 hs3 hs4 _ using 1\\n[GOAL]\\ncase h.e'_3\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + p * s) / p / s = (log (1 + p * s) - log 1) / (1 + p * s - 1)\\n[PROOFSTEP]\\nfield_simp [log_one, hp.ne']\\n[GOAL]\\ncase h.e'_4\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 log (1 + s) / s = (log (1 + s) - log 1) / (1 + s - 1)\\n[PROOFSTEP]\\nfield_simp [log_one]\\n[GOAL]\\ncase inr.inr.a.inr\\ns : \\u211d\\nhs\\u271d : -1 \\u2264 s\\nhs'\\u271d : s \\u2260 0\\np : \\u211d\\nhp\\u271d : 1 < p\\nhs : -1 < s\\nhs1 : 0 < 1 + s\\nhs2 : 0 < 1 + p * s\\nhp : 0 < p\\nhs3 : 1 + s \\u2260 1\\nhs4 : 1 + p * s \\u2260 1\\nhs' : s > 0\\nthis : 1 \\u2208 Ioi 0\\n\\u22a2 1 + s < 1 + p * s\\n[PROOFSTEP]\\nnlinarith\\n[GOAL]\\ns : \\u211d\\nhs : -1 \\u2264 s\\np : \\u211d\\nhp : 1 \\u2264 p\\n\\u22a2 1 + p * s \\u2264 (1 + s) ^ p\\n[PROOFSTEP]\\nrcases eq_or_lt_of_le hp with (rfl | hp)\\n[GOAL]\\ncase inl\\ns : \\u211d\\nhs : -1 \\u2264 s\\nhp : 1 \\u2264 1\\n\\u22a2 1 + 1 * s \\u2264 (1 + s) ^ 1\\n[PROOFSTEP]\\nsimp\\n[GOAL]\\ncase inr\\ns : \\u211d\\nhs : -1 \\u2264 s\\np : \\u211d\\nhp\\u271d : 1 \\u2264 p\\nhp : 1 < p\\n\\u22a2 1 + p * s \\u2264 (1 + s) ^ p\\n[PROOFSTEP]\\nby_cases hs' : s = 0\\n[GOAL]\\ncase pos\\ns : \\u211d\\nhs : -1 \\u2264 s\\np : \\u211d\\nhp\\u271d : 1 \\u2264 p\\nhp : 1 < p\\nhs' : s = 0\\n\\u22a2 1 + p * s \\u2264 (1 + s) ^ p\\n[PROOFSTEP]\\nsimp [hs']\\n[GOAL]\\ncase neg\\ns : \\u211d\\nhs : -1 \\u2264 s\\np : \\u211d\\nhp\\u271d : 1 \\u2264 p\\nhp : 1 < p\\nhs' : \\u00acs = 0\\n\\u22a2 1 + p * s \\u2264 (1 + s) ^ p\\n[PROOFSTEP]\\nexact (one_add_mul_self_lt_rpow_one_add hs hs' hp).le\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\n\\u22a2 StrictConvexOn \\u211d (Ici 0) fun x => x ^ p\\n[PROOFSTEP]\\napply strictConvexOn_of_slope_strict_mono_adjacent (convex_Ici (0 : \\u211d))\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\n\\u22a2 \\u2200 {x y z : \\u211d}, x \\u2208 Ici 0 \\u2192 z \\u2208 Ici 0 \\u2192 x < y \\u2192 y < z \\u2192 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nrintro x y z (hx : 0 \\u2264 x) (hz : 0 \\u2264 z) hxy hyz\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hy : 0 < y := by linarith\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\n\\u22a2 0 < y\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hy' : 0 < y ^ p := rpow_pos_of_pos hy _\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave H1 : y ^ (p - 1 + 1) = y ^ (p - 1) * y := rpow_add_one hy.ne' _\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ (p - 1 + 1) = y ^ (p - 1) * y\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nring_nf at H1 \\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\ntrans p * y ^ (p - 1)\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave h3 : 0 < y - x := by linarith only [hxy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\n\\u22a2 0 < y - x\\n[PROOFSTEP]\\nlinarith only [hxy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave hyx'' : x / y < 1 := by rwa [div_lt_one hy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\n\\u22a2 x / y < 1\\n[PROOFSTEP]\\nrwa [div_lt_one hy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave hyx''' : x / y - 1 < 0 := by linarith only [hyx'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\n\\u22a2 x / y - 1 < 0\\n[PROOFSTEP]\\nlinarith only [hyx'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave hyx'''' : 0 \\u2264 x / y := by positivity\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\n\\u22a2 0 \\u2264 x / y\\n[PROOFSTEP]\\npositivity\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave hyx''''' : -1 \\u2264 x / y - 1 := by linarith only [hyx'''']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\n\\u22a2 -1 \\u2264 x / y - 1\\n[PROOFSTEP]\\nlinarith only [hyx'''']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nhave : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1) := by\\n linarith [one_add_mul_self_lt_rpow_one_add hyx''''' hyx'''.ne hp]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\n\\u22a2 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n[PROOFSTEP]\\nlinarith [one_add_mul_self_lt_rpow_one_add hyx''''' hyx'''.ne hp]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\\n[PROOFSTEP]\\nrw [div_lt_iff h3, \\u2190 div_lt_div_right hy']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 (y ^ p - x ^ p) / y ^ p < p * y ^ (p - 1) * (y - x) / y ^ p\\n[PROOFSTEP]\\nconvert this using 1\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 (y ^ p - x ^ p) / y ^ p = 1 - (1 + (x / y - 1)) ^ p\\n[PROOFSTEP]\\nhave H : (x / y) ^ p = x ^ p / y ^ p := div_rpow hx hy.le _\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\nH : (x / y) ^ p = x ^ p / y ^ p\\n\\u22a2 (y ^ p - x ^ p) / y ^ p = 1 - (1 + (x / y - 1)) ^ p\\n[PROOFSTEP]\\nring_nf at H \\u22a2\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\nH : (x * y\\u207b\\u00b9) ^ p = x ^ p * (y ^ p)\\u207b\\u00b9\\n\\u22a2 -(x ^ p * (y ^ p)\\u207b\\u00b9) + y ^ p * (y ^ p)\\u207b\\u00b9 = 1 - (x * y\\u207b\\u00b9) ^ p\\n[PROOFSTEP]\\nfield_simp [hy.ne', hy'.ne'] at H \\u22a2\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\nH : (x / y) ^ p * y ^ p = x ^ p\\n\\u22a2 -x ^ p + y ^ p = (1 - (x / y) ^ p) * y ^ p\\n[PROOFSTEP]\\nlinear_combination H\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 p * y ^ (p - 1) * (y - x) / y ^ p = -p * (x / y - 1)\\n[PROOFSTEP]\\nring_nf at H1 \\u22a2\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 p * y ^ (-1 + p) * y * (y ^ p)\\u207b\\u00b9 - p * y ^ (-1 + p) * x * (y ^ p)\\u207b\\u00b9 = p - p * x * y\\u207b\\u00b9\\n[PROOFSTEP]\\nfield_simp [hy.ne', hy'.ne']\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nh3 : 0 < y - x\\nhyx'' : x / y < 1\\nhyx''' : x / y - 1 < 0\\nhyx'''' : 0 \\u2264 x / y\\nhyx''''' : -1 \\u2264 x / y - 1\\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\\n\\u22a2 (p * y ^ (-1 + p) * y - p * y ^ (-1 + p) * x) * y = (p * y - p * x) * y ^ p\\n[PROOFSTEP]\\nlinear_combination p * (-y + x) * H1\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hyz' : 0 < z - y := by linarith only [hyz]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\n\\u22a2 0 < z - y\\n[PROOFSTEP]\\nlinarith only [hyz]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hyz'' : 1 < z / y := by rwa [one_lt_div hy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\n\\u22a2 1 < z / y\\n[PROOFSTEP]\\nrwa [one_lt_div hy]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hyz''' : 0 < z / y - 1 := by linarith only [hyz'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\n\\u22a2 0 < z / y - 1\\n[PROOFSTEP]\\nlinarith only [hyz'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave hyz'''' : -1 \\u2264 z / y - 1 := by linarith only [hyz'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\n\\u22a2 -1 \\u2264 z / y - 1\\n[PROOFSTEP]\\nlinarith only [hyz'']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nhave : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1 := by\\n linarith [one_add_mul_self_lt_rpow_one_add hyz'''' hyz'''.ne' hp]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\n\\u22a2 p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n[PROOFSTEP]\\nlinarith [one_add_mul_self_lt_rpow_one_add hyz'''' hyz'''.ne' hp]\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\\n[PROOFSTEP]\\nrw [lt_div_iff hyz', \\u2190 div_lt_div_right hy']\\n[GOAL]\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 p * y ^ (p - 1) * (z - y) / y ^ p < (z ^ p - y ^ p) / y ^ p\\n[PROOFSTEP]\\nconvert this using 1\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 p * y ^ (p - 1) * (z - y) / y ^ p = p * (z / y - 1)\\n[PROOFSTEP]\\nring_nf at H1 \\u22a2\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 -(p * y ^ (-1 + p) * y * (y ^ p)\\u207b\\u00b9) + p * y ^ (-1 + p) * z * (y ^ p)\\u207b\\u00b9 = -p + p * z * y\\u207b\\u00b9\\n[PROOFSTEP]\\nfield_simp [hy.ne', hy'.ne'] at H1 \\u22a2\\n[GOAL]\\ncase h.e'_3\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 (-(p * y ^ (-1 + p) * y * y ^ p) + p * y ^ (-1 + p) * z * y ^ p) * y = (-(p * y) + p * z) * (y ^ p * y ^ p)\\n[PROOFSTEP]\\nlinear_combination p * (y - z) * y ^ p * H1\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\n\\u22a2 (z ^ p - y ^ p) / y ^ p = (1 + (z / y - 1)) ^ p - 1\\n[PROOFSTEP]\\nhave H : (z / y) ^ p = z ^ p / y ^ p := div_rpow hz hy.le _\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\nH : (z / y) ^ p = z ^ p / y ^ p\\n\\u22a2 (z ^ p - y ^ p) / y ^ p = (1 + (z / y - 1)) ^ p - 1\\n[PROOFSTEP]\\nring_nf at H \\u22a2\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\nH : (z * y\\u207b\\u00b9) ^ p = z ^ p * (y ^ p)\\u207b\\u00b9\\n\\u22a2 z ^ p * (y ^ p)\\u207b\\u00b9 - y ^ p * (y ^ p)\\u207b\\u00b9 = -1 + (z * y\\u207b\\u00b9) ^ p\\n[PROOFSTEP]\\nfield_simp [hy.ne', hy'.ne'] at H \\u22a2\\n[GOAL]\\ncase h.e'_4\\np : \\u211d\\nhp : 1 < p\\nx y z : \\u211d\\nhx : 0 \\u2264 x\\nhz : 0 \\u2264 z\\nhxy : x < y\\nhyz : y < z\\nhy : 0 < y\\nhy' : 0 < y ^ p\\nH1 : y ^ p = y ^ (-1 + p) * y\\nhyz' : 0 < z - y\\nhyz'' : 1 < z / y\\nhyz''' : 0 < z / y - 1\\nhyz'''' : -1 \\u2264 z / y - 1\\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\\nH : (z / y) ^ p * y ^ p = z ^ p\\n\\u22a2 z ^ p - y ^ p = (-1 + (z / y) ^ p) * y ^ p\\n[PROOFSTEP]\\nlinear_combination -H\\n[GOAL]\\np : \\u211d\\nhp : 1 \\u2264 p\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ p\\n[PROOFSTEP]\\nrcases eq_or_lt_of_le hp with (rfl | hp)\\n[GOAL]\\ncase inl\\nhp : 1 \\u2264 1\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ 1\\n[PROOFSTEP]\\nsimpa using convexOn_id (convex_Ici _)\\n[GOAL]\\ncase inr\\np : \\u211d\\nhp\\u271d : 1 \\u2264 p\\nhp : 1 < p\\n\\u22a2 ConvexOn \\u211d (Ici 0) fun x => x ^ p\\n[PROOFSTEP]\\nexact (strictConvexOn_rpow hp).convexOn\\n[GOAL]\\n\\u22a2 StrictConcaveOn \\u211d (Iio 0) log\\n[PROOFSTEP]\\nrefine' \\u27e8convex_Iio _, _\\u27e9\\n[GOAL]\\n\\u22a2 \\u2200 \\u2983x : \\u211d\\u2984,\\n x \\u2208 Iio 0 \\u2192\\n \\u2200 \\u2983y : \\u211d\\u2984,\\n y \\u2208 Iio 0 \\u2192 x \\u2260 y \\u2192 \\u2200 \\u2983a b : \\u211d\\u2984, 0 < a \\u2192 0 < b \\u2192 a + b = 1 \\u2192 a \\u2022 log x + b \\u2022 log y < log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nrintro x (hx : x < 0) y (hy : y < 0) hxy a b ha hb hab\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\n\\u22a2 a \\u2022 log x + b \\u2022 log y < log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nhave hx' : 0 < -x := by linarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\n\\u22a2 0 < -x\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\n\\u22a2 a \\u2022 log x + b \\u2022 log y < log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nhave hy' : 0 < -y := by linarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\n\\u22a2 0 < -y\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\n\\u22a2 a \\u2022 log x + b \\u2022 log y < log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nhave hxy' : -x \\u2260 -y := by contrapose! hxy; linarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\n\\u22a2 -x \\u2260 -y\\n[PROOFSTEP]\\ncontrapose! hxy\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy : -x = -y\\n\\u22a2 x = y\\n[PROOFSTEP]\\nlinarith\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 a \\u2022 log x + b \\u2022 log y < log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\ncalc\\n a \\u2022 log x + b \\u2022 log y = a \\u2022 log (-x) + b \\u2022 log (-y) := by simp_rw [log_neg_eq_log]\\n _ < log (a \\u2022 -x + b \\u2022 -y) := (strictConcaveOn_log_Ioi.2 hx' hy' hxy' ha hb hab)\\n _ = log (-(a \\u2022 x + b \\u2022 y)) := by congr 1; simp only [Algebra.id.smul_eq_mul]; ring\\n _ = _ := by rw [log_neg_eq_log]\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 a \\u2022 log x + b \\u2022 log y = a \\u2022 log (-x) + b \\u2022 log (-y)\\n[PROOFSTEP]\\nsimp_rw [log_neg_eq_log]\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 log (a \\u2022 -x + b \\u2022 -y) = log (-(a \\u2022 x + b \\u2022 y))\\n[PROOFSTEP]\\ncongr 1\\n[GOAL]\\ncase e_x\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 a \\u2022 -x + b \\u2022 -y = -(a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nsimp only [Algebra.id.smul_eq_mul]\\n[GOAL]\\ncase e_x\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 a * -x + b * -y = -(a * x + b * y)\\n[PROOFSTEP]\\nring\\n[GOAL]\\nx : \\u211d\\nhx : x < 0\\ny : \\u211d\\nhy : y < 0\\nhxy : x \\u2260 y\\na b : \\u211d\\nha : 0 < a\\nhb : 0 < b\\nhab : a + b = 1\\nhx' : 0 < -x\\nhy' : 0 < -y\\nhxy' : -x \\u2260 -y\\n\\u22a2 log (-(a \\u2022 x + b \\u2022 y)) = log (a \\u2022 x + b \\u2022 y)\\n[PROOFSTEP]\\nrw [log_neg_eq_log]\\n\"} {\"text\": \"/-\\nCopyright (c) 2022 Andrew Yang. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Andrew Yang\\n\\n! This file was ported from Lean 3 source module algebra.gcd_monoid.integrally_closed\\n! leanprover-community/mathlib commit 2032a878972d5672e7c27c957e7a6e297b044973\\n! Please do not edit these lines, except to modify the commit id\\n! if you have ported upstream changes.\\n-/\\nimport Mathbin.Algebra.GcdMonoid.Basic\\nimport Mathbin.RingTheory.IntegrallyClosed\\nimport Mathbin.RingTheory.Polynomial.Eisenstein.Basic\\n\\n/-!\\n\\n# GCD domains are integrally closed\\n\\n-/\\n\\n\\nopen BigOperators Polynomial\\n\\nvariable {R A : Type _} [CommRing R] [IsDomain R] [GCDMonoid R] [CommRing A] [Algebra R A]\\n\\ntheorem IsLocalization.surj_of_gcd_domain (M : Submonoid R) [IsLocalization M A] (z : A) :\\n \\u2203 a b : R, IsUnit (gcd a b) \\u2227 z * algebraMap R A b = algebraMap R A a :=\\n by\\n obtain \\u27e8x, \\u27e8y, hy\\u27e9, rfl\\u27e9 := IsLocalization.mk'_surjective M z\\n obtain \\u27e8x', y', hx', hy', hu\\u27e9 := extract_gcd x y\\n use x', y', hu\\n rw [mul_comm, IsLocalization.mul_mk'_eq_mk'_of_mul]\\n convert IsLocalization.mk'_mul_cancel_left _ _ using 2\\n \\u00b7 rw [Subtype.coe_mk, hy', \\u2190 mul_comm y', mul_assoc]\\n conv_lhs => rw [hx']\\n \\u00b7 infer_instance\\n#align is_localization.surj_of_gcd_domain IsLocalization.surj_of_gcd_domain\\n\\ninstance (priority := 100) GCDMonoid.toIsIntegrallyClosed : IsIntegrallyClosed R :=\\n \\u27e8fun X \\u27e8p, hp\\u2081, hp\\u2082\\u27e9 =>\\n by\\n obtain \\u27e8x, y, hg, he\\u27e9 := IsLocalization.surj_of_gcd_domain (nonZeroDivisors R) X\\n have :=\\n Polynomial.dvd_pow_natDegree_of_eval\\u2082_eq_zero (IsFractionRing.injective R <| FractionRing R)\\n hp\\u2081 y x _ hp\\u2082 (by rw [mul_comm, he])\\n have : IsUnit y := by\\n rw [isUnit_iff_dvd_one, \\u2190 one_pow]\\n exact\\n (dvd_gcd this <| dvd_refl y).trans\\n (gcd_pow_left_dvd_pow_gcd.trans <| pow_dvd_pow_of_dvd (isUnit_iff_dvd_one.1 hg) _)\\n use x * (this.unit\\u207b\\u00b9 : _)\\n erw [map_mul, \\u2190 Units.coe_map_inv, eq_comm, Units.eq_mul_inv_iff_mul_eq]\\n exact he\\u27e9\\n#align gcd_monoid.to_is_integrally_closed GCDMonoid.toIsIntegrallyClosed\\n\\n\"} {\"text\": \"import Aoc\\nimport Data.List\\nimport Data.List1\\nimport Data.Strings\\nimport Data.SortedMap\\nimport Debug.Trace\\n\\ndata Production = Terminal String | NTs (List (List Int))\\nShow Production where\\n show (Terminal s) = show s\\n show (NTs s) = show s\\n\\nRules : Type\\nRules = SortedMap Int Production\\n\\ntoRules : List (Int, Production) -> Rules\\ntoRules = fromList\\n\\nparseRule : String -> Maybe (Int, Production)\\nparseRule s = do\\n (sn:::[rest]) <- pure (split (==':') s) | _ => Nothing\\n n <- parsePositive {a=Int} sn\\n case split (=='\\\"') rest of\\n (\\\" \\\":::[t,\\\"\\\"]) => Just (n, Terminal t)\\n _ =>\\n let parseChain = traverse parsePositive . forget . split (==' ') . trim\\n in case traverse parseChain . forget . split (=='|') . trim $ rest of\\n Just nts => Just (n, NTs nts)\\n Nothing => Nothing\\n\\nmunch : Eq a => List a -> List a -> Maybe (List a)\\nmunch [] ys = Just ys\\nmunch (x::xs) [] = Nothing\\nmunch (x::xs) (y::ys) = if x == y then munch xs ys else Nothing\\n\\nmutual\\n matches : Rules -> Int -> List Char -> List (List Char)\\n matches rs k cs =\\n case lookup k rs of\\n Nothing => []\\n Just (Terminal t) => toList $ munch (unpack t) cs\\n Just (NTs alts) => do\\n alt <- alts\\n matchesSeq rs alt cs\\n\\n matchesSeq : Rules -> List Int -> List Char -> List (List Char)\\n matchesSeq rs [] cs = [cs]\\n matchesSeq rs (k::ks) cs = do\\n cs' <- matches rs k cs\\n matchesSeq rs ks cs'\\n\\nmatchesFully : Rules -> Int -> String -> Bool\\nmatchesFully rs k s = any (==[]) $ matches rs k (unpack s)\\n\\nmain : IO ()\\nmain = do\\n (ls1:::[ls2]) <- readParagraphs | _ => putStrLn \\\"paragraph parse error\\\"\\n Just rules <- pure $ toRules <$> traverse parseRule ls1 | _ => putStrLn \\\"rule parse error\\\"\\n putStr \\\"* \\\"; printLn $ count (matchesFully rules 0) ls2\\n let rules' = insert 8 (NTs [[42,8],[42]]) $ insert 11 (NTs [[42,31],[42,11,31]]) $ rules\\n putStr \\\"** \\\"; printLn $ count (matchesFully rules' 0) ls2\\n\\n\"} {\"text\": \"section \\\"Setup of Environment for CAVA Model Checker\\\"\\ntheory CAVA_Base\\n imports \\n Collections.CollectionsV1 (*-- {* Compatibility with ICF 1.0 *}*)\\n Collections.Refine_Dflt \\n\\n Statistics (*-- {* Collecting statistics by instrumenting the formalization *}*)\\n\\n CAVA_Code_Target (*-- {* Code Generator Setup *}*)\\nbegin\\n\\nhide_const (open) CollectionsV1.ahs_rel\\n\\n(*\\n(* Select-function that selects element from set *)\\n(* TODO: Move! Is select properly integrated into autoref? *)\\n definition select where\\n \\\"select S \\\\<equiv> if S={} then RETURN None else RES {Some s | s. s\\\\<in>S}\\\"\\n\\nlemma select_correct: \\n \\\"select X \\\\<le> SPEC (\\\\<lambda>r. case r of None \\\\<Rightarrow> X={} | Some x \\\\<Rightarrow> x\\\\<in>X)\\\"\\n unfolding select_def\\n apply (refine_rcg refine_vcg)\\n by auto\\n*)\\n \\n text \\\\<open>Cleaning up the namespace a bit\\\\<close>\\n \\n hide_type (open) Word.word\\n no_notation test_bit (infixl \\\"!!\\\" 100)\\n\\n text \\\\<open>Some custom setup in cava, that does not match HOL defaults:\\\\<close>\\n declare Let_def[simp add]\\n\\nend\\n\"} {\"text\": \"-- An ATP local hint cannot be equal to the conjecture in which it is\\n-- used.\\n\\n-- This error is detected by Syntax.Translation.ConcreteToAbstract.\\n\\nmodule ATPBadLocalHint1 where\\n\\npostulate\\n D : Set\\n p : D\\n\\n{-# ATP prove p p #-}\\n\"} {\"text\": \"lemma add_assoc' {\\u03b1 : Type} [add_semigroup \\u03b1] :\\n \\u2200 (a b c : \\u03b1), a + (b + c) = a + b + c :=\\nbegin\\n intros a b c, rewrite add_assoc\\nend\\n\\nlemma mul_assoc' {\\u03b1 : Type} [comm_semigroup \\u03b1] :\\n \\u2200 (a b c : \\u03b1), a * (b * c) = a * b * c :=\\nbegin \\n intros a b c, rewrite mul_assoc \\nend\\n\\n#check add_right_comm\\nlemma mul_comm_assoc {\\u03b1 : Type} [comm_semigroup \\u03b1] : \\n \\u2200 a b c : \\u03b1, (a * b) * c = (a * c) * b := \\nbegin\\n intros a b c, rewrite mul_assoc, \\n rewrite mul_comm b c, \\n rewrite mul_assoc\\nend\\n\\nlemma mul_add_mul_add {\\u03b1 : Type} [ring \\u03b1] (t c x d : \\u03b1) : \\n (t + c * x) + (d * x) = t + ((c + d) * x) := \\nbegin\\n rewrite add_assoc,\\n rewrite add_mul\\nend\"} {\"text\": \"inductive Tree (\\u03b2 : Type v) where\\n | leaf\\n | node (left : Tree \\u03b2) (key : Nat) (value : \\u03b2) (right : Tree \\u03b2)\\n deriving Repr\\n\\ndef Tree.find? (t : Tree \\u03b2) (k : Nat) : Option \\u03b2 :=\\n match t with\\n | leaf => none\\n | node left key value right =>\\n if k < key then\\n left.find? k\\n else if key < k then\\n right.find? k\\n else\\n some value\\n\\ndef Tree.insert (t : Tree \\u03b2) (k : Nat) (v : \\u03b2) : Tree \\u03b2 :=\\n match t with\\n | leaf => node leaf k v leaf\\n | node left key value right =>\\n if k < key then\\n node (left.insert k v) key value right\\n else if key < k then\\n node left key value (right.insert k v)\\n else\\n node left k v right\\n\\ninductive ForallTree (p : Nat \\u2192 \\u03b2 \\u2192 Prop) : Tree \\u03b2 \\u2192 Prop\\n | leaf : ForallTree p .leaf\\n | node :\\n ForallTree p left \\u2192\\n p key value \\u2192\\n ForallTree p right \\u2192\\n ForallTree p (.node left key value right)\\n\\ninductive BST : Tree \\u03b2 \\u2192 Prop\\n | leaf : BST .leaf\\n | node :\\n {value : \\u03b2} \\u2192\\n ForallTree (fun k v => k < key) left \\u2192\\n ForallTree (fun k v => key < k) right \\u2192\\n BST left \\u2192 BST right \\u2192\\n BST (.node left key value right)\\n\\ndef BinTree (\\u03b2 : Type u) := { t : Tree \\u03b2 // BST t }\\n\\ndef BinTree.mk : BinTree \\u03b2 :=\\n \\u27e8.leaf, .leaf\\u27e9\\n\\ndef BinTree.find? (b : BinTree \\u03b2) (k : Nat) : Option \\u03b2 :=\\n b.val.find? k\\n\\ndef BinTree.insert (b : BinTree \\u03b2) (k : Nat) (v : \\u03b2) : BinTree \\u03b2 :=\\n \\u27e8b.val.insert k v, sorry\\u27e9\\n\\nattribute [local simp]\\n BinTree.mk BinTree.find?\\n BinTree.insert Tree.find? Tree.insert\\n\\ntheorem BinTree.find_insert (b : BinTree \\u03b2) (k : Nat) (v : \\u03b2)\\n : (b.insert k v).find? k = some v := by\\n let \\u27e8t, h\\u27e9 := b; simp\\n induction t with simp\\n | node left key value right ihl ihr =>\\n by_cases k < key <;> simp [*]\\n . cases h; apply ihl; done\\n . sorry\\n\"} {\"text\": \"@test problem2(4e6) == 4613732\\n\"} {\"text\": \"import Smt\\n\\ntheorem triv' : 0 + 1 = 1 := by\\n smt\\n simp_all\\n\"} {\"text\": \"lemma closure_closure [simp]: \\\"closure (closure S) = closure S\\\"\"} {\"text\": \"example : 2 + 3 = 5 :=\\nbegin\\n generalize : 3 = x,\\n sorry\\nend\\n\"} {\"text\": \"function this = orderfields(this, vals);\\n\\n for index = 1:length(this)\\n this(index).EEG = orderfields(this(index).EEG, vals);\\n end;\\n\"} {\"text\": \"[STATEMENT]\\nlemma mopup_bef_erase[simp]: \\\"mopup_bef_erase_a (s, l, []) lm n ires \\\\<Longrightarrow> \\n mopup_bef_erase_a (s, l, [Bk]) lm n ires\\\"\\n \\\"\\\\<lbrakk>n < length lm; 0 < s; s \\\\<le> 2 * n; s mod 2 = Suc 0; \\\\<not> Suc (Suc s) \\\\<le> 2 *n;\\n mopup_bef_erase_a (s, l, []) lm n ires\\\\<rbrakk>\\n \\\\<Longrightarrow> mopup_jump_over1 (s', Bk # l, []) lm n ires\\\"\\n \\\"mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\\\<Longrightarrow> l \\\\<noteq> []\\\"\\n \\\"\\\\<lbrakk>n < length lm; 0 < s; s \\\\<le> 2 * n; \\n s mod 2 \\\\<noteq> Suc 0; \\n mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\\\<rbrakk> \\n \\\\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires\\\"\\n \\\"\\\\<lbrakk>mopup_bef_erase_b (s, l, []) lm n ires\\\\<rbrakk> \\\\<Longrightarrow> \\n mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. ((mopup_bef_erase_a (s, l, []) lm n ires \\\\<Longrightarrow> mopup_bef_erase_a (s, l, [Bk]) lm n ires) &&& (\\\\<lbrakk>n < length lm; 0 < s; s \\\\<le> 2 * n; s mod 2 = Suc 0; \\\\<not> Suc (Suc s) \\\\<le> 2 * n; mopup_bef_erase_a (s, l, []) lm n ires\\\\<rbrakk> \\\\<Longrightarrow> mopup_jump_over1 (s', Bk # l, []) lm n ires)) &&& (mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\\\<Longrightarrow> l \\\\<noteq> []) &&& (\\\\<lbrakk>n < length lm; 0 < s; s \\\\<le> 2 * n; s mod 2 \\\\<noteq> Suc 0; mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\\\<rbrakk> \\\\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires) &&& (mopup_bef_erase_b (s, l, []) lm n ires \\\\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires)\\n[PROOF STEP]\\nby(auto simp: mopup_bef_erase_b.simps mopup_bef_erase_a.simps)\"} {\"text\": \";;; -*- syntax: common-lisp; package: KEIM; base: 10; mode: Theory -*-\\n;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;\\n;; ;;\\n;; Copyright (C) 1998 by AG Siekmann, Fachbereich Informatik, ;;\\n;; Universitaet des Saarlandes, Saarbruecken, Germany. ;;\\n;; All rights reserved. ;;\\n;; For information about this program, write to: ;;\\n;; KEIM Project ;;\\n;; AG Siekmann/FB Informatik ;;\\n;; Universitaet des Saarlandes ;;\\n;; Postfach 1150 ;;\\n;; D-66041 Saarbruecken ;;\\n;; Germany ;;\\n;; electronic mail: keim@ags.uni-sb.de ;;\\n;; ;;\\n;; The author makes no representations about the suitability of this ;;\\n;; software for any purpose. It is provided \\\"AS IS\\\" without express or ;;\\n;; implied warranty. In particular, it must be understood that this ;;\\n;; software is an experimental version, and is not suitable for use in ;;\\n;; any safety-critical application, and the author denies a license for ;;\\n;; such use. ;;\\n;; ;;\\n;; You may use, copy, modify and distribute this software for any ;;\\n;; noncommercial and non-safety-critical purpose. Use of this software ;;\\n;; in a commercial product is not included under this license. You must ;;\\n;; maintain this copyright statement in all copies of this software that ;;\\n;; you modify or distribute. ;;\\n;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;\\n(in-package :omega)\\n\\n\\n;Beispiel aus LIMIT\\n;(th~deftheorem absval-idempotence\\n; (in limit)\\n; (conclusion\\n; (forall (lam (a num)\\n; (= (absval (absval a))\\n; (absval a)))))\\n; (help \\\"The idempotence of |.| \\\"))\\n\\n\\n\\n\\n(th~deftheorem fact1\\n\\t (in lock-res)\\n\\t (conclusion\\n\\t\\t(forall (lam (x (o form)) (forall (lam (y (o (o form)))\\n\\t\\t\\t\\t(implies (in x y)\\n\\t\\t\\t\\t\\t (derivable x y crule-set)))))))\\n\\t (help \\\"Theorem for the fact, that every element of a set of clauses is derivable.\\\"))\\n\\n(th~deftheorem fact2\\n (in lock-res)\\n (conclusion\\n (forall (lam (y (o (o form)))\\n (implies (and (forall (lam (x (o form))\\n (implies (in x y) (setunit x))))\\n (unsat-cl-set y))\\n (derivable empty-cl y crule-set)))))\\n (help \\\"Theorem for the fact, that resolvable unit cluase, result in the empty clause.\\\"))\\n\\n;(th~deftheorem fact2\\n; (in lock-res)\\n; (conclusion\\n; (forall (lam (cs (o (o form)))\\n; (implies\\n; (exists (lam (x (o form))\\n; (exists (lam (y (o form))\\n; (and (and (and (setunit x) (setunit y))\\n; (resolvable-s x y))\\n; (and (cs x) (cs y)))))))\\n; (derivable empty-cl cs crule-set))))))\\n\\n\\n(th~deftheorem fact3\\n\\t (in lock-res)\\n\\t (conclusion\\n\\t\\t(forall (lam (klm (o (o form))) (forall (lam (gkl (o form))\\n (implies\\n (and (in klm all-clause-sets)\\n (exists (lam (kl1 (o form)) (and (klm kl1) (card>2 kl1)))))\\n (exists (lam (kl (o form)) (exists (lam (l form)\\n (and (and (implies\\n (derivable\\n gkl\\n (union (setminus klm (singleton kl))\\n (singleton (setminus kl (singleton l))))\\n crule-set)\\n (or (derivable gkl klm crule-set)\\n (derivable (union gkl (singleton l))\\n klm crule-set)))\\n (kl l))\\n (and (klm kl)\\n (card>2 kl)))))))))))))\\n\\t (help \\\"A calculus independet formulation of the Disjunction Lemma\\\"))\\n\\n\\n(th~defaxiom fact4\\n\\t (in lock-res)\\n\\t (formula (forall (lam (klm (o (o form))) (forall (lam (kl (o form))\\n\\t\\t\\t (forall (lam (l form)\\n\\t\\t\\t (implies\\n\\t\\t\\t\\t(and\\n\\t\\t\\t\\t (and (klm kl) (kl l))\\n\\t\\t\\t\\t (and (derivable\\n\\t\\t\\t\\t (union empty-cl (singleton l)) \\n\\t\\t\\t\\t klm \\n\\t\\t\\t\\t crule-set)\\n\\t\\t\\t\\t (derivable\\n\\t\\t\\t\\t empty-cl\\n\\t\\t\\t\\t (union (setminus klm (singleton kl))\\n\\t\\t\\t\\t\\t (singleton (singleton l)))\\n\\t\\t\\t\\t crule-set)))\\n\\t\\t\\t\\t (derivable empty-cl klm crule-set)))))))))\\n\\t (help \\\"A formula helping to close the eln-technique application.\\\"))\\n\\n\\n\\n(th~deftheorem leq-thm-1\\n\\t (in lock-res)\\n\\t (conclusion\\n\\t\\t(forall (lam (x num) (forall (lam (y num)\\n\\t\\t\\t (implies (and (nat x) (nat y))\\n\\t\\t\\t\\t (equiv (leq x y)\\n\\t\\t\\t\\t\\t (or (= x y)\\n\\t\\t\\t\\t\\t\\t (leq (s x) y))))))))))\\n\\n(th~deftheorem card2\\n\\t (in lock-res)\\n\\t (conclusion\\n\\t\\t(forall (lam (as (o form)) \\n\\t\\t\\t (implies (card>2 as)\\n\\t\\t\\t\\t (exists (lam (el form)\\n\\t\\t\\t\\t\\t\\t (as el))))))))\\n\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 Adam Topaz. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Adam Topaz\\n-/\\nimport topology.category.Profinite.basic\\nimport topology.locally_constant.basic\\nimport topology.discrete_quotient\\n\\n/-!\\n# Cofiltered limits of profinite sets.\\n\\nThis file contains some theorems about cofiltered limits of profinite sets.\\n\\n## Main Results\\n\\n- `exists_clopen_of_cofiltered` shows that any clopen set in a cofiltered limit of profinite\\n sets is the pullback of a clopen set from one of the factors in the limit.\\n- `exists_locally_constant` shows that any locally constant function from a cofiltered limit\\n of profinite sets factors through one of the components.\\n-/\\n\\n\\nnamespace Profinite\\n\\nopen_locale classical\\nopen category_theory\\nopen category_theory.limits\\n\\nuniverse u\\nvariables {J : Type u} [small_category J] [is_cofiltered J]\\n {F : J \\u2964 Profinite.{u}} (C : cone F) (hC : is_limit C)\\n\\ninclude hC\\n\\n/--\\nIf `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\\na clopen set in one of the terms in the limit.\\n-/\\ntheorem exists_clopen_of_cofiltered {U : set C.X} (hU : is_clopen U) :\\n \\u2203 (j : J) (V : set (F.obj j)) (hV : is_clopen V), U = C.\\u03c0.app j \\u207b\\u00b9' V :=\\nbegin\\n -- First, we have the topological basis of the cofiltered limit obtained by pulling back\\n -- clopen sets from the factors in the limit. By continuity, all such sets are again clopen.\\n have hB := Top.is_topological_basis_cofiltered_limit.{u}\\n (F \\u22d9 Profinite.to_Top)\\n (Profinite.to_Top.map_cone C)\\n (is_limit_of_preserves _ hC)\\n (\\u03bb j, {W | is_clopen W})\\n _ (\\u03bb i, is_clopen_univ) (\\u03bb i U1 U2 hU1 hU2, hU1.inter hU2) _,\\n rotate,\\n { intros i,\\n change topological_space.is_topological_basis\\n {W : set (F.obj i) | is_clopen W},\\n apply is_topological_basis_clopen },\\n { rintros i j f V (hV : is_clopen _),\\n refine \\u27e8hV.1.preimage _, hV.2.preimage _\\u27e9;\\n continuity },\\n -- Using this, since `U` is open, we can write `U` as a union of clopen sets all of which\\n -- are preimages of clopens from the factors in the limit.\\n obtain \\u27e8S,hS,h\\u27e9 := hB.open_eq_sUnion hU.1,\\n clear hB,\\n let j : S \\u2192 J := \\u03bb s, (hS s.2).some,\\n let V : \\u03a0 (s : S), set (F.obj (j s)) := \\u03bb s, (hS s.2).some_spec.some,\\n have hV : \\u2200 (s : S), is_clopen (V s) \\u2227 s.1 = C.\\u03c0.app (j s) \\u207b\\u00b9' (V s) :=\\n \\u03bb s, (hS s.2).some_spec.some_spec,\\n -- Since `U` is also closed, hence compact, it is covered by finitely many of the\\n -- clopens constructed in the previous step.\\n have := hU.2.is_compact.elim_finite_subcover (\\u03bb s : S, C.\\u03c0.app (j s) \\u207b\\u00b9' (V s)) _ _,\\n rotate,\\n { intros s,\\n refine (hV s).1.1.preimage _,\\n continuity },\\n { dsimp only,\\n rw h,\\n rintro x \\u27e8T,hT,hx\\u27e9,\\n refine \\u27e8_,\\u27e8\\u27e8T,hT\\u27e9,rfl\\u27e9,_\\u27e9,\\n dsimp only,\\n rwa \\u2190 (hV \\u27e8T,hT\\u27e9).2 },\\n -- We thus obtain a finite set `G : finset J` and a clopen set of `F.obj j` for each\\n -- `j \\u2208 G` such that `U` is the union of the preimages of these clopen sets.\\n obtain \\u27e8G,hG\\u27e9 := this,\\n -- Since `J` is cofiltered, we can find a single `j0` dominating all the `j \\u2208 G`.\\n -- Pulling back all of the sets from the previous step to `F.obj j0` and taking a union,\\n -- we obtain a clopen set in `F.obj j0` which works.\\n obtain \\u27e8j0,hj0\\u27e9 := is_cofiltered.inf_objs_exists (G.image j),\\n let f : \\u03a0 (s : S) (hs : s \\u2208 G), j0 \\u27f6 j s :=\\n \\u03bb s hs, (hj0 (finset.mem_image.mpr \\u27e8s,hs,rfl\\u27e9)).some,\\n let W : S \\u2192 set (F.obj j0) := \\u03bb s,\\n if hs : s \\u2208 G then F.map (f s hs) \\u207b\\u00b9' (V s) else set.univ,\\n -- Conclude, using the `j0` and the clopen set of `F.obj j0` obtained above.\\n refine \\u27e8j0, \\u22c3 (s : S) (hs : s \\u2208 G), W s, _, _\\u27e9,\\n { apply is_clopen_bUnion_finset,\\n intros s hs,\\n dsimp only [W],\\n rw dif_pos hs,\\n refine \\u27e8(hV s).1.1.preimage _, (hV s).1.2.preimage _\\u27e9;\\n continuity },\\n { ext x,\\n split,\\n { intro hx,\\n simp_rw [set.preimage_Union, set.mem_Union],\\n obtain \\u27e8_, \\u27e8s,rfl\\u27e9, _, \\u27e8hs, rfl\\u27e9, hh\\u27e9 := hG hx,\\n refine \\u27e8s, hs, _\\u27e9,\\n dsimp only [W] at hh \\u22a2,\\n rwa [dif_pos hs, \\u2190 set.preimage_comp, \\u2190 Profinite.coe_comp, C.w] },\\n { intro hx,\\n simp_rw [set.preimage_Union, set.mem_Union] at hx,\\n obtain \\u27e8s,hs,hx\\u27e9 := hx,\\n rw h,\\n refine \\u27e8s.1,s.2,_\\u27e9,\\n rw (hV s).2,\\n dsimp only [W] at hx,\\n rwa [dif_pos hs, \\u2190 set.preimage_comp, \\u2190 Profinite.coe_comp, C.w] at hx } }\\nend\\n\\nlemma exists_locally_constant_fin_two (f : locally_constant C.X (fin 2)) :\\n \\u2203 (j : J) (g : locally_constant (F.obj j) (fin 2)), f = g.comap (C.\\u03c0.app _) :=\\nbegin\\n let U := f \\u207b\\u00b9' {0},\\n have hU : is_clopen U := f.is_locally_constant.is_clopen_fiber _,\\n obtain \\u27e8j,V,hV,h\\u27e9 := exists_clopen_of_cofiltered C hC hU,\\n use [j, locally_constant.of_clopen hV],\\n apply locally_constant.locally_constant_eq_of_fiber_zero_eq,\\n rw locally_constant.coe_comap _ _ (C.\\u03c0.app j).continuous,\\n conv_rhs { rw set.preimage_comp },\\n rw [locally_constant.of_clopen_fiber_zero hV, \\u2190 h],\\nend\\n\\n\\n\\ntheorem exists_locally_constant_finite_nonempty {\\u03b1 : Type*} [finite \\u03b1] [nonempty \\u03b1]\\n (f : locally_constant C.X \\u03b1) :\\n \\u2203 (j : J) (g : locally_constant (F.obj j) \\u03b1), f = g.comap (C.\\u03c0.app _) :=\\nbegin\\n inhabit \\u03b1,\\n obtain \\u27e8j,gg,h\\u27e9 := exists_locally_constant_finite_aux _ hC f,\\n let \\u03b9 : \\u03b1 \\u2192 \\u03b1 \\u2192 fin 2 := \\u03bb a b, if a = b then 0 else 1,\\n let \\u03c3 : (\\u03b1 \\u2192 fin 2) \\u2192 \\u03b1 := \\u03bb f, if h : \\u2203 (a : \\u03b1), \\u03b9 a = f then h.some else arbitrary _,\\n refine \\u27e8j, gg.map \\u03c3, _\\u27e9,\\n ext,\\n rw locally_constant.coe_comap _ _ (C.\\u03c0.app j).continuous,\\n dsimp [\\u03c3],\\n have h1 : \\u03b9 (f x) = gg (C.\\u03c0.app j x),\\n { change f.map (\\u03bb a b, if a = b then (0 : fin 2) else 1) x = _,\\n rw [h, locally_constant.coe_comap _ _ (C.\\u03c0.app j).continuous] },\\n have h2 : \\u2203 a : \\u03b1, \\u03b9 a = gg (C.\\u03c0.app j x) := \\u27e8f x, h1\\u27e9,\\n rw dif_pos h2,\\n apply_fun \\u03b9,\\n { rw h2.some_spec,\\n exact h1 },\\n { intros a b hh,\\n apply_fun (\\u03bb e, e a) at hh,\\n dsimp [\\u03b9] at hh,\\n rw if_pos rfl at hh,\\n split_ifs at hh with hh1 hh1,\\n { exact hh1.symm },\\n { exact false.elim (bot_ne_top hh) } }\\nend\\n\\n/-- Any locally constant function from a cofiltered limit of profinite sets factors through\\none of the components. -/\\ntheorem exists_locally_constant {\\u03b1 : Type*} (f : locally_constant C.X \\u03b1) :\\n \\u2203 (j : J) (g : locally_constant (F.obj j) \\u03b1), f = g.comap (C.\\u03c0.app _) :=\\nbegin\\n let S := f.discrete_quotient,\\n let ff : S \\u2192 \\u03b1 := f.lift,\\n casesI is_empty_or_nonempty S,\\n { suffices : \\u2203 j, is_empty (F.obj j),\\n { refine this.imp (\\u03bb j hj, _),\\n refine \\u27e8\\u27e8hj.elim, \\u03bb A, _\\u27e9, _\\u27e9,\\n { convert is_open_empty,\\n exact @set.eq_empty_of_is_empty _ hj _ },\\n { ext x,\\n exact hj.elim' (C.\\u03c0.app j x) } },\\n simp only [\\u2190 not_nonempty_iff, \\u2190 not_forall],\\n intros h,\\n haveI : \\u2200 j : J, nonempty ((F \\u22d9 Profinite.to_Top).obj j) := h,\\n haveI : \\u2200 j : J, t2_space ((F \\u22d9 Profinite.to_Top).obj j) := \\u03bb j,\\n (infer_instance : t2_space (F.obj j)),\\n haveI : \\u2200 j : J, compact_space ((F \\u22d9 Profinite.to_Top).obj j) := \\u03bb j,\\n (infer_instance : compact_space (F.obj j)),\\n have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system\\n (F \\u22d9 Profinite.to_Top),\\n suffices : nonempty C.X, from is_empty.false (S.proj this.some),\\n let D := Profinite.to_Top.map_cone C,\\n have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC,\\n have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit.{u} _)).inv,\\n exact cond.map CD },\\n { let f' : locally_constant C.X S := \\u27e8S.proj, S.proj_is_locally_constant\\u27e9,\\n obtain \\u27e8j, g', hj\\u27e9 := exists_locally_constant_finite_nonempty _ hC f',\\n refine \\u27e8j, \\u27e8ff \\u2218 g', g'.is_locally_constant.comp _\\u27e9,_\\u27e9,\\n ext1 t,\\n apply_fun (\\u03bb e, e t) at hj,\\n rw locally_constant.coe_comap _ _ (C.\\u03c0.app j).continuous at hj \\u22a2,\\n dsimp at hj \\u22a2,\\n rw \\u2190 hj,\\n refl },\\nend\\n\\nend Profinite\\n\"} {\"text\": \"test_msi_sync_to_archive {\\n\\n *err = errormsg(\\n msisync_to_archive(\\n \\\"comp_resc;cache_resc\\\",\\n \\\"/tmp/cache_resc/home/rods/file1\\\",\\n \\\"/tempZone/home/rods/file1\\\" ),\\n *msg );\\n if( 0 != *err ) {\\n writeLine( \\\"stdout\\\", \\\"Error - [*msg], *err\\\" );\\n } else {\\n writeLine( \\\"stdout\\\", \\\"success?\\\" );\\n }\\n\\n}\\n\\nINPUT null\\nOUTPUT ruleExecOut\\n\\n\"} {\"text\": \"import Data.List\\nimport Data.List1\\nimport Data.String\\n\\nimport System.File\\n\\nsimulate1 : Nat -> Nat -> Nat\\nsimulate1 0 c = 1\\nsimulate1 (S n) 0 = simulate1 n 6 + simulate1 n 8\\nsimulate1 (S n) (S c) = simulate1 n c\\n\\nrun : String -> IO ()\\nrun s = do let l = group $ sort $ catMaybes $ parsePositive {a=Nat} <$> (forget $ split (== ',') s)\\n let n = sum $ (\\\\l@(c ::: _) => (length $ forget $ l) * simulate1 256 c) <$> l\\n putStrLn $ show n\\n\\nmain : IO ()\\nmain = do Right s <- readFile \\\"input.txt\\\"\\n | Left err => putStrLn $ show err\\n run s\\n\\n\"} {\"text\": \"universe u\\n\\ndef f1 (n m : Nat) (x : Fin n) (h : n = m) : Fin m :=\\nh \\u25b8 x\\n\\ndef f2 (n m : Nat) (x : Fin n) (h : m = n) : Fin m :=\\nh \\u25b8 x\\n\\ntheorem ex1 {\\u03b1 : Sort u} {a b c : \\u03b1} (h\\u2081 : a = b) (h\\u2082 : b = c) : a = c :=\\nh\\u2082 \\u25b8 h\\u2081\\n\\ntheorem ex2 {\\u03b1 : Sort u} {a b : \\u03b1} (h : a = b) : b = a :=\\nh \\u25b8 rfl\\n\\ntheorem ex3 {\\u03b1 : Sort u} {a b c : \\u03b1} (r : \\u03b1 \\u2192 \\u03b1 \\u2192 Prop) (h\\u2081 : r a b) (h\\u2082 : b = c) : r a c :=\\nh\\u2082 \\u25b8 h\\u2081\\n\\ntheorem ex3b {\\u03b1 : Sort u} {a b c : \\u03b1} (r : \\u03b1 \\u2192 \\u03b1 \\u2192 Prop) (h\\u2081 : r a b) (h\\u2082 : b = c) : r a c :=\\nh\\u2082.symm \\u25b8 h\\u2081\\n\\ntheorem ex3c {\\u03b1 : Sort u} {a b c : \\u03b1} (r : \\u03b1 \\u2192 \\u03b1 \\u2192 Prop) (h\\u2081 : r a b) (h\\u2082 : b = c) : r a c :=\\nh\\u2082.symm.symm \\u25b8 h\\u2081\\n\\ntheorem ex4 {\\u03b1 : Sort u} {a b c : \\u03b1} (r : \\u03b1 \\u2192 \\u03b1 \\u2192 Prop) (h\\u2081 : a = b) (h\\u2082 : r b c) : r a c :=\\nh\\u2081 \\u25b8 h\\u2082\\n\\ntheorem ex5 {p : Prop} (h : p = True) : p :=\\nh \\u25b8 trivial\\n\\ntheorem ex6 {p : Prop} (h : p = False) : \\u00acp :=\\nfun hp => h \\u25b8 hp\\n\\ntheorem ex7 {\\u03b1} {a b c d : \\u03b1} (h\\u2081 : a = c) (h\\u2082 : b = d) (h\\u2083 : c \\u2260 d) : a \\u2260 b :=\\nh\\u2081 \\u25b8 h\\u2082 \\u25b8 h\\u2083\\n\\ntheorem ex8 (n m k : Nat) (h : Nat.succ n + m = Nat.succ n + k) : Nat.succ (n + m) = Nat.succ (n + k) :=\\nNat.succ_add .. \\u25b8 Nat.succ_add .. \\u25b8 h\\n\\ntheorem ex9 (a b : Nat) (h\\u2081 : a = a + b) (h\\u2082 : a = b) : a = b + a :=\\nh\\u2082 \\u25b8 h\\u2081\\n\\ntheorem ex10 (a b : Nat) (h : a = b) : b = a :=\\nh \\u25b8 rfl\\n\\ndef ex11 {\\u03b1 : Type u} {n : Nat} (a : Array \\u03b1) (i : Nat) (h\\u2081 : a.size = n) (h\\u2082 : i < n) : \\u03b1 :=\\n a.get \\u27e8i, h\\u2081 \\u25b8 h\\u2082\\u27e9\\n\\ntheorem ex12 {\\u03b1 : Type u} {n : Nat}\\n (a b : Array \\u03b1)\\n (hsz\\u2081 : a.size = n) (hsz\\u2082 : b.size = n)\\n (h : \\u2200 (i : Nat) (hi : i < n), a.getLit i hsz\\u2081 hi = b.getLit i hsz\\u2082 hi) : a = b :=\\nArray.ext a b (hsz\\u2081.trans hsz\\u2082.symm) fun i hi\\u2081 hi\\u2082 => h i (hsz\\u2081 \\u25b8 hi\\u2081)\\n\\ndef toArrayLit {\\u03b1 : Type u} (a : Array \\u03b1) (n : Nat) (hsz : a.size = n) : Array \\u03b1 :=\\nList.toArray $ Array.toListLitAux a n hsz n (hsz \\u25b8 Nat.le_refl _) []\\n\\npartial def isEqvAux {\\u03b1} (a b : Array \\u03b1) (hsz : a.size = b.size) (p : \\u03b1 \\u2192 \\u03b1 \\u2192 Bool) (i : Nat) : Bool :=\\n if h : i < a.size then\\n let aidx : Fin a.size := \\u27e8i, h\\u27e9\\n let bidx : Fin b.size := \\u27e8i, hsz \\u25b8 h\\u27e9\\n match p (a.get aidx) (b.get bidx) with\\n | true => isEqvAux a b hsz p (i+1)\\n | false => false\\n else\\n true\\n\"} {\"text\": \"module mod1\\n#ifdef _OPENACC\\ninteger, parameter :: bla = 10\\n#endif\\nend module mod1\\n\"} {\"text\": \"From stdpp Require Export BVbase tactics.\\nFrom stdpp Require Import options.\\n\\nSection definitions.\\n Context {A T : Type} `{EqDecision A}.\\n Global Instance fn_insert : Insert A T (A \\u2192 T) :=\\n \\u03bb a t f b, if decide (a = b) then t else f b.\\n Global Instance fn_alter : Alter A T (A \\u2192 T) :=\\n \\u03bb (g : T \\u2192 T) a f b, if decide (a = b) then g (f a) else f b.\\nEnd definitions.\\n\\n(* TODO: For now, we only have the properties here that do not need a notion\\n of equality of functions. *)\\n\\nSection functions.\\n Context {A T : Type} `{!EqDecision A}.\\n\\n Lemma fn_lookup_insert (f : A \\u2192 T) a t : <[a:=t]>f a = t.\\n Proof. unfold insert, fn_insert. by destruct (decide (a = a)). Qed.\\n Lemma fn_lookup_insert_rev (f : A \\u2192 T) a t1 t2 :\\n <[a:=t1]>f a = t2 \\u2192 t1 = t2.\\n Proof. rewrite fn_lookup_insert. congruence. Qed.\\n Lemma fn_lookup_insert_ne (f : A \\u2192 T) a b t : a \\u2260 b \\u2192 <[a:=t]>f b = f b.\\n Proof. unfold insert, fn_insert. by destruct (decide (a = b)). Qed.\\n\\n Lemma fn_lookup_alter (g : T \\u2192 T) (f : A \\u2192 T) a : alter g a f a = g (f a).\\n Proof. unfold alter, fn_alter. by destruct (decide (a = a)). Qed.\\n Lemma fn_lookup_alter_ne (g : T \\u2192 T) (f : A \\u2192 T) a b :\\n a \\u2260 b \\u2192 alter g a f b = f b.\\n Proof. unfold alter, fn_alter. by destruct (decide (a = b)). Qed.\\nEnd functions.\\n\"} {\"text\": \"import LeanCodePrompts.AesopSearch\\nimport Lean\\nopen Lean Meta Elab\\n\\nopaque sillyN : Nat\\nopaque sillyM : Nat\\n\\naxiom n_is_m : sillyN = sillyM\\n\\ninductive MyEmpty : Type\\n\\ntheorem MyEmpty.eql (a b : MyEmpty) : a = b := by\\n cases a\\n \\n\\n\\nelab \\\"test_aesop\\\" : tactic => do\\n Tactic.liftMetaTactic (\\n runAesop 0.5 #[``MyEmpty.eql] #[``Nat.add_comm] #[``n_is_m]\\n )\\n\\nset_option trace.leanaide.proof.info true \\n\\nset_option trace.aesop.proof true \\nset_option trace.aesop.steps true \\nset_option trace.aesop.steps.tree true \\nset_option trace.aesop.steps.ruleSelection true \\nset_option trace.aesop.steps.ruleFailures true \\n\\n\\nexample (a b : MyEmpty): a = b := by\\n test_aesop -- uses `apply MyEmpty.eql`\\n\\n\\nexample : sillyN + 1 = sillyM + 1 := by\\n test_aesop -- uses `rw [n_is_m]`\\n\\nexample : \\u03b1 \\u2192 \\u03b1 := by\\n aesop\\n\\nset_option pp.rawOnError true\\nset_option trace.Translate.info true\\n\\nexample : \\u03b1 \\u2192 \\u03b1 := by\\n test_aesop\\n\\nexample (x: List Nat) : (3 :: x).length = x.length + 1 := by\\n test_aesop\\n\\n\\nexample (x y: Nat) : x + y = y + x := by\\n test_aesop -- uses `Nat.add_comm`\\n\"} {\"text\": \"/-\\nCopyright (c) 2022 Mario Carneiro. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Mario Carneiro\\n-/\\nimport Std.Logic\\n\\n/--\\nAn alternative constructor for `LawfulMonad` which has more\\ndefaultable fields in the common case.\\n-/\\ntheorem LawfulMonad.mk' (m : Type u \\u2192 Type v) [Monad m]\\n (id_map : \\u2200 {\\u03b1} (x : m \\u03b1), id <$> x = x)\\n (pure_bind : \\u2200 {\\u03b1 \\u03b2} (x : \\u03b1) (f : \\u03b1 \\u2192 m \\u03b2), pure x >>= f = f x)\\n (bind_assoc : \\u2200 {\\u03b1 \\u03b2 \\u03b3} (x : m \\u03b1) (f : \\u03b1 \\u2192 m \\u03b2) (g : \\u03b2 \\u2192 m \\u03b3),\\n x >>= f >>= g = x >>= fun x => f x >>= g)\\n (map_const : \\u2200 {\\u03b1 \\u03b2} (x : \\u03b1) (y : m \\u03b2),\\n Functor.mapConst x y = Function.const \\u03b2 x <$> y := by intros; rfl)\\n (seqLeft_eq : \\u2200 {\\u03b1 \\u03b2} (x : m \\u03b1) (y : m \\u03b2),\\n x <* y = (x >>= fun a => y >>= fun _ => pure a) := by intros; rfl)\\n (seqRight_eq : \\u2200 {\\u03b1 \\u03b2} (x : m \\u03b1) (y : m \\u03b2), x *> y = (x >>= fun _ => y) := by intros; rfl)\\n (bind_pure_comp : \\u2200 {\\u03b1 \\u03b2} (f : \\u03b1 \\u2192 \\u03b2) (x : m \\u03b1),\\n x >>= (fun y => pure (f y)) = f <$> x := by intros; rfl)\\n (bind_map : \\u2200 {\\u03b1 \\u03b2} (f : m (\\u03b1 \\u2192 \\u03b2)) (x : m \\u03b1), f >>= (. <$> x) = f <*> x := by intros; rfl)\\n : LawfulMonad m :=\\n have map_pure {\\u03b1 \\u03b2} (g : \\u03b1 \\u2192 \\u03b2) (x : \\u03b1) : g <$> (pure x : m \\u03b1) = pure (g x) := by\\n rw [\\u2190 bind_pure_comp]; simp [pure_bind]\\n { id_map, bind_pure_comp, bind_map, pure_bind, bind_assoc, map_pure,\\n comp_map := by simp [\\u2190 bind_pure_comp, bind_assoc, pure_bind]\\n pure_seq := by intros; rw [\\u2190 bind_map]; simp [pure_bind]\\n seq_pure := by intros; rw [\\u2190 bind_map]; simp [map_pure, bind_pure_comp]\\n seq_assoc := by simp [\\u2190 bind_pure_comp, \\u2190 bind_map, bind_assoc, pure_bind]\\n map_const := funext fun x => funext (map_const x)\\n seqLeft_eq := by simp [seqLeft_eq, \\u2190 bind_map, \\u2190 bind_pure_comp, pure_bind, bind_assoc]\\n seqRight_eq := fun x y => by\\n rw [seqRight_eq, \\u2190 bind_map, \\u2190 bind_pure_comp, bind_assoc]; simp [pure_bind, id_map] }\\n\\ninstance : LawfulMonad (Except \\u03b5) := LawfulMonad.mk'\\n (id_map := fun x => by cases x <;> rfl)\\n (pure_bind := fun a f => rfl)\\n (bind_assoc := fun a f g => by cases a <;> rfl)\\n\\ninstance : LawfulApplicative (Except \\u03b5) := inferInstance\\ninstance : LawfulFunctor (Except \\u03b5) := inferInstance\\n\\ninstance : LawfulMonad Option := LawfulMonad.mk'\\n (id_map := fun x => by cases x <;> rfl)\\n (pure_bind := fun x f => rfl)\\n (bind_assoc := fun x f g => by cases x <;> rfl)\\n (bind_pure_comp := fun f x => by cases x <;> rfl)\\n\\ninstance : LawfulApplicative Option := inferInstance\\ninstance : LawfulFunctor Option := inferInstance\\n\\n/-!\\n## SatisfiesM\\n\\nThe `SatisfiesM` predicate works over an arbitrary (lawful) monad / applicative / functor,\\nand enables Hoare-like reasoning over monadic expressions. For example, given a monadic\\nfunction `f : \\u03b1 \\u2192 m \\u03b2`, to say that the return value of `f` satisfies `Q` whenever\\nthe input satisfies `P`, we write `\\u2200 a, P a \\u2192 SatisfiesM Q (f a)`.\\n-/\\n\\n/--\\n`SatisfiesM p (x : m \\u03b1)` lifts propositions over a monad. It asserts that `x` may as well\\nhave the type `x : m {a // p a}`, because there exists some `m {a // p a}` whose image is `x`.\\nSo `p` is the postcondition of the monadic value.\\n-/\\ndef SatisfiesM {m : Type u \\u2192 Type v} [Functor m] (p : \\u03b1 \\u2192 Prop) (x : m \\u03b1) : Prop :=\\n \\u2203 x' : m {a // p a}, Subtype.val <$> x' = x\\n\\nnamespace SatisfiesM\\n\\n/-- If `p` is always true, then every `x` satisfies it. -/\\ntheorem of_true [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (h : \\u2200 a, p a) : SatisfiesM p x :=\\n \\u27e8(fun a => \\u27e8a, h a\\u27e9) <$> x, by simp [\\u2190 comp_map, Function.comp]\\u27e9\\n\\n/--\\nIf `p` is always true, then every `x` satisfies it.\\n(This is the strongest postcondition version of `of_true`.)\\n-/\\nprotected theorem trivial [Applicative m] [LawfulApplicative m] {x : m \\u03b1} :\\n SatisfiesM (fun _ => True) x := of_true fun _ => trivial\\n\\n/-- The `SatisfiesM p x` predicate is monotonic in `p`. -/\\ntheorem imp [Functor m] [LawfulFunctor m] {x : m \\u03b1}\\n (h : SatisfiesM p x) (H : \\u2200 {a}, p a \\u2192 q a) : SatisfiesM q x :=\\n let \\u27e8x, h\\u27e9 := h; \\u27e8(fun \\u27e8a, h\\u27e9 => \\u27e8_, H h\\u27e9) <$> x, by rw [\\u2190 h, \\u2190 comp_map]; rfl\\u27e9\\n\\n/-- `SatisfiesM` distributes over `<$>`, general version. -/\\nprotected theorem map [Functor m] [LawfulFunctor m] {x : m \\u03b1}\\n (hx : SatisfiesM p x) (hf : \\u2200 {a}, p a \\u2192 q (f a)) : SatisfiesM q (f <$> x) := by\\n let \\u27e8x', hx\\u27e9 := hx\\n refine \\u27e8(fun \\u27e8a, h\\u27e9 => \\u27e8f a, hf h\\u27e9) <$> x', ?_\\u27e9\\n rw [\\u2190 hx]; simp [\\u2190 comp_map, Function.comp]\\n\\n/--\\n`SatisfiesM` distributes over `<$>`, strongest postcondition version.\\n(Use this for reasoning forward from assumptions.)\\n-/\\ntheorem map_post [Functor m] [LawfulFunctor m] {x : m \\u03b1}\\n (hx : SatisfiesM p x) : SatisfiesM (fun b => \\u2203 a, p a \\u2227 b = f a) (f <$> x) :=\\n hx.map fun h => \\u27e8_, h, rfl\\u27e9\\n\\n/--\\n`SatisfiesM` distributes over `<$>`, weakest precondition version.\\n(Use this for reasoning backward from the goal.)\\n-/\\ntheorem map_pre [Functor m] [LawfulFunctor m] {x : m \\u03b1}\\n (hx : SatisfiesM (fun a => p (f a)) x) : SatisfiesM p (f <$> x) :=\\n hx.map fun h => h\\n\\n/-- `SatisfiesM` distributes over `mapConst`, general version. -/\\nprotected theorem mapConst [Functor m] [LawfulFunctor m] {x : m \\u03b1}\\n (hx : SatisfiesM q x) (ha : \\u2200 {b}, q b \\u2192 p a) : SatisfiesM p (Functor.mapConst a x) :=\\n map_const (f := m) \\u25b8 hx.map ha\\n\\n/-- `SatisfiesM` distributes over `pure`, general version / weakest precondition version. -/\\nprotected theorem pure [Applicative m] [LawfulApplicative m]\\n (h : p a) : SatisfiesM (m := m) p (pure a) := \\u27e8pure \\u27e8_, h\\u27e9, by simp\\u27e9\\n\\n/-- `SatisfiesM` distributes over `<*>`, general version. -/\\nprotected theorem seq [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hf : SatisfiesM p\\u2081 f) (hx : SatisfiesM p\\u2082 x)\\n (H : \\u2200 {f a}, p\\u2081 f \\u2192 p\\u2082 a \\u2192 q (f a)) : SatisfiesM q (f <*> x) := by\\n match f, x, hf, hx with | _, _, \\u27e8f, rfl\\u27e9, \\u27e8x, rfl\\u27e9 => ?_\\n refine \\u27e8(fun \\u27e8a, h\\u2081\\u27e9 \\u27e8b, h\\u2082\\u27e9 => \\u27e8a b, H h\\u2081 h\\u2082\\u27e9) <$> f <*> x, ?_\\u27e9\\n simp only [\\u2190 pure_seq]; simp [SatisfiesM, seq_assoc]\\n simp only [\\u2190 pure_seq]; simp [seq_assoc, Function.comp]\\n\\n/-- `SatisfiesM` distributes over `<*>`, strongest postcondition version. -/\\nprotected theorem seq_post [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hf : SatisfiesM p\\u2081 f) (hx : SatisfiesM p\\u2082 x) :\\n SatisfiesM (fun c => \\u2203 f a, p\\u2081 f \\u2227 p\\u2082 a \\u2227 c = f a) (f <*> x) :=\\n hf.seq hx fun hf ha => \\u27e8_, _, hf, ha, rfl\\u27e9\\n\\n/--\\n`SatisfiesM` distributes over `<*>`, weakest precondition version 1.\\n(Use this when `x` and the goal are known and `f` is a subgoal.)\\n-/\\nprotected theorem seq_pre [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hf : SatisfiesM (fun f => \\u2200 {a}, p\\u2082 a \\u2192 q (f a)) f) (hx : SatisfiesM p\\u2082 x) :\\n SatisfiesM q (f <*> x) :=\\n hf.seq hx fun hf ha => hf ha\\n\\n/--\\n`SatisfiesM` distributes over `<*>`, weakest precondition version 2.\\n(Use this when `f` and the goal are known and `x` is a subgoal.)\\n-/\\nprotected theorem seq_pre' [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hf : SatisfiesM p\\u2081 f) (hx : SatisfiesM (fun a => \\u2200 {f}, p\\u2081 f \\u2192 q (f a)) x) :\\n SatisfiesM q (f <*> x) :=\\n hf.seq hx fun hf ha => ha hf\\n\\n/-- `SatisfiesM` distributes over `<*`, general version. -/\\nprotected theorem seqLeft [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hx : SatisfiesM p\\u2081 x) (hy : SatisfiesM p\\u2082 y)\\n (H : \\u2200 {a b}, p\\u2081 a \\u2192 p\\u2082 b \\u2192 q a) : SatisfiesM q (x <* y) :=\\n seqLeft_eq x y \\u25b8 (hx.map fun h _ => H h).seq_pre hy\\n\\n/-- `SatisfiesM` distributes over `*>`, general version. -/\\nprotected theorem seqRight [Applicative m] [LawfulApplicative m] {x : m \\u03b1}\\n (hx : SatisfiesM p\\u2081 x) (hy : SatisfiesM p\\u2082 y)\\n (H : \\u2200 {a b}, p\\u2081 a \\u2192 p\\u2082 b \\u2192 q b) : SatisfiesM q (x *> y) :=\\n seqRight_eq x y \\u25b8 (hx.map fun h _ => H h).seq_pre hy\\n\\n/-- `SatisfiesM` distributes over `>>=`, general version. -/\\nprotected theorem bind [Monad m] [LawfulMonad m] {f : \\u03b1 \\u2192 m \\u03b2}\\n (hx : SatisfiesM p x) (hf : \\u2200 a, p a \\u2192 SatisfiesM q (f a)) :\\n SatisfiesM q (x >>= f) := by\\n match x, hx with | _, \\u27e8x, rfl\\u27e9 => ?_\\n have g a ha := Classical.indefiniteDescription _ (hf a ha)\\n refine \\u27e8x >>= fun \\u27e8a, h\\u27e9 => g a h, ?_\\u27e9\\n simp [\\u2190 bind_pure_comp]; congr; funext \\u27e8a, h\\u27e9; simp [\\u2190 (g a h).2, \\u2190 bind_pure_comp]\\n\\n/-- `SatisfiesM` distributes over `>>=`, weakest precondition version. -/\\nprotected theorem bind_pre [Monad m] [LawfulMonad m] {f : \\u03b1 \\u2192 m \\u03b2}\\n (hx : SatisfiesM (fun a => SatisfiesM q (f a)) x) :\\n SatisfiesM q (x >>= f) := hx.bind fun _ h => h\\n\\nend SatisfiesM\\n\\n@[simp] theorem SatisfiesM_Id_eq : SatisfiesM (m := Id) p x \\u2194 p x :=\\n \\u27e8fun \\u27e8y, eq\\u27e9 => eq \\u25b8 y.2, fun h => \\u27e8\\u27e8_, h\\u27e9, rfl\\u27e9\\u27e9\\n\\n@[simp] theorem SatisfiesM_Option_eq : SatisfiesM (m := Option) p x \\u2194 \\u2200 a, x = some a \\u2192 p a :=\\n \\u27e8by revert x; intro | some _, \\u27e8some \\u27e8_, h\\u27e9, rfl\\u27e9, _, rfl => exact h,\\n fun h => match x with | some a => \\u27e8some \\u27e8a, h _ rfl\\u27e9, rfl\\u27e9 | none => \\u27e8none, rfl\\u27e9\\u27e9\\n\\n@[simp] theorem SatisfiesM_Except_eq : SatisfiesM (m := Except \\u03b5) p x \\u2194 \\u2200 a, x = .ok a \\u2192 p a :=\\n \\u27e8by revert x; intro | .ok _, \\u27e8.ok \\u27e8_, h\\u27e9, rfl\\u27e9, _, rfl => exact h,\\n fun h => match x with | .ok a => \\u27e8.ok \\u27e8a, h _ rfl\\u27e9, rfl\\u27e9 | .error e => \\u27e8.error e, rfl\\u27e9\\u27e9\\n\\n@[simp] theorem SatisfiesM_ReaderT_eq [Monad m] :\\n SatisfiesM (m := ReaderT \\u03c1 m) p x \\u2194 \\u2200 s, SatisfiesM p (x s) :=\\n (exists_congr fun a => by exact \\u27e8fun eq _ => eq \\u25b8 rfl, funext\\u27e9).trans Classical.skolem.symm\\n\\ntheorem SatisfiesM_StateRefT_eq [Monad m] :\\n SatisfiesM (m := StateRefT' \\u03c9 \\u03c3 m) p x \\u2194 \\u2200 s, SatisfiesM p (x s) := by simp\\n\\n@[simp] theorem SatisfiesM_StateT_eq [Monad m] [LawfulMonad m] :\\n SatisfiesM (m := StateT \\u03c1 m) (\\u03b1 := \\u03b1) p x \\u2194 \\u2200 s, SatisfiesM (m := m) (p \\u00b7.1) (x s) := by\\n refine .trans \\u27e8fun \\u27e8f, eq\\u27e9 => eq \\u25b8 ?_, fun \\u27e8f, h\\u27e9 => ?_\\u27e9 Classical.skolem.symm\\n \\u00b7 refine \\u27e8fun s => (fun \\u27e8\\u27e8a, h\\u27e9, s'\\u27e9 => \\u27e8\\u27e8a, s'\\u27e9, h\\u27e9) <$> f s, fun s => ?_\\u27e9\\n rw [\\u2190 comp_map, map_eq_pure_bind]; rfl\\n \\u00b7 refine \\u27e8fun s => (fun \\u27e8\\u27e8a, s'\\u27e9, h\\u27e9 => \\u27e8\\u27e8a, h\\u27e9, s'\\u27e9) <$> f s, funext fun s => ?_\\u27e9\\n show _ >>= _ = _; simp [map_eq_pure_bind, \\u2190 h]\\n\\n@[simp] theorem SatisfiesM_ExceptT_eq [Monad m] [LawfulMonad m] :\\n SatisfiesM (m := ExceptT \\u03c1 m) (\\u03b1 := \\u03b1) p x \\u2194 SatisfiesM (m := m) (\\u2200 a, \\u00b7 = .ok a \\u2192 p a) x := by\\n refine \\u27e8fun \\u27e8f, eq\\u27e9 => eq \\u25b8 ?_, fun \\u27e8f, eq\\u27e9 => eq \\u25b8 ?_\\u27e9\\n \\u00b7 exists (fun | .ok \\u27e8a, h\\u27e9 => \\u27e8.ok a, fun | _, rfl => h\\u27e9 | .error e => \\u27e8.error e, fun.\\u27e9) <$> f\\n show _ = _ >>= _; rw [\\u2190 comp_map, map_eq_pure_bind]; congr; funext a; cases a <;> rfl\\n \\u00b7 exists ((fun | \\u27e8.ok a, h\\u27e9 => .ok \\u27e8a, h _ rfl\\u27e9 | \\u27e8.error e, _\\u27e9 => .error e) <$> f : m _)\\n show _ >>= _ = _; simp [\\u2190 comp_map, map_eq_pure_bind]; congr; funext \\u27e8a, h\\u27e9; cases a <;> rfl\\n\"} {\"text\": \"(****************************************************************************)\\n(* Copyright 2020 The Project Oak Authors *)\\n(* *)\\n(* Licensed under the Apache License, Version 2.0 (the \\\"License\\\") *)\\n(* you may not use this file except in compliance with the License. *)\\n(* You may obtain a copy of the License at *)\\n(* *)\\n(* http://www.apache.org/licenses/LICENSE-2.0 *)\\n(* *)\\n(* Unless required by applicable law or agreed to in writing, software *)\\n(* distributed under the License is distributed on an \\\"AS IS\\\" BASIS, *)\\n(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)\\n(* See the License for the specific language governing permissions and *)\\n(* limitations under the License. *)\\n(****************************************************************************)\\n\\nRequire Import Coq.Arith.Arith Coq.Logic.Eqdep_dec Coq.Vectors.Vector Coq.micromega.Lia\\n Coq.NArith.NArith Coq.Strings.String Coq.NArith.Ndigits.\\nRequire Import Cava.Arrow.ArrowExport\\n Cava.BitArithmetic Cava.VectorUtils.\\nRequire Import Cava.Tactics.\\n\\nRequire Import Aes.Pkg Aes.SboxCanrightPkg.\\n\\nImport VectorNotations.\\nImport KappaNotation.\\nOpen Scope kind_scope.\\n\\n(* function automatic logic [3:0] aes_inverse_gf2p4(logic [3:0] gamma);\\n logic [3:0] delta;\\n logic [1:0] a, b, c, d;\\n a = gamma[3:2] ^ gamma[1:0];\\n b = aes_mul_gf2p2(gamma[3:2], gamma[1:0]);\\n c = aes_scale_omega2_gf2p2(aes_square_gf2p2(a));\\n d = aes_square_gf2p2(c ^ b);\\n delta[3:2] = aes_mul_gf2p2(d, gamma[1:0]);\\n delta[1:0] = aes_mul_gf2p2(d, gamma[3:2]);\\n return delta;\\nendfunction *)\\nProgram Definition aes_inverse_gf2p4\\n : <<Vector Bit 4, Unit>> ~> (Vector Bit 4) :=\\n <[\\\\ gamma =>\\n let a = (gamma[:3:2]) ^ (gamma[:1:0]) in\\n let b = !aes_mul_gf2p2 (gamma[:3:2]) (gamma[:1:0]) in\\n let c = !aes_scale_omega2_gf2p2 (!aes_square_gf2p2 a) in\\n let d = !aes_square_gf2p2 (c ^ b) in\\n concat\\n (!aes_mul_gf2p2 d (gamma[:3:2]))\\n (!aes_mul_gf2p2 d (gamma[:1:0]))\\n ]>.\\n\\n (* // Inverse in GF(2^8), using normal basis [d^16, d]\\n // (see Figure 11 in the technical report)\\n function automatic logic [7:0] aes_inverse_gf2p8(logic [7:0] gamma);\\n logic [7:0] delta;\\n logic [3:0] a, b, c, d;\\n a = gamma[7:4] ^ gamma[3:0];\\n b = aes_mul_gf2p4(gamma[7:4], gamma[3:0]);\\n c = aes_square_scale_gf2p4_gf2p2(a);\\n d = aes_inverse_gf2p4(c ^ b);\\n delta[7:4] = aes_mul_gf2p4(d, gamma[3:0]);\\n delta[3:0] = aes_mul_gf2p4(d, gamma[7:4]);\\n return delta;\\n endfunction *)\\nDefinition aes_inverse_gf2p8\\n : <<Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\\n <[\\\\ gamma =>\\n let a = (gamma[:7:4]) ^ (gamma[:3:0]) in\\n let b = !aes_mul_gf2p4 (gamma[:7:4]) (gamma[:3:0]) in\\n let c = !aes_square_scale_gf2p4_gf2p2 a in\\n let d = !aes_inverse_gf2p4 (c ^ b) in\\n\\n concat\\n (!aes_mul_gf2p4 d (gamma[:7:4]))\\n (!aes_mul_gf2p4 d (gamma[:3:0]))\\n ]>.\\n\\n(* module aes_sbox_canright (\\n input aes_pkg::ciph_op_e op_i,\\n input logic [7:0] data_i,\\n output logic [7:0] data_o\\n); *)\\nDefinition aes_sbox_canright\\n : << Bit, Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\\n <[\\\\ op_i data_i =>\\n (* // Convert to normal basis X.\\n assign data_basis_x = (op_i == CIPH_FWD) ? aes_mvm(data_i, A2X) :\\n aes_mvm(data_i ^ 8'h63, S2X); *)\\n let data_basis_x = if op_i == !CIPH_FWD\\n then !aes_mvm data_i !A2X\\n else !aes_mvm (data_i ^ #99) !S2X in\\n\\n (* // Do the inversion in normal basis X.\\n assign data_inverse = aes_inverse_gf2p8(data_basis_x); *)\\n let data_inverse = !aes_inverse_gf2p8 data_basis_x in\\n\\n (* // Convert to basis S or A.\\n assign data_o = (op_i == CIPH_FWD) ? aes_mvm(data_inverse, X2S) ^ 8'h63 :\\n aes_mvm(data_inverse, X2A); *)\\n let data_o = if op_i == !CIPH_FWD\\n then (!aes_mvm data_inverse !X2S) ^ #99\\n else !aes_mvm data_inverse !X2A in\\n\\n data_o\\n ]>.\\n\\nDefinition canright_composed\\n : << Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\\n <[\\\\input =>\\n let encoded = !aes_sbox_canright !CIPH_FWD input in\\n let decoded = !aes_sbox_canright !CIPH_INV encoded in\\n decoded ]>.\\n\\nLemma canright_composed_combinational: is_combinational (closure_conversion aes_sbox_canright).\\nProof. time simply_combinational. Qed.\\n\\nLocal Notation \\\"# x\\\" := (nat_to_bitvec_sized 8 x) (at level 99).\\n\\nGoal kinterp canright_composed (# 0, tt) = (# 0).\\nProof. time (vm_compute; auto). Qed.\\n\\n(* TODO(blaxill): reduced bound for CI time *)\\nGoal forall x, x < 100 ->\\nkinterp canright_composed (#x, tt) = (#x).\\nProof. time (repeat (lia || destruct x); now vm_compute). Qed.\\n\"} {\"text\": \"/-\\nCopyright (c) 2021 OpenAI. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\\n-/\\nimport mathzoo.imports.miniF2F\\n\\nopen_locale nat rat real big_operators topological_space\\n\\ntheorem mathd_algebra_455\\n (x : \\u211d)\\n (h\\u2080 : 2 * (2 * (2 * (2 * x))) = 48) :\\n x = 3 :=\\nbegin\\n linarith,\\nend\"} {\"text\": \"lemma contour_integral_subpath_refl [simp]: \\\"contour_integral (subpath u u g) f = 0\\\"\"} {\"text\": \"If $f$ is a real-valued function, then $\\\\int f(x) dx = c \\\\int f(t + cx) dx$ for any constant $c \\\\neq 0$.\"} {\"text\": \"[STATEMENT]\\nlemma uint64_of_uint32_code [code]:\\n \\\"uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\\n[PROOF STEP]\\nby transfer simp\"} {\"text\": \"import data.equiv.algebra\\nimport group_theory.quotient_group\\n\\n-- Some stuff is now in mathlib\\n\\nnamespace quotient_group\\n\\ntheorem map_id {G : Type*} [group G] (K : set G) [normal_subgroup K] (g : quotient K) :\\nmap K K id (\\u03bb x h, h) g = g := by induction g; refl\\n\\ntheorem map_comp\\n {G : Type*} {H : Type*} {J : Type*}\\n [group G] [group H] [group J]\\n (a : G \\u2192 H) [is_group_hom a] (b : H \\u2192 J) [is_group_hom b]\\n {G1 : set G} {H1 : set H} {J1 : set J}\\n [normal_subgroup G1] [normal_subgroup H1] [normal_subgroup J1]\\n (h1 : G1 \\u2286 a \\u207b\\u00b9' H1) (h2 : H1 \\u2286 b \\u207b\\u00b9' J1)\\n (g : quotient G1) :\\nmap H1 J1 b h2 (map G1 H1 a h1 g) = map G1 J1 (b \\u2218 a) (\\u03bb _ hx, h2 $ h1 hx) g :=\\nby induction g; refl\\n\\nend quotient_group\\n\\nopen quotient_group\\n\\n-- This version is better (than a previous, deleted version),\\n-- but Mario points out that really I shuold be using a\\n-- relation rather than h2 : he.to_equiv \\u207b\\u00b9' K = J.\\ndef mul_equiv.quotient {G : Type*} {H : Type*} [group G] [group H]\\n (he : G \\u2243* H) (J : set G) [normal_subgroup J] (K : set H) [normal_subgroup K]\\n (h2 : he.to_equiv \\u207b\\u00b9' K = J) :\\nmul_equiv (quotient_group.quotient J) (quotient_group.quotient K) :=\\n{ to_fun := quotient_group.lift J (mk \\u2218 he) begin\\n unfold set.preimage at h2,\\n intros g hg,\\n rw \\u2190h2 at hg,\\n rw \\u2190is_group_hom.mem_ker (quotient_group.mk : H \\u2192 quotient_group.quotient K),\\n rwa quotient_group.ker_mk,\\n end,\\n inv_fun := quotient_group.lift K (mk \\u2218 he.symm) begin\\n intros h hh,\\n rw \\u2190is_group_hom.mem_ker (quotient_group.mk : G \\u2192 quotient_group.quotient J),\\n rw quotient_group.ker_mk,\\n show he.to_equiv.symm h \\u2208 J,\\n rw \\u2190h2,\\n show he.to_equiv (he.to_equiv.symm h) \\u2208 K,\\n convert hh,\\n exact he.to_equiv.right_inv h\\n end,\\n left_inv := \\u03bb g, begin\\n induction g,\\n conv begin\\n to_rhs,\\n rw \\u2190he.to_equiv.left_inv g,\\n end,\\n refl, refl,\\n end,\\n right_inv := \\u03bb h, begin\\n induction h,\\n conv begin\\n to_rhs,\\n rw \\u2190he.to_equiv.right_inv h,\\n end,\\n refl, refl,\\n end,\\n map_mul' := (quotient_group.is_group_hom_quotient_lift J _ _).map_mul }\\n\"} {\"text\": \"From Perennial.program_proof.mvcc Require Import\\n txn_prelude txn_repr\\n wrbuf_repr wrbuf_open_tuples.\\n\\nSection program.\\nContext `{!heapGS \\u03a3, !mvcc_ghostG \\u03a3}.\\n\\n(*****************************************************************)\\n(* func (txn *Txn) acquire() bool *)\\n(*****************************************************************)\\nTheorem wp_txn__acquire txn tid view \\u03b3 \\u03c4 :\\n {{{ own_txn txn tid view \\u03b3 \\u03c4 }}}\\n Txn__acquire #txn\\n {{{ (ok : bool), RET #ok;\\n if ok then own_txn_ready txn tid view \\u03b3 \\u03c4 else own_txn txn tid view \\u03b3 \\u03c4\\n }}}.\\nProof.\\n iIntros (\\u03a6) \\\"Htxn H\\u03a6\\\".\\n wp_call.\\n\\n (***********************************************************)\\n (* ok := txn.wrbuf.OpenTuples(txn.tid, txn.idx) *)\\n (* return ok *)\\n (***********************************************************)\\n iNamed \\\"Htxn\\\".\\n iNamed \\\"Himpl\\\".\\n do 3 wp_loadField.\\n wp_apply (wp_wrbuf__OpenTuples with \\\"HidxRI [$HwrbufRP $Hactive]\\\").\\n iIntros (ok) \\\"[Hactive HwrbufRP]\\\".\\n wp_pures.\\n iApply \\\"H\\u03a6\\\".\\n destruct ok.\\n { (* Case success. *)\\n iDestruct \\\"HwrbufRP\\\" as (tpls) \\\"[HwrbufRP Htpls]\\\".\\n do 3 iExists _.\\n rewrite Etid.\\n iFrame \\\"Htxnmap Htpls HwrbufRP Hltuples\\\".\\n eauto 20 with iFrame.\\n }\\n { (* Case failure. *)\\n do 2 iExists _.\\n iFrame \\\"Htxnmap HwrbufRP Hltuples\\\".\\n eauto 20 with iFrame.\\n }\\nQed.\\n\\nEnd program.\\n\"} {\"text\": \"lemmas continuous_on_Re [continuous_intros] = bounded_linear.continuous_on[OF bounded_linear_Re]\"} {\"text\": \"/-\\nCopyright (c) 2020 S\\u00e9bastien Gou\\u00ebzel. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthors: S\\u00e9bastien Gou\\u00ebzel, Floris van Doorn\\n\\n! This file was ported from Lean 3 source module geometry.manifold.cont_mdiff_mfderiv\\n! leanprover-community/mathlib commit 0187644979f2d3e10a06e916a869c994facd9a87\\n! Please do not edit these lines, except to modify the commit id\\n! if you have ported upstream changes.\\n-/\\nimport Mathbin.Geometry.Manifold.Mfderiv\\n\\n/-!\\n### Interactions between differentiability, smoothness and manifold derivatives\\n\\nWe give the relation between `mdifferentiable`, `cont_mdiff`, `mfderiv`, `tangent_map`\\nand related notions.\\n\\n## Main statements\\n\\n* `cont_mdiff_on.cont_mdiff_on_tangent_map_within` states that the bundled derivative\\n of a `C\\u207f` function in a domain is `C\\u1d50` when `m + 1 \\u2264 n`.\\n* `cont_mdiff.cont_mdiff_tangent_map` states that the bundled derivative\\n of a `C\\u207f` function is `C\\u1d50` when `m + 1 \\u2264 n`.\\n-/\\n\\n\\nopen Set Function Filter ChartedSpace SmoothManifoldWithCorners Bundle\\n\\nopen Topology Manifold Bundle\\n\\n/-! ### Definition of smooth functions between manifolds -/\\n\\n\\nvariable {\\ud835\\udd5c : Type _} [NontriviallyNormedField \\ud835\\udd5c]\\n -- declare a smooth manifold `M` over the pair `(E, H)`.\\n {E : Type _}\\n [NormedAddCommGroup E] [NormedSpace \\ud835\\udd5c E] {H : Type _} [TopologicalSpace H]\\n {I : ModelWithCorners \\ud835\\udd5c E H} {M : Type _} [TopologicalSpace M] [ChartedSpace H M]\\n [Is : SmoothManifoldWithCorners I M]\\n -- declare a smooth manifold `M'` over the pair `(E', H')`.\\n {E' : Type _}\\n [NormedAddCommGroup E'] [NormedSpace \\ud835\\udd5c E'] {H' : Type _} [TopologicalSpace H']\\n {I' : ModelWithCorners \\ud835\\udd5c E' H'} {M' : Type _} [TopologicalSpace M'] [ChartedSpace H' M']\\n [I's : SmoothManifoldWithCorners I' M']\\n -- declare a smooth manifold `N` over the pair `(F, G)`.\\n {F : Type _}\\n [NormedAddCommGroup F] [NormedSpace \\ud835\\udd5c F] {G : Type _} [TopologicalSpace G]\\n {J : ModelWithCorners \\ud835\\udd5c F G} {N : Type _} [TopologicalSpace N] [ChartedSpace G N]\\n [Js : SmoothManifoldWithCorners J N]\\n -- declare a smooth manifold `N'` over the pair `(F', G')`.\\n {F' : Type _}\\n [NormedAddCommGroup F'] [NormedSpace \\ud835\\udd5c F'] {G' : Type _} [TopologicalSpace G']\\n {J' : ModelWithCorners \\ud835\\udd5c F' G'} {N' : Type _} [TopologicalSpace N'] [ChartedSpace G' N']\\n [J's : SmoothManifoldWithCorners J' N']\\n -- declare some additional normed spaces, used for fibers of vector bundles\\n {F\\u2081 : Type _}\\n [NormedAddCommGroup F\\u2081] [NormedSpace \\ud835\\udd5c F\\u2081] {F\\u2082 : Type _} [NormedAddCommGroup F\\u2082]\\n [NormedSpace \\ud835\\udd5c F\\u2082]\\n -- declare functions, sets, points and smoothness indices\\n {f f\\u2081 : M \\u2192 M'}\\n {s s\\u2081 t : Set M} {x : M} {m n : \\u2115\\u221e}\\n\\n/-! ### Deducing differentiability from smoothness -/\\n\\n\\ntheorem ContMdiffWithinAt.mdifferentiableWithinAt (hf : ContMdiffWithinAt I I' n f s x)\\n (hn : 1 \\u2264 n) : MdifferentiableWithinAt I I' f s x :=\\n by\\n suffices h : MdifferentiableWithinAt I I' f (s \\u2229 f \\u207b\\u00b9' (extChartAt I' (f x)).source) x\\n \\u00b7 rwa [mdifferentiableWithinAt_inter'] at h\\n apply hf.1.preimage_mem_nhdsWithin\\n exact extChartAt_source_mem_nhds I' (f x)\\n rw [mdifferentiableWithinAt_iff]\\n exact \\u27e8hf.1.mono (inter_subset_left _ _), (hf.2.DifferentiableWithinAt hn).mono (by mfld_set_tac)\\u27e9\\n#align cont_mdiff_within_at.mdifferentiable_within_at ContMdiffWithinAt.mdifferentiableWithinAt\\n\\ntheorem ContMdiffAt.mdifferentiableAt (hf : ContMdiffAt I I' n f x) (hn : 1 \\u2264 n) :\\n MdifferentiableAt I I' f x :=\\n mdifferentiableWithinAt_univ.1 <| ContMdiffWithinAt.mdifferentiableWithinAt hf hn\\n#align cont_mdiff_at.mdifferentiable_at ContMdiffAt.mdifferentiableAt\\n\\ntheorem ContMdiffOn.mdifferentiableOn (hf : ContMdiffOn I I' n f s) (hn : 1 \\u2264 n) :\\n MdifferentiableOn I I' f s := fun x hx => (hf x hx).MdifferentiableWithinAt hn\\n#align cont_mdiff_on.mdifferentiable_on ContMdiffOn.mdifferentiableOn\\n\\ntheorem ContMdiff.mdifferentiable (hf : ContMdiff I I' n f) (hn : 1 \\u2264 n) : Mdifferentiable I I' f :=\\n fun x => (hf x).MdifferentiableAt hn\\n#align cont_mdiff.mdifferentiable ContMdiff.mdifferentiable\\n\\ntheorem SmoothWithinAt.mdifferentiableWithinAt (hf : SmoothWithinAt I I' f s x) :\\n MdifferentiableWithinAt I I' f s x :=\\n hf.MdifferentiableWithinAt le_top\\n#align smooth_within_at.mdifferentiable_within_at SmoothWithinAt.mdifferentiableWithinAt\\n\\ntheorem SmoothAt.mdifferentiableAt (hf : SmoothAt I I' f x) : MdifferentiableAt I I' f x :=\\n hf.MdifferentiableAt le_top\\n#align smooth_at.mdifferentiable_at SmoothAt.mdifferentiableAt\\n\\ntheorem SmoothOn.mdifferentiableOn (hf : SmoothOn I I' f s) : MdifferentiableOn I I' f s :=\\n hf.MdifferentiableOn le_top\\n#align smooth_on.mdifferentiable_on SmoothOn.mdifferentiableOn\\n\\ntheorem Smooth.mdifferentiable (hf : Smooth I I' f) : Mdifferentiable I I' f :=\\n ContMdiff.mdifferentiable hf le_top\\n#align smooth.mdifferentiable Smooth.mdifferentiable\\n\\ntheorem Smooth.mdifferentiableAt (hf : Smooth I I' f) : MdifferentiableAt I I' f x :=\\n hf.Mdifferentiable x\\n#align smooth.mdifferentiable_at Smooth.mdifferentiableAt\\n\\ntheorem Smooth.mdifferentiableWithinAt (hf : Smooth I I' f) : MdifferentiableWithinAt I I' f s x :=\\n hf.MdifferentiableAt.MdifferentiableWithinAt\\n#align smooth.mdifferentiable_within_at Smooth.mdifferentiableWithinAt\\n\\n/-! ### The tangent map of a smooth function is smooth -/\\n\\n\\nsection tangentMap\\n\\n/-- If a function is `C^n` with `1 \\u2264 n` on a domain with unique derivatives, then its bundled\\nderivative is continuous. In this auxiliary lemma, we prove this fact when the source and target\\nspace are model spaces in models with corners. The general fact is proved in\\n`cont_mdiff_on.continuous_on_tangent_map_within`-/\\ntheorem ContMdiffOn.continuousOn_tangentMapWithin_aux {f : H \\u2192 H'} {s : Set H}\\n (hf : ContMdiffOn I I' n f s) (hn : 1 \\u2264 n) (hs : UniqueMdiffOn I s) :\\n ContinuousOn (tangentMapWithin I I' f s) (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) :=\\n by\\n suffices h :\\n ContinuousOn\\n (fun p : H \\u00d7 E =>\\n (f p.fst,\\n (fderivWithin \\ud835\\udd5c (writtenInExtChartAt I I' p.fst f) (I.symm \\u207b\\u00b9' s \\u2229 range I)\\n ((extChartAt I p.fst) p.fst) :\\n E \\u2192L[\\ud835\\udd5c] E')\\n p.snd))\\n (Prod.fst \\u207b\\u00b9' s)\\n \\u00b7 have A := (tangentBundleModelSpaceHomeomorph H I).Continuous\\n rw [continuous_iff_continuousOn_univ] at A\\n have B :=\\n ((tangentBundleModelSpaceHomeomorph H' I').symm.Continuous.comp_continuousOn h).comp' A\\n have :\\n univ \\u2229 \\u21d1(tangentBundleModelSpaceHomeomorph H I) \\u207b\\u00b9' (Prod.fst \\u207b\\u00b9' s) =\\n \\u03c0 (TangentSpace I) \\u207b\\u00b9' s :=\\n by\\n ext \\u27e8x, v\\u27e9\\n simp only [mfld_simps]\\n rw [this] at B\\n apply B.congr\\n rintro \\u27e8x, v\\u27e9 hx\\n dsimp [tangentMapWithin]\\n ext\\n \\u00b7 rfl\\n simp only [mfld_simps]\\n apply congr_fun\\n apply congr_arg\\n rw [MdifferentiableWithinAt.mfderivWithin (hf.mdifferentiable_on hn x hx)]\\n rfl\\n suffices h :\\n ContinuousOn\\n (fun p : H \\u00d7 E =>\\n (fderivWithin \\ud835\\udd5c (I' \\u2218 f \\u2218 I.symm) (I.symm \\u207b\\u00b9' s \\u2229 range I) (I p.fst) : E \\u2192L[\\ud835\\udd5c] E') p.snd)\\n (Prod.fst \\u207b\\u00b9' s)\\n \\u00b7 dsimp [writtenInExtChartAt, extChartAt]\\n apply\\n ContinuousOn.prod\\n (ContinuousOn.comp hf.continuous_on continuous_fst.continuous_on (subset.refl _))\\n apply h.congr\\n intro p hp\\n rfl\\n suffices h : ContinuousOn (fderivWithin \\ud835\\udd5c (I' \\u2218 f \\u2218 I.symm) (I.symm \\u207b\\u00b9' s \\u2229 range I)) (I '' s)\\n \\u00b7 have C := ContinuousOn.comp h I.continuous_to_fun.continuous_on (subset.refl _)\\n have A : Continuous fun q : (E \\u2192L[\\ud835\\udd5c] E') \\u00d7 E => q.1 q.2 :=\\n is_bounded_bilinear_map_apply.continuous\\n have B :\\n ContinuousOn\\n (fun p : H \\u00d7 E => (fderivWithin \\ud835\\udd5c (I' \\u2218 f \\u2218 I.symm) (I.symm \\u207b\\u00b9' s \\u2229 range I) (I p.1), p.2))\\n (Prod.fst \\u207b\\u00b9' s) :=\\n by\\n apply ContinuousOn.prod _ continuous_snd.continuous_on\\n refine' (ContinuousOn.comp C continuous_fst.continuous_on _ : _)\\n exact preimage_mono (subset_preimage_image _ _)\\n exact A.comp_continuous_on B\\n rw [contMdiffOn_iff] at hf\\n let x : H := I.symm (0 : E)\\n let y : H' := I'.symm (0 : E')\\n have A := hf.2 x y\\n simp only [I.image_eq, inter_comm, mfld_simps] at A\\u22a2\\n apply A.continuous_on_fderiv_within _ hn\\n convert hs.unique_diff_on_target_inter x using 1\\n simp only [inter_comm, mfld_simps]\\n#align cont_mdiff_on.continuous_on_tangent_map_within_aux ContMdiffOn.continuousOn_tangentMapWithin_aux\\n\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative is\\n`C^m` when `m+1 \\u2264 n`. In this auxiliary lemma, we prove this fact when the source and target space\\nare model spaces in models with corners. The general fact is proved in\\n`cont_mdiff_on.cont_mdiff_on_tangent_map_within` -/\\ntheorem ContMdiffOn.contMdiffOn_tangentMapWithin_aux {f : H \\u2192 H'} {s : Set H}\\n (hf : ContMdiffOn I I' n f s) (hmn : m + 1 \\u2264 n) (hs : UniqueMdiffOn I s) :\\n ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) :=\\n by\\n have m_le_n : m \\u2264 n := by\\n apply le_trans _ hmn\\n have : m + 0 \\u2264 m + 1 := add_le_add_left (zero_le _) _\\n simpa only [add_zero] using this\\n have one_le_n : 1 \\u2264 n := by\\n apply le_trans _ hmn\\n change 0 + 1 \\u2264 m + 1\\n exact add_le_add_right (zero_le _) _\\n have U' : UniqueDiffOn \\ud835\\udd5c (range I \\u2229 I.symm \\u207b\\u00b9' s) :=\\n by\\n intro y hy\\n simpa only [UniqueMdiffOn, UniqueMdiffWithinAt, hy.1, inter_comm, mfld_simps] using\\n hs (I.symm y) hy.2\\n rw [contMdiffOn_iff]\\n refine' \\u27e8hf.continuous_on_tangent_map_within_aux one_le_n hs, fun p q => _\\u27e9\\n have A :\\n range I \\u00d7\\u02e2 univ \\u2229\\n ((Equiv.sigmaEquivProd H E).symm \\u2218 fun p : E \\u00d7 E => (I.symm p.fst, p.snd)) \\u207b\\u00b9'\\n (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) =\\n (range I \\u2229 I.symm \\u207b\\u00b9' s) \\u00d7\\u02e2 univ :=\\n by\\n ext \\u27e8x, v\\u27e9\\n simp only [mfld_simps]\\n suffices h :\\n ContDiffOn \\ud835\\udd5c m\\n (((fun p : H' \\u00d7 E' => (I' p.fst, p.snd)) \\u2218 Equiv.sigmaEquivProd H' E') \\u2218\\n tangentMapWithin I I' f s \\u2218\\n (Equiv.sigmaEquivProd H E).symm \\u2218 fun p : E \\u00d7 E => (I.symm p.fst, p.snd))\\n ((range \\u21d1I \\u2229 \\u21d1I.symm \\u207b\\u00b9' s) \\u00d7\\u02e2 univ)\\n \\u00b7 simpa [A] using h\\n change\\n ContDiffOn \\ud835\\udd5c m\\n (fun p : E \\u00d7 E =>\\n ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E \\u2192 E') p.snd) : E' \\u00d7 E'))\\n ((range I \\u2229 I.symm \\u207b\\u00b9' s) \\u00d7\\u02e2 univ)\\n -- check that all bits in this formula are `C^n`\\n have hf' := contMdiffOn_iff.1 hf\\n have A : ContDiffOn \\ud835\\udd5c m (I' \\u2218 f \\u2218 I.symm) (range I \\u2229 I.symm \\u207b\\u00b9' s) := by\\n simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n\\n have B : ContDiffOn \\ud835\\udd5c m ((I' \\u2218 f \\u2218 I.symm) \\u2218 Prod.fst) ((range I \\u2229 I.symm \\u207b\\u00b9' s) \\u00d7\\u02e2 univ) :=\\n A.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\\n suffices C :\\n ContDiffOn \\ud835\\udd5c m\\n (fun p : E \\u00d7 E => (fderivWithin \\ud835\\udd5c (I' \\u2218 f \\u2218 I.symm) (I.symm \\u207b\\u00b9' s \\u2229 range I) p.1 : _) p.2)\\n ((range I \\u2229 I.symm \\u207b\\u00b9' s) \\u00d7\\u02e2 univ)\\n \\u00b7 apply ContDiffOn.prod B _\\n apply C.congr fun p hp => _\\n simp only [mfld_simps] at hp\\n simp only [mfderivWithin, hf.mdifferentiable_on one_le_n _ hp.2, hp.1, if_pos, mfld_simps]\\n have D :\\n ContDiffOn \\ud835\\udd5c m (fun x => fderivWithin \\ud835\\udd5c (I' \\u2218 f \\u2218 I.symm) (I.symm \\u207b\\u00b9' s \\u2229 range I) x)\\n (range I \\u2229 I.symm \\u207b\\u00b9' s) :=\\n by\\n have : ContDiffOn \\ud835\\udd5c n (I' \\u2218 f \\u2218 I.symm) (range I \\u2229 I.symm \\u207b\\u00b9' s) := by\\n simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)\\n simpa only [inter_comm] using this.fderiv_within U' hmn\\n have := D.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\\n have := ContDiffOn.prod this cont_diff_snd.cont_diff_on\\n exact is_bounded_bilinear_map_apply.cont_diff.comp_cont_diff_on this\\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux ContMdiffOn.contMdiffOn_tangentMapWithin_aux\\n\\ninclude Is I's\\n\\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative\\nis `C^m` when `m+1 \\u2264 n`. -/\\ntheorem ContMdiffOn.contMdiffOn_tangentMapWithin (hf : ContMdiffOn I I' n f s) (hmn : m + 1 \\u2264 n)\\n (hs : UniqueMdiffOn I s) :\\n ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) :=\\n by\\n /- The strategy of the proof is to avoid unfolding the definitions, and reduce by functoriality\\n to the case of functions on the model spaces, where we have already proved the result.\\n Let `l` and `r` be the charts to the left and to the right, so that we have\\n ```\\n l^{-1} f r\\n H --------> M ---> M' ---> H'\\n ```\\n Then the tangent map `T(r \\u2218 f \\u2218 l)` is smooth by a previous result. Consider the composition\\n ```\\n Tl T(r \\u2218 f \\u2218 l^{-1}) Tr^{-1}\\n TM -----> TH -------------------> TH' ---------> TM'\\n ```\\n where `Tr^{-1}` and `Tl` are the tangent maps of `r^{-1}` and `l`. Writing `Tl` and `Tr^{-1}` as\\n composition of charts (called `Dl` and `il` for `l` and `Dr` and `ir` in the proof below), it\\n follows that they are smooth. The composition of all these maps is `Tf`, and is therefore smooth\\n as a composition of smooth maps.\\n -/\\n have m_le_n : m \\u2264 n := by\\n apply le_trans _ hmn\\n have : m + 0 \\u2264 m + 1 := add_le_add_left (zero_le _) _\\n simpa only [add_zero]\\n have one_le_n : 1 \\u2264 n := by\\n apply le_trans _ hmn\\n change 0 + 1 \\u2264 m + 1\\n exact add_le_add_right (zero_le _) _\\n -- First step: local reduction on the space, to a set `s'` which is contained in chart domains.\\n refine' contMdiffOn_of_locally_contMdiffOn fun p hp => _\\n have hf' := contMdiffOn_iff.1 hf\\n simp only [mfld_simps] at hp\\n let l := chart_at H p.proj\\n set Dl := chart_at (ModelProd H E) p with hDl\\n let r := chart_at H' (f p.proj)\\n let Dr := chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)\\n let il := chart_at (ModelProd H E) (tangentMap I I l p)\\n let ir := chart_at (ModelProd H' E') (tangentMap I I' (r \\u2218 f) p)\\n let s' := f \\u207b\\u00b9' r.source \\u2229 s \\u2229 l.source\\n let s'_lift := \\u03c0 (TangentSpace I) \\u207b\\u00b9' s'\\n let s'l := l.target \\u2229 l.symm \\u207b\\u00b9' s'\\n let s'l_lift := \\u03c0 (TangentSpace I) \\u207b\\u00b9' s'l\\n rcases continuousOn_iff'.1 hf'.1 r.source r.open_source with \\u27e8o, o_open, ho\\u27e9\\n suffices h : ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) s'_lift\\n \\u00b7 refine' \\u27e8\\u03c0 (TangentSpace I) \\u207b\\u00b9' (o \\u2229 l.source), _, _, _\\u27e9\\n show IsOpen (\\u03c0 (TangentSpace I) \\u207b\\u00b9' (o \\u2229 l.source))\\n exact (IsOpen.inter o_open l.open_source).Preimage (continuous_proj E _)\\n show p \\u2208 \\u03c0 (TangentSpace I) \\u207b\\u00b9' (o \\u2229 l.source)\\n \\u00b7 simp\\n have : p.proj \\u2208 f \\u207b\\u00b9' r.source \\u2229 s := by simp [hp]\\n rw [ho] at this\\n exact this.1\\n \\u00b7 have : \\u03c0 (TangentSpace I) \\u207b\\u00b9' s \\u2229 \\u03c0 (TangentSpace I) \\u207b\\u00b9' (o \\u2229 l.source) = s'_lift :=\\n by\\n dsimp only [s'_lift, s']\\n rw [ho]\\n mfld_set_tac\\n rw [this]\\n exact h\\n /- Second step: check that all functions are smooth, and use the chain rule to write the bundled\\n derivative as a composition of a function between model spaces and of charts.\\n Convention: statements about the differentiability of `a \\u2218 b \\u2218 c` are named `diff_abc`. Statements\\n about differentiability in the bundle have a `_lift` suffix. -/\\n have U' : UniqueMdiffOn I s' :=\\n by\\n apply UniqueMdiffOn.inter _ l.open_source\\n rw [ho, inter_comm]\\n exact hs.inter o_open\\n have U'l : UniqueMdiffOn I s'l := U'.unique_mdiff_on_preimage (mdifferentiable_chart _ _)\\n have diff_f : ContMdiffOn I I' n f s' := hf.mono (by mfld_set_tac)\\n have diff_r : ContMdiffOn I' I' n r r.source := contMdiffOn_chart\\n have diff_rf : ContMdiffOn I I' n (r \\u2218 f) s' :=\\n by\\n apply ContMdiffOn.comp diff_r diff_f fun x hx => _\\n simp only [s', mfld_simps] at hx\\n simp only [hx, mfld_simps]\\n have diff_l : ContMdiffOn I I n l.symm s'l :=\\n haveI A : ContMdiffOn I I n l.symm l.target := contMdiffOn_chart_symm\\n A.mono (by mfld_set_tac)\\n have diff_rfl : ContMdiffOn I I' n (r \\u2218 f \\u2218 l.symm) s'l :=\\n by\\n apply ContMdiffOn.comp diff_rf diff_l\\n mfld_set_tac\\n have diff_rfl_lift :\\n ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' (r \\u2218 f \\u2218 l.symm) s'l) s'l_lift :=\\n diff_rfl.cont_mdiff_on_tangent_map_within_aux hmn U'l\\n have diff_irrfl_lift :\\n ContMdiffOn I.tangent I'.tangent m (ir \\u2218 tangentMapWithin I I' (r \\u2218 f \\u2218 l.symm) s'l) s'l_lift :=\\n haveI A : ContMdiffOn I'.tangent I'.tangent m ir ir.source := contMdiffOn_chart\\n ContMdiffOn.comp A diff_rfl_lift fun p hp => by simp only [ir, mfld_simps]\\n have diff_Drirrfl_lift :\\n ContMdiffOn I.tangent I'.tangent m (Dr.symm \\u2218 ir \\u2218 tangentMapWithin I I' (r \\u2218 f \\u2218 l.symm) s'l)\\n s'l_lift :=\\n by\\n have A : ContMdiffOn I'.tangent I'.tangent m Dr.symm Dr.target := contMdiffOn_chart_symm\\n apply ContMdiffOn.comp A diff_irrfl_lift fun p hp => _\\n simp only [s'l_lift, mfld_simps] at hp\\n simp only [ir, hp, mfld_simps]\\n -- conclusion of this step: the composition of all the maps above is smooth\\n have diff_DrirrflilDl :\\n ContMdiffOn I.tangent I'.tangent m\\n (Dr.symm \\u2218 (ir \\u2218 tangentMapWithin I I' (r \\u2218 f \\u2218 l.symm) s'l) \\u2218 il.symm \\u2218 Dl) s'_lift :=\\n by\\n have A : ContMdiffOn I.tangent I.tangent m Dl Dl.source := contMdiffOn_chart\\n have A' : ContMdiffOn I.tangent I.tangent m Dl s'_lift :=\\n by\\n apply A.mono fun p hp => _\\n simp only [s'_lift, mfld_simps] at hp\\n simp only [Dl, hp, mfld_simps]\\n have B : ContMdiffOn I.tangent I.tangent m il.symm il.target := contMdiffOn_chart_symm\\n have C : ContMdiffOn I.tangent I.tangent m (il.symm \\u2218 Dl) s'_lift :=\\n ContMdiffOn.comp B A' fun p hp => by simp only [il, mfld_simps]\\n apply ContMdiffOn.comp diff_Drirrfl_lift C fun p hp => _\\n simp only [s'_lift, mfld_simps] at hp\\n simp only [il, s'l_lift, hp, total_space.proj, mfld_simps]\\n /- Third step: check that the composition of all the maps indeed coincides with the derivative we\\n are looking for -/\\n have eq_comp :\\n \\u2200 q \\u2208 s'_lift,\\n tangentMapWithin I I' f s q =\\n (Dr.symm \\u2218 ir \\u2218 tangentMapWithin I I' (r \\u2218 f \\u2218 l.symm) s'l \\u2218 il.symm \\u2218 Dl) q :=\\n by\\n intro q hq\\n simp only [s'_lift, mfld_simps] at hq\\n have U'q : UniqueMdiffWithinAt I s' q.1 := by\\n apply U'\\n simp only [hq, s', mfld_simps]\\n have U'lq : UniqueMdiffWithinAt I s'l (Dl q).1 :=\\n by\\n apply U'l\\n simp only [hq, s'l, mfld_simps]\\n have A :\\n tangentMapWithin I I' ((r \\u2218 f) \\u2218 l.symm) s'l (il.symm (Dl q)) =\\n tangentMapWithin I I' (r \\u2218 f) s' (tangentMapWithin I I l.symm s'l (il.symm (Dl q))) :=\\n by\\n refine' tangentMapWithin_comp_at (il.symm (Dl q)) _ _ (fun p hp => _) U'lq\\n \\u00b7 apply diff_rf.mdifferentiable_on one_le_n\\n simp only [hq, mfld_simps]\\n \\u00b7 apply diff_l.mdifferentiable_on one_le_n\\n simp only [s'l, hq, mfld_simps]\\n \\u00b7 simp only [mfld_simps] at hp\\n simp only [hp, mfld_simps]\\n have B : tangentMapWithin I I l.symm s'l (il.symm (Dl q)) = q :=\\n by\\n have :\\n tangentMapWithin I I l.symm s'l (il.symm (Dl q)) = tangentMap I I l.symm (il.symm (Dl q)) :=\\n by\\n refine' tangentMapWithin_eq_tangentMap U'lq _\\n refine' mdifferentiableAt_atlas_symm _ (chart_mem_atlas _ _) _\\n simp only [hq, mfld_simps]\\n rw [this, tangentMap_chart_symm, hDl]\\n \\u00b7 simp only [hq, mfld_simps]\\n have : q \\u2208 (chart_at (ModelProd H E) p).source := by simp only [hq, mfld_simps]\\n exact (chart_at (ModelProd H E) p).left_inv this\\n \\u00b7 simp only [hq, mfld_simps]\\n have C :\\n tangentMapWithin I I' (r \\u2218 f) s' q =\\n tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q) :=\\n by\\n refine' tangentMapWithin_comp_at q _ _ (fun r hr => _) U'q\\n \\u00b7 apply diff_r.mdifferentiable_on one_le_n\\n simp only [hq, mfld_simps]\\n \\u00b7 apply diff_f.mdifferentiable_on one_le_n\\n simp only [hq, mfld_simps]\\n \\u00b7 simp only [s', mfld_simps] at hr\\n simp only [hr, mfld_simps]\\n have D :\\n Dr.symm (ir (tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q))) =\\n tangentMapWithin I I' f s' q :=\\n by\\n have A :\\n tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q) =\\n tangentMap I' I' r (tangentMapWithin I I' f s' q) :=\\n by\\n apply tangentMapWithin_eq_tangentMap\\n \\u00b7 apply IsOpen.uniqueMdiffWithinAt _ r.open_source\\n simp [hq]\\n \\u00b7 refine' mdifferentiableAt_atlas _ (chart_mem_atlas _ _) _\\n simp only [hq, mfld_simps]\\n have : f p.proj = (tangentMapWithin I I' f s p).1 := rfl\\n rw [A]\\n dsimp [r, Dr]\\n rw [this, tangentMap_chart]\\n \\u00b7 simp only [hq, mfld_simps]\\n have :\\n tangentMapWithin I I' f s' q \\u2208\\n (chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)).source :=\\n by simp only [hq, mfld_simps]\\n exact (chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)).left_inv this\\n \\u00b7 simp only [hq, mfld_simps]\\n have E : tangentMapWithin I I' f s' q = tangentMapWithin I I' f s q :=\\n by\\n refine' tangentMapWithin_subset (by mfld_set_tac) U'q _\\n apply hf.mdifferentiable_on one_le_n\\n simp only [hq, mfld_simps]\\n simp only [(\\u00b7 \\u2218 \\u00b7), A, B, C, D, E.symm]\\n exact diff_DrirrflilDl.congr eq_comp\\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within ContMdiffOn.contMdiffOn_tangentMapWithin\\n\\n/-- If a function is `C^n` on a domain with unique derivatives, with `1 \\u2264 n`, then its bundled\\nderivative is continuous there. -/\\ntheorem ContMdiffOn.continuousOn_tangentMapWithin (hf : ContMdiffOn I I' n f s) (hmn : 1 \\u2264 n)\\n (hs : UniqueMdiffOn I s) :\\n ContinuousOn (tangentMapWithin I I' f s) (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) :=\\n haveI :\\n ContMdiffOn I.tangent I'.tangent 0 (tangentMapWithin I I' f s) (\\u03c0 (TangentSpace I) \\u207b\\u00b9' s) :=\\n hf.cont_mdiff_on_tangent_map_within hmn hs\\n this.continuous_on\\n#align cont_mdiff_on.continuous_on_tangent_map_within ContMdiffOn.continuousOn_tangentMapWithin\\n\\n/-- If a function is `C^n`, then its bundled derivative is `C^m` when `m+1 \\u2264 n`. -/\\ntheorem ContMdiff.contMdiff_tangentMap (hf : ContMdiff I I' n f) (hmn : m + 1 \\u2264 n) :\\n ContMdiff I.tangent I'.tangent m (tangentMap I I' f) :=\\n by\\n rw [\\u2190 contMdiffOn_univ] at hf\\u22a2\\n convert hf.cont_mdiff_on_tangent_map_within hmn uniqueMdiffOn_univ\\n rw [tangentMapWithin_univ]\\n#align cont_mdiff.cont_mdiff_tangent_map ContMdiff.contMdiff_tangentMap\\n\\n/-- If a function is `C^n`, with `1 \\u2264 n`, then its bundled derivative is continuous. -/\\ntheorem ContMdiff.continuous_tangentMap (hf : ContMdiff I I' n f) (hmn : 1 \\u2264 n) :\\n Continuous (tangentMap I I' f) :=\\n by\\n rw [\\u2190 contMdiffOn_univ] at hf\\n rw [continuous_iff_continuousOn_univ]\\n convert hf.continuous_on_tangent_map_within hmn uniqueMdiffOn_univ\\n rw [tangentMapWithin_univ]\\n#align cont_mdiff.continuous_tangent_map ContMdiff.continuous_tangentMap\\n\\nend tangentMap\\n\\nnamespace TangentBundle\\n\\ninclude Is\\n\\nvariable (I M)\\n\\nopen Bundle\\n\\n/-- The derivative of the zero section of the tangent bundle maps `\\u27e8x, v\\u27e9` to `\\u27e8\\u27e8x, 0\\u27e9, \\u27e8v, 0\\u27e9\\u27e9`.\\n\\nNote that, as currently framed, this is a statement in coordinates, thus reliant on the choice\\nof the coordinate system we use on the tangent bundle.\\n\\nHowever, the result itself is coordinate-dependent only to the extent that the coordinates\\ndetermine a splitting of the tangent bundle. Moreover, there is a canonical splitting at each\\npoint of the zero section (since there is a canonical horizontal space there, the tangent space\\nto the zero section, in addition to the canonical vertical space which is the kernel of the\\nderivative of the projection), and this canonical splitting is also the one that comes from the\\ncoordinates on the tangent bundle in our definitions. So this statement is not as crazy as it\\nmay seem.\\n\\nTODO define splittings of vector bundles; state this result invariantly. -/\\ntheorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :\\n tangentMap I I.tangent (zeroSection (TangentSpace I)) p = \\u27e8\\u27e8p.proj, 0\\u27e9, \\u27e8p.2, 0\\u27e9\\u27e9 :=\\n by\\n rcases p with \\u27e8x, v\\u27e9\\n have N : I.symm \\u207b\\u00b9' (chart_at H x).target \\u2208 \\ud835\\udcdd (I ((chart_at H x) x)) :=\\n by\\n apply IsOpen.mem_nhds\\n apply (LocalHomeomorph.open_target _).Preimage I.continuous_inv_fun\\n simp only [mfld_simps]\\n have A : MdifferentiableAt I I.tangent (fun x => @total_space_mk M (TangentSpace I) x 0) x :=\\n haveI : Smooth I (I.prod \\ud835\\udcd8(\\ud835\\udd5c, E)) (zero_section (TangentSpace I : M \\u2192 Type _)) :=\\n Bundle.smooth_zeroSection \\ud835\\udd5c (TangentSpace I : M \\u2192 Type _)\\n this.mdifferentiable_at\\n have B :\\n fderivWithin \\ud835\\udd5c (fun x' : E => (x', (0 : E))) (Set.range \\u21d1I) (I ((chart_at H x) x)) v = (v, 0) :=\\n by\\n rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]\\n \\u00b7 simp\\n \\u00b7 exact differentiableAt_id'\\n \\u00b7 exact differentiableAt_const _\\n \\u00b7 exact ModelWithCorners.unique_diff_at_image I\\n \\u00b7 exact differentiable_at_id'.prod (differentiableAt_const _)\\n simp only [Bundle.zeroSection, tangentMap, mfderiv, total_space.proj_mk, A, if_pos, chart_at,\\n FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply, tangentBundleCore,\\n Function.comp, ContinuousLinearMap.map_zero, mfld_simps]\\n rw [\\u2190 fderivWithin_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _))] at B\\n rw [\\u2190 fderivWithin_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _)), \\u2190 B]\\n congr 2\\n apply fderivWithin_congr _ fun y hy => _\\n \\u00b7 simp only [Prod.mk.inj_iff, mfld_simps]\\n \\u00b7 apply UniqueDiffWithinAt.inter (I.unique_diff _ _) N\\n simp only [mfld_simps]\\n \\u00b7 simp only [mfld_simps] at hy\\n simp only [hy, Prod.mk.inj_iff, mfld_simps]\\n#align tangent_bundle.tangent_map_tangent_bundle_pure TangentBundle.tangentMap_tangentBundle_pure\\n\\nend TangentBundle\\n\\n\"} {\"text\": \"\\n#include(\\\"testS2Cell.jl\\\")\\ninclude(\\\"testS1Angle.jl\\\")\\ninclude(\\\"testS1ChordAngle.jl\\\")\\ninclude(\\\"testS2Point.jl\\\")\\n\\n\"} {\"text\": \"[STATEMENT]\\nlemma af\\\\<^sub>G_eval\\\\<^sub>G:\\n \\\"Only_G \\\\<G> \\\\<Longrightarrow> \\\\<G> \\\\<Turnstile>\\\\<^sub>P af\\\\<^sub>G (eval\\\\<^sub>G \\\\<G> \\\\<phi>) w \\\\<longleftrightarrow> \\\\<G> \\\\<Turnstile>\\\\<^sub>P eval\\\\<^sub>G \\\\<G> (af\\\\<^sub>G \\\\<phi> w)\\\"\\n[PROOF STATE]\\nproof (prove)\\ngoal (1 subgoal):\\n 1. Only_G \\\\<G> \\\\<Longrightarrow> \\\\<G> \\\\<Turnstile>\\\\<^sub>P af\\\\<^sub>G (eval\\\\<^sub>G \\\\<G> \\\\<phi>) w = \\\\<G> \\\\<Turnstile>\\\\<^sub>P eval\\\\<^sub>G \\\\<G> (af\\\\<^sub>G \\\\<phi> w)\\n[PROOF STEP]\\nby (induction \\\\<phi>) (simp_all add: eval\\\\<^sub>G_prop_entailment af\\\\<^sub>G_decompose)\"} {\"text\": \"open classical\\n\\nvariable p: Prop \\n#check em p \\n\\ntheorem dne {p: Prop} (h: \\u00ac \\u00ac p) : p :=\\n (em p).elim \\n (assume hp: p, hp)\\n (assume hnp: \\u00ac p, absurd hnp h)\\n \\n#check by_cases\\n\"} {\"text\": \"abbrev M := ExceptT String $ StateT Nat Id\\n\\ndef add (n : Nat) : M Unit :=\\n modify (\\u00b7 + 0)\\n\\n@[simp] theorem addZero : add (natLit! 0) = pure () :=\\n rfl\\n\\nsyntax \\\"bigAdd0Seq! \\\" num : term\\n\\nmacro_rules\\n | `(bigAdd0Seq! $n) =>\\n let n := n.toNat\\n if n == 0 then\\n `(pure ())\\n else\\n `(add (natLit! 0) >>= fun _ => bigAdd0Seq! $(Lean.quote (n - 1)))\\n\\nset_option maxRecDepth 10000\\n\\ntheorem ex : bigAdd0Seq! 10 = pure () := by\\n simp\\n\\n-- set_option pp.explicit true\\n-- set_option pp.notation false\\n-- #print ex\\n\"} {\"text\": \"import topology.basic\\nimport algebra.module.basic\\nimport algebra.module.submodule\\n\\nimport analysis.normed_space.basic\\n\\n-- Montrer que si un sous-espace vectoriel F d'un espace norm\\u00e9 E est ouvert alors F = E .\\n\\ntheorem exo {R E: Type*} [normed_field R] [normed_group E] [normed_space R E] (F: subspace R E):\\n is_open F.carrier -> forall x: E, set.mem x F\\n:= sorry\\n\"} {\"text\": \"module Test.Extra.ListTest\\n\\nimport IdrTest.Test\\nimport IdrTest.Expectation\\n\\nimport Extra.List\\n\\nexport\\nsuite : Test\\nsuite =\\n describe \\\"List Extra Tests\\\" [\\n describe \\\"Length\\\" [\\n test \\\"Populated List\\\" (\\\\_ => assertEq\\n (length [1,2,3])\\n 3\\n ),\\n test \\\"Empty\\\" (\\\\_ => assertEq\\n (length (the (List Int) []))\\n 0\\n )\\n ],\\n describe \\\"Range\\\" [\\n test \\\"Simple Range\\\" (\\\\_ => assertEq\\n (range 5)\\n [0,1,2,3,4]\\n ),\\n test \\\"Empty Range\\\" (\\\\_ => assertEq\\n (range 0)\\n []\\n )\\n ],\\n describe \\\"Zip with Index\\\" [\\n test \\\"Simple List\\\" (\\\\_ => assertEq\\n (zipWithIndex ['a', 'b', 'c', 'd'])\\n [('a', 0), ('b', 1), ('c', 2), ('d', 3)]\\n ),\\n test \\\"Empty List\\\" (\\\\_ => assertEq\\n (zipWithIndex (the (List Int) []))\\n []\\n )\\n ],\\n describe \\\"Find all\\\" [\\n test \\\"Find all simple\\\" (\\\\_ => assertEq\\n (findAll (unpack \\\"abcbcd\\\") (unpack \\\"bc\\\"))\\n ([1, 3])\\n )\\n ],\\n describe \\\"Replace\\\" [\\n test \\\"Replace simple\\\" (\\\\_ => assertEq\\n (replace (unpack \\\"abcbcd\\\") (unpack \\\"bc\\\") (unpack \\\"zzz\\\"))\\n (unpack \\\"azzzzzzd\\\")\\n )\\n ]\\n ]\\n\"} {\"text\": \"\\nimport data.finsupp.basic\\n\\nsection\\n\\n\\n/-- An inductive type from which to index the variables of the multi-variable polynomials the proof manages -/\\n@[derive decidable_eq]\\ninductive vars : Type\\n| r_v : vars\\n| r_w : vars\\n| \\u03b1_v : vars\\n| \\u03b1_w : vars\\n| \\u03b1_y : vars\\n| \\u03b2 : vars\\n| \\u03b3 : vars\\n\\nlemma finsupp_vars_eq_ext (f g : vars \\u2192\\u2080 \\u2115) : f = g \\u2194 \\n f vars.r_v = g vars.r_v \\n \\u2227 f vars.r_w = g vars.r_w\\n \\u2227 f vars.\\u03b1_v = g vars.\\u03b1_v\\n \\u2227 f vars.\\u03b1_w = g vars.\\u03b1_w\\n \\u2227 f vars.\\u03b1_y = g vars.\\u03b1_y\\n \\u2227 f vars.\\u03b2 = g vars.\\u03b2\\n \\u2227 f vars.\\u03b3 = g vars.\\u03b3 :=\\nbegin\\n rw finsupp.ext_iff,\\n split,\\n {\\n intro h,\\n split, exact h vars.r_v,\\n split, exact h vars.r_w,\\n split, exact h vars.\\u03b1_v,\\n split, exact h vars.\\u03b1_w,\\n split, exact h vars.\\u03b1_y,\\n split, exact h vars.\\u03b2,\\n exact h vars.\\u03b3,\\n },\\n {\\n intro h,\\n intro a,\\n induction a,\\n finish,\\n finish,\\n finish,\\n finish,\\n finish,\\n finish,\\n finish,\\n },\\n -- induction,\\nend\\n\\nend\"} {\"text\": \"import data.finset\\n\\n-- Formula for the Number of Combinations\\n\\nopen finset\\n\\ntheorem t058 {\\u03b1} : \\u03a0 (n : \\u2115) (s : finset \\u03b1),\\n card (powerset_len n s) = nat.choose (card s) n\\n:= finset.card_powerset_len\\n\"} {\"text\": \"using Dates\\n\\nout_dir() = mkpath(normpath(joinpath(@__FILE__, \\\"..\\\", \\\"..\\\", \\\"..\\\", \\\"out\\\")))\\n\\nsnapshot_name(time::DateTime, step::Int) = \\\"bert-abs-$(Dates.format(time, \\\"yyyy-mm-dd-HH:MM\\\"))-step-$(string(step, pad=6))\\\"\\n\\nsnapshot_file(time::DateTime, step::Int, name::String) = joinpath(out_dir(), \\\"$(snapshot_name(time, step))-$name\\\")\\n\\nfunction snapshot_files(time::DateTime, inc_steps::Int, name::String)::Tuple{Vector{String}, Int}\\n step = inc_steps\\n files = []\\n push!(files, snapshot_file(time, step, name))\\n while isfile(files[end])\\n step += inc_steps\\n push!(files, snapshot_file(time, step, name))\\n end\\n return files[1:end-1], step - inc_steps\\nend\\n\"} {\"text\": \"! RUN: %f18 -fopenacc -funparse %s | FileCheck %s\\n\\n! Test unparse does not crash with OpenACC directives.\\n\\n! Test bug 47659\\nprogram bug47659\\n integer :: i, j\\n label1: do i = 1, 10\\n !$acc parallel loop\\n do j = 1, 10\\n if (j == 2) then\\n exit label1\\n end if\\n end do\\n end do label1\\nend program\\n\\n!CHECK-LABEL: PROGRAM bug47659\\n!CHECK: !$ACC PARALLEL LOOP\\n\"} {\"text\": \"\\ndata Nat : Set where\\n zero : Nat\\n suc : Nat \\u2192 Nat\\n\\ndata Id (A : Set) : Set where\\n mkId : A \\u2192 Id A\\n\\ndata Monad (M : Set \\u2192 Set) : Set where\\n\\npostulate\\n return : \\u2200 {M} {{Mon : Monad M}} {A} \\u2192 A \\u2192 M A\\n _>>=_ : \\u2200 {M} {{Mon : Monad M}} {A B} \\u2192 M A \\u2192 (A \\u2192 M B) \\u2192 M B\\n State : (S A : Set) \\u2192 Set\\n\\n instance\\n MonadState : \\u2200 {S} \\u2192 Monad (State S)\\n MonadId : Monad Id\\n\\n-- Yields\\n-- _M Nat == State Nat Nat,\\n-- which inert improvement solves by\\n-- _M x := State (_S x) (_A x)\\n-- with _S Nat == Nat\\n-- _A Nat == Nat\\n-- This allows instance search to pick the right instance.\\nrz : State Nat Nat\\nrz = return zero\\n\\npostulate\\n StateT : (S : Set) (M : Set \\u2192 Set) (A : Set) \\u2192 Set\\n\\n instance\\n MonadStateT : \\u2200 {S M} \\u2192 Monad M \\u2192 Monad (StateT S M)\\n\\nstateT\\u2081 : \\u2200 {M} {{Mon : Monad M}} \\u2192 StateT Nat M Nat\\nstateT\\u2081 = return zero\\n\\nstateT\\u2082 : \\u2200 {M} {{Mon : Monad M}} \\u2192 StateT Nat M Nat\\nstateT\\u2082 = return zero >>= \\u03bb n \\u2192 return (suc n)\\n\\npostulate\\n _<$_ : \\u2200 {A B M} {{Mon : Monad M}} \\u2192 A \\u2192 M B \\u2192 M A\\n\\nrecord \\u22a4 : Set where\\n constructor tt\\n\\nfoo : Id \\u22a4\\nfoo = _ <$ return zero\\n\"} {\"text\": \"",
    "formal_statement": "is: lemma closed_empty [continuous_intros, intro, simp]: \\\"closed {}\\\" Informal statement is: The empty set is closed.\"} {\"text\": \"Formal statement is: lemma closure_closure [simp]: \\\"closure (closure S) = closure S\\\" Informal statement is: The closure of the closure of a set is the closure of the set.\"} {\"text\": \" Note \\n\"} {\"text\": \"Require Export P02.\\n\\n(** **** Problem #3 : 2 stars (mult_S_1) *)\\nTheorem mult_S_1 : forall n m : nat,\\n m = S n -> \\n m * (1 + n) = m * m.\\nProof.\\n intros n m.\\n intros K.\\n rewrite -> K.\\n reflexivity.\\nQed.\\n\\n(*-- Check --*)\\n\\nCheck mult_S_1 : forall n m : nat,\\n m = S n -> \\n m * (1 + n) = m * m.\\n\"} {\"text\": \"/-\\nCopyright (c) 2023 Mar\\u00eda In\\u00e9s de Frutos-Fern\\u00e1ndez. All rights reserved.\\nReleased under Apache 2.0 license as described in the file LICENSE.\\nAuthor : Mar\\u00eda In\\u00e9s de Frutos-Fern\\u00e1ndez\\n-/\\n\\nimport order.filter.basic\\n\\n/-!\\n# Filtros\\nLa definici\\u00f3n de `filtro` en Lean es la siguiente:\\n\\nstructure filter (\\u03b1 : Type*)"
  },
  {
    "informal_statement": "For all odd $n$ show that $8 \\\\mid n^{2}-1$.",
    "formal_statement": "theorem exercise_1_27 {n : \\u2115} (hn : odd n) : 8 \\u2223 (n^2 - 1) :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\\\bar{V}$ is compact and $\\\\bar{V} \\\\subset U$.",
    "formal_statement": "theorem exercise_29_10 {X : Type*}\\n [topological_space X] [t2_space X] (x : X)\\n (hx : \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 (\\u2203 K : set X, U \\u2282 K \\u2227 is_compact K))\\n (U : set X) (hU : is_open U) (hxU : x \\u2208 U) :\\n \\u2203 (V : set X), is_open V \\u2227 x \\u2208 V \\u2227 is_compact (closure V) \\u2227 closure V \\u2286 U :=\"}"
  },
  {
    "informal_statement": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\\\{z \\\\in \\\\mathbb{C}:|z| \\\\leq 1\\\\}$.",
    "formal_statement": "theorem exercise_2018_b2 (n : \\u2115) (hn : n > 0) (f : \\u2115 \\u2192 \\u2102 \\u2192 \\u2102) \\n (hf : \\u2200 n : \\u2115, f n = \\u03bb z, (\\u2211 (i : fin n), (n-i)* z^(i : \\u2115))) : \\n \\u00ac (\\u2203 z : \\u2102, \\u2016z\\u2016 \\u2264 1 \\u2227 f n z = 0) :=\"}"
  },
  {
    "informal_statement": "Show that a group of order 5 must be abelian.",
    "formal_statement": "theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\\n (hG : card G = 5) :\\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "formal_statement": "theorem exercise_25_4 {X : Type*} [topological_space X]\\n [loc_path_connected_space X] (U : set X) (hU : is_open U)\\n (hcU : is_connected U) : is_path_connected U :=\"}"
  },
  {
    "informal_statement": "If $z$ is a complex number, prove that there exists an $r\\\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "formal_statement": "theorem exercise_1_11a (z : \\u2102) : \\n \\u2203 (r : \\u211d) (w : \\u2102), abs w = 1 \\u2227 z = r * w :=\"}"
  },
  {
    "informal_statement": "Suppose $V$ is a complex inner-product space and $T \\\\in \\\\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "formal_statement": "theorem exercise_7_10 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\\n is_self_adjoint T \\u2227 T^2 = T :=\"}"
  },
  {
    "informal_statement": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\\\equiv 1(p q)$.",
    "formal_statement": "theorem exercise_3_14 {p q n : \\u2115} (hp0 : p.prime \\u2227 p > 2) \\n (hq0 : q.prime \\u2227 q > 2) (hpq0 : p \\u2260 q) (hpq1 : p - 1 \\u2223 q - 1)\\n (hn : n.gcd (p*q) = 1) : \\n n^(q-1) \\u2261 1 [MOD p*q] :=\"}"
  },
  {
    "informal_statement": "Prove that $(x, y)$ is not a principal ideal in $\\\\mathbb{Q}[x, y]$.",
    "formal_statement": "theorem exercise_9_3_2 {f g : polynomial \\u211a} (i j : \\u2115)\\n (hfg : \\u2200 n : \\u2115, \\u2203 a : \\u2124, (f*g).coeff = a) :\\n \\u2203 a : \\u2124, f.coeff i * g.coeff j = a :=\"}"
  },
  {
    "informal_statement": "Let $\\\\left\\\\{A_{n}\\\\right\\\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\\\cap A_{n+1} \\\\neq \\\\varnothing$ for all $n$. Show that $\\\\bigcup A_{n}$ is connected.",
    "formal_statement": "theorem exercise_23_2 {X : Type*}\\n [topological_space X] {A : \\u2115 \\u2192 set X} (hA : \\u2200 n, is_connected (A n))\\n (hAn : \\u2200 n, A n \\u2229 A (n + 1) \\u2260 \\u2205) :\\n is_connected (\\u22c3 n, A n) :=\"}"
  },
  {
    "informal_statement": "If $G$ is a nonabelian group of order 6, prove that $G \\\\simeq S_3$.",
    "formal_statement": "theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\\n (hG : card G = 6) (hG' : is_empty (comm_group G)) :\\n G \\u2243* equiv.perm (fin 3) :=\"}"
  },
  {
    "informal_statement": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "formal_statement": "theorem exercise_2_27a (k : \\u2115) (E P : set (euclidean_space \\u211d (fin k)))\\n (hE : E.nonempty \\u2227 \\u00ac set.countable E)\\n (hP : P = {x | \\u2200 U \\u2208 \\ud835\\udcdd x, \\u00ac set.countable (P \\u2229 E)}) :\\n is_closed P \\u2227 P = {x | cluster_pt x (\\ud835\\udcdf P)} :=\"}"
  },
  {
    "informal_statement": "Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "formal_statement": "theorem exercise_2_27a (k : \\u2115) (E P : set (euclidean_space \\u211d (fin k)))\\n (hE : E.nonempty \\u2227 \\u00ac set.countable E)\\n (hP : P = {x | \\u2200 U \\u2208 \\ud835\\udcdd x, \\u00ac set.countable (P \\u2229 E)}) :\\n is_closed P \\u2227 P = {x | cluster_pt x (\\ud835\\udcdf P)} :=\"}"
  },
  {
    "informal_statement": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "formal_statement": "theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\\n [module K V] {S : set V} (hS : set.countable S)\\n (hS1 : span K S = \\u22a4) {\\u03b9 : Type*} (R : \\u03b9 \\u2192 V)\\n (hR : linear_independent K R) : countable \\u03b9 :=\"}"
  },
  {
    "informal_statement": "Show that the rationals $\\\\mathbb{Q}$ are not locally compact.",
    "formal_statement": "theorem exercise_29_10 {X : Type*}\\n [topological_space X] [t2_space X] (x : X)\\n (hx : \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 (\\u2203 K : set X, U \\u2282 K \\u2227 is_compact K))\\n (U : set X) (hU : is_open U) (hxU : x \\u2208 U) :\\n \\u2203 (V : set X), is_open V \\u2227 x \\u2208 V \\u2227 is_compact (closure V) \\u2227 closure V \\u2286 U :=\"}"
  },
  {
    "informal_statement": "Prove that if $G$ is an abelian simple group then $G \\\\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "formal_statement": "theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\\n is_cyclic G \\u2227 \\u2203 G_fin : fintype G, nat.prime (@card G G_fin) :=\"}"
  },
  {
    "informal_statement": "Prove that the power series $\\\\sum zn/n^2$ converges at every point of the unit circle.",
    "formal_statement": "theorem exercise_1_19b (z : \\u2102) (hz : abs z = 1) (s : \\u2115 \\u2192 \\u2102)\\n (h : s = (\\u03bb n, \\u2211 i in (finset.range n), i * z / i ^ 2)) :\\n \\u2203 y, tendsto s at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "formal_statement": "theorem exercise_18_4 {n : \\u2115} (hn : \\u2203 x y z w : \\u2124, \\n x^3 + y^3 = n \\u2227 z^3 + w^3 = n \\u2227 x \\u2260 z \\u2227 x \\u2260 w \\u2227 y \\u2260 z \\u2227 y \\u2260 w) : \\n n \\u2265 1729 :=\"}"
  },
  {
    "informal_statement": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\\n (hG : card G = 1365) : \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "Define $f_{n}:[0,1] \\\\rightarrow \\\\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\\\left(f_{n}(x)\\\\right)$ converges for each $x \\\\in[0,1]$.",
    "formal_statement": "theorem exercise_21_6a\\n (f : \\u2115 \\u2192 I \\u2192 \\u211d )\\n (h : \\u2200 x n, f n x = x ^ n) :\\n \\u2200 x, \\u2203 y, tendsto (\\u03bb n, f n x) at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "formal_statement": "theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \\n (hG : card G = 200) : \\n \\u2203 N : sylow 5 G, N.normal :=\"}"
  },
  {
    "informal_statement": "Prove that if $|G|=132$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\\n (hG : card G = 132) : \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "Let $R$ be the ring of $2 \\\\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "formal_statement": "theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \\u211d)) : \\n I = \\u22a5 \\u2228 I = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "formal_statement": "theorem exercise_30_13 {X : Type*} [topological_space X]\\n (h : \\u2203 (s : set X), countable s \\u2227 dense s) (U : set (set X))\\n (hU : \\u2200 (x y : set X), x \\u2208 U \\u2192 y \\u2208 U \\u2192 x \\u2260 y \\u2192 x \\u2229 y = \\u2205) :\\n countable U :=\"}"
  },
  {
    "informal_statement": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-\\u010cech compactification of $X$ is connected.",
    "formal_statement": "theorem exercise_38_6 {X : Type*}\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0}) :\\n is_connected (univ : set X) \\u2194 is_connected (univ : set (stone_cech X)) :=\"}"
  },
  {
    "informal_statement": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "formal_statement": "theorem exercise_4_5 {p t : \\u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\\n (a : zmod p) :\\n is_primitive_root a p \\u2194 ((-a) ^ ((p-1)/2) = 1 \\u2227 \\u2200 (k : \\u2115), k < (p-1)/2 \\u2192 (-a)^k \\u2260 1) :=\"}"
  },
  {
    "informal_statement": "Suppose that $|G| = pm$, where $p \\\\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "formal_statement": "theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\\n {p m : \\u2115} (hp : nat.prime p) (hp1 : \\u00ac p \\u2223 m) (hG : card G = p*m) \\n {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\\n characteristic H :=\"}"
  },
  {
    "informal_statement": "Suppose that $|G| = pm$, where $p \\\\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "formal_statement": "theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\\n (hG : card G = 6) (hG' : is_empty (comm_group G)) :\\n G \\u2243* equiv.perm (fin 3) :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2d {p : \\u2115} (hp : p.prime \\u2227 p > 2) \\n {f : polynomial \\u2124} (hf : f = (X + 2)^p): \\n irreducible (\\u2211 n in (f.support \\\\ {0}), (f.coeff n) * X ^ (n-1) : \\n polynomial \\u2124) :=\"}"
  },
  {
    "informal_statement": "Suppose $a, b \\\\in R^k$. Find $c \\\\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "formal_statement": "theorem exercise_1_19\\n (n : \\u2115)\\n (a b c x : euclidean_space \\u211d (fin n))\\n (r : \\u211d)\\n (h\\u2081 : r > 0)\\n (h\\u2082 : 3 \\u2022 c = 4 \\u2022 b - a)\\n (h\\u2083 : 3 * r = 2 * \\u2016x - b\\u2016)\\n : \\u2016x - a\\u2016 = 2 * \\u2016x - b\\u2016 \\u2194 \\u2016x - c\\u2016 = r :=\"}"
  },
  {
    "informal_statement": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "formal_statement": "theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \\n (hG : card G > 2) (H : subgroup G) [fintype H] : \\n card H \\u2260 card G - 1 :=\"}"
  },
  {
    "informal_statement": "Prove that $-(-v) = v$ for every $v \\\\in V$.",
    "formal_statement": "theorem exercise_1_3 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {v : V} : -(-v) = v :=\"}"
  },
  {
    "informal_statement": "Show that a closed subspace of a normal space is normal.",
    "formal_statement": "theorem exercise_32_2b\\n {\\u03b9 : Type*} {X : \\u03b9 \\u2192 Type*} [\\u2200 i, topological_space (X i)]\\n (h : \\u2200 i, nonempty (X i)) (h2 : regular_space (\\u03a0 i, X i)) :\\n \\u2200 i, regular_space (X i) :=\"}"
  },
  {
    "informal_statement": "If $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "formal_statement": "theorem exercise_1_1a\\n (x : \\u211d) (y : \\u211a) :\\n ( irrational x ) -> irrational ( x + y ) :=\"}"
  },
  {
    "informal_statement": "Show that a closed subspace of a normal space is normal.",
    "formal_statement": "theorem exercise_32_1 {X : Type*} [topological_space X]\\n (hX : normal_space X) (A : set X) (hA : is_closed A) :\\n normal_space {x // x \\u2208 A} :=\"}"
  },
  {
    "informal_statement": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "formal_statement": "theorem exercise_10_7_10 {R : Type*} [ring R]\\n (M : ideal R) (hM : \\u2200 (x : R), x \\u2209 M \\u2192 is_unit x) :\\n is_maximal M \\u2227 \\u2200 (N : ideal R), is_maximal N \\u2192 N = M :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathbf{x}_1, \\\\mathbf{x}_2, \\\\ldots$ be a sequence of the points of the product space $\\\\prod X_\\\\alpha$. Show that this sequence converges to the point $\\\\mathbf{x}$ if and only if the sequence $\\\\pi_\\\\alpha(\\\\mathbf{x}_i)$ converges to $\\\\pi_\\\\alpha(\\\\mathbf{x})$ for each $\\\\alpha$.",
    "formal_statement": "theorem exercise_21_6a\\n (f : \\u2115 \\u2192 I \\u2192 \\u211d )\\n (h : \\u2200 x n, f n x = x ^ n) :\\n \\u2200 x, \\u2203 y, tendsto (\\u03bb n, f n x) at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13c {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, abs (f z) = c) :\\n f a = f b :=\"}"
  },
  {
    "informal_statement": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "formal_statement": "theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \\u2115} \\n (hm : \\u2203 (g : G), order_of g = m) \\n (hn : \\u2203 (g : G), order_of g = n) \\n (hmn : m.coprime n) :\\n \\u2203 (g : G), order_of g = m * n :=\"}"
  },
  {
    "informal_statement": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\\n (hG : card G = 132) : \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "If $C_{0}+\\\\frac{C_{1}}{2}+\\\\cdots+\\\\frac{C_{n-1}}{n}+\\\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\\\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "formal_statement": "theorem exercise_5_4 {n : \\u2115}\\n (C : \\u2115 \\u2192 \\u211d)\\n (hC : \\u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\\n \\u2203 x, x \\u2208 (set.Icc (0 : \\u211d) 1) \\u2227 \\u2211 i in finset.range (n + 1), (C i) * (x^i) = 0 :=\"}"
  },
  {
    "informal_statement": "Show that a connected metric space having more than one point is uncountable.",
    "formal_statement": "theorem exercise_27_4\\n {X : Type*} [metric_space X] [connected_space X] (hX : \\u2203 x y : X, x \\u2260 y) :\\n \\u00ac countable (univ : set X) :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "formal_statement": "theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \\n (hG : \\u00ac (card G).prime) (hG1 : \\u2200 k \\u2223 card G, \\n \\u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \\n \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "formal_statement": "theorem exercise_31_2 {X : Type*}\\n [topological_space X] [normal_space X] {A B : set X}\\n (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\\n \\u2203 (U V : set X), is_open U \\u2227 is_open V \\u2227 A \\u2286 U \\u2227 B \\u2286 V \\u2227 closure U \\u2229 closure V = \\u2205 :=\"}"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $\\\\text{Re}(f)$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13a {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, (f z).re = c) :\\n f a = f b :=\"}"
  },
  {
    "informal_statement": "Show that the lower limit topology $\\\\mathbb{R}_l$ and $K$-topology $\\\\mathbb{R}_K$ are not comparable.",
    "formal_statement": "theorem exercise_13_6 :\\n \\u00ac (\\u2200 U, Rl.is_open U \\u2192 K_topology.is_open U) \\u2227 \\u00ac (\\u2200 U, K_topology.is_open U \\u2192 Rl.is_open U) :=\"}"
  },
  {
    "informal_statement": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\\\times Y)-(A \\\\times B)$ is connected.",
    "formal_statement": "theorem exercise_24_2 {f : (metric.sphere 0 1 : set \\u211d) \\u2192 \\u211d}\\n (hf : continuous f) : \\u2203 x, f x = f (-x) :=\"}"
  },
  {
    "informal_statement": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "formal_statement": "theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\\n (h : a * b = b * a) :\\n \\u2200 x y : closure {x | x = a \\u2228 x = b}, x*y = y*x :=\"}"
  },
  {
    "informal_statement": "Show that every locally compact Hausdorff space is regular.",
    "formal_statement": "theorem exercise_32_3 {X : Type*} [topological_space X]\\n (hX : locally_compact_space X) (hX' : t2_space X) :\\n regular_space X :=\"}"
  },
  {
    "informal_statement": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\\\operatorname{dim} V=1$ and $T \\\\in \\\\mathcal{L}(V, V)$, then there exists $a \\\\in \\\\mathbf{F}$ such that $T v=a v$ for all $v \\\\in V$.",
    "formal_statement": "theorem exercise_3_1 {F V : Type*} \\n [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\\n (T : V \\u2192\\u2097[F] V) (hT : finrank F V = 1) :\\n \\u2203 c : F, \\u2200 v : V, T v = c \\u2022 v:=\"}"
  },
  {
    "informal_statement": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\\\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "formal_statement": "theorem exercise_1_6_17 {G : Type*} [group G] (f : G \\u2192 G) \\n (hf : f = \\u03bb g, g\\u207b\\u00b9) :\\n \\u2200 x y : G, f x * f y = f (x*y) \\u2194 \\u2200 x y : G, x*y = y*x :=\"}"
  },
  {
    "informal_statement": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "formal_statement": "theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {\\u03b9 : Type*} (u : \\u03b9 \\u2192 submodule F V) :\\n \\u2203 U : submodule F V, (\\u22c2 (i : \\u03b9), (u i).carrier) = \\u2191U :=\"}"
  },
  {
    "informal_statement": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "formal_statement": "theorem exercise_1_13a {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, (f z).re = c) :\\n f a = f b :=\"}"
  },
  {
    "informal_statement": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "formal_statement": "theorem exercise_17_4 {X : Type*} [topological_space X]\\n (U A : set X) (hU : is_open U) (hA : is_closed A) :\\n is_open (U \\\\ A) \\u2227 is_closed (A \\\\ U) :=\"}"
  },
  {
    "informal_statement": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "formal_statement": "theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\\n (A : set X) (hA : is_closed A) :\\n \\u2203 P\\u2081 P\\u2082 : set X, A = P\\u2081 \\u222a P\\u2082 \\u2227\\n is_closed P\\u2081 \\u2227 P\\u2081 = {x | cluster_pt x (\\ud835\\udcdf P\\u2081)} \\u2227\\n set.countable P\\u2082 :=\"}"
  },
  {
    "informal_statement": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "formal_statement": "theorem exercise_4_19\\n {f : \\u211d \\u2192 \\u211d} (hf : \\u2200 a b c, a < b \\u2192 f a < c \\u2192 c < f b \\u2192 \\u2203 x, a < x \\u2227 x < b \\u2227 f x = c)\\n (hg : \\u2200 r : \\u211a, is_closed {x | f x = r}) : continuous f :=\"}"
  },
  {
    "informal_statement": "Let $p$ be an odd prime and let $1 + \\\\frac{1}{2} + ... + \\\\frac{1}{p - 1} = \\\\frac{a}{b}$, where $a, b$ are integers. Show that $p \\\\mid a$.",
    "formal_statement": "theorem exercise_4_2_9 {p : \\u2115} (hp : nat.prime p) (hp1 : odd p) :\\n \\u2203 (a b : \\u2124), (a / b : \\u211a) = \\u2211 i in finset.range p, 1 / (i + 1) \\u2192 \\u2191p \\u2223 a :=\"}"
  },
  {
    "informal_statement": "For $j \\\\in\\\\{1,2,3,4\\\\}$, let $z_{j}$ be a complex number with $\\\\left|z_{j}\\\\right|=1$ and $z_{j} \\\\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\\\neq 0 .$",
    "formal_statement": "theorem exercise_2020_b5 (z : fin 4 \\u2192 \\u2102) (hz0 : \\u2200 n, \\u2016z n\\u2016 < 1) \\n (hz1 : \\u2200 n : fin 4, z n \\u2260 1) : \\n 3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \\u2260 0 :=\"}"
  },
  {
    "informal_statement": "Prove that a group of even order contains an element of order $2 .$",
    "formal_statement": "theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\\n [module K V] {S : set V} (hS : set.countable S)\\n (hS1 : span K S = \\u22a4) {\\u03b9 : Type*} (R : \\u03b9 \\u2192 V)\\n (hR : linear_independent K R) : countable \\u03b9 :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\\\in G$. Show that $G$ is abelian.",
    "formal_statement": "theorem exercise_2_2_5 {G : Type*} [group G] \\n (h : \\u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \\u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\\\mathbb{Q}[x]$.",
    "formal_statement": "theorem exercise_13_4_10 \\n {p : \\u2115} {hp : nat.prime p} (h : \\u2203 r : \\u2115, p = 2 ^ r + 1) :\\n \\u2203 (k : \\u2115), p = 2 ^ (2 ^ k) + 1 :=\"}"
  },
  {
    "informal_statement": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "formal_statement": "theorem exercise_13_4_10 \\n {p : \\u2115} {hp : nat.prime p} (h : \\u2203 r : \\u2115, p = 2 ^ r + 1) :\\n \\u2203 (k : \\u2115), p = 2 ^ (2 ^ k) + 1 :=\"}"
  },
  {
    "informal_statement": "Give an example of a nonempty subset $U$ of $\\\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\\\in U$ whenever $u \\\\in U$), but $U$ is not a subspace of $\\\\mathbf{R}^2$.",
    "formal_statement": "theorem exercise_1_6 : \\u2203 U : set (\\u211d \\u00d7 \\u211d),\\n (U \\u2260 \\u2205) \\u2227\\n (\\u2200 (u v : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2227 v \\u2208 U \\u2192 u + v \\u2208 U) \\u2227\\n (\\u2200 (u : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2192 -u \\u2208 U) \\u2227\\n (\\u2200 U' : submodule \\u211d (\\u211d \\u00d7 \\u211d), U \\u2260 \\u2191U') :=\"}"
  },
  {
    "informal_statement": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "formal_statement": "theorem exercise_5_2_20 {F V \\u03b9: Type*} [infinite F] [field F] \\n [add_comm_group V] [module F V] {u : \\u03b9 \\u2192 submodule F V} \\n (hu : \\u2200 i : \\u03b9, u i \\u2260 \\u22a4) : \\n (\\u22c3 i : \\u03b9, (u i : set V)) \\u2260 \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "formal_statement": "theorem exercise_2_24 {X : Type*} [metric_space X]\\n (hX : \\u2200 (A : set X), infinite A \\u2192 \\u2203 (x : X), x \\u2208 closure A) :\\n separable_space X :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\sqrt{n+1}-\\\\sqrt{n} \\\\rightarrow 0$ as $n \\\\rightarrow \\\\infty$.",
    "formal_statement": "theorem exercise_3_4 (n : \\u2115) :\\n tendsto (\\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\\ud835\\udcdd 0) :=\"}"
  },
  {
    "informal_statement": "Let $\\\\|\\\\cdot\\\\|$ be any norm on $\\\\mathbb{R}^{m}$ and let $B=\\\\left\\\\{x \\\\in \\\\mathbb{R}^{m}:\\\\|x\\\\| \\\\leq 1\\\\right\\\\}$. Prove that $B$ is compact.",
    "formal_statement": "theorem exercise_2_41 (m : \\u2115) {X : Type*} [normed_space \\u211d ((fin m) \\u2192 \\u211d)] :\\n is_compact (metric.closed_ball 0 1) :=\"}"
  },
  {
    "informal_statement": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "formal_statement": "theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \\u2115}\\n (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\\n is_simple_group G \\u2192 false :=\"}"
  },
  {
    "informal_statement": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\\\left(\\\\frac{x+y}{2}\\\\right) \\\\leq \\\\frac{f(x)+f(y)}{2}$ for all $x, y \\\\in(a, b)$. Prove that $f$ is convex.",
    "formal_statement": "theorem exercise_4_24 {f : \\u211d \\u2192 \\u211d}\\n (hf : continuous f) (a b : \\u211d) (hab : a < b)\\n (h : \\u2200 x y : \\u211d, a < x \\u2192 x < b \\u2192 a < y \\u2192 y < b \\u2192 f ((x + y) / 2) \\u2264 (f x + f y) / 2) :\\n convex_on \\u211d (set.Ioo a b) f :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "formal_statement": "theorem exercise_31_2 {X : Type*}\\n [topological_space X] [normal_space X] {A B : set X}\\n (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\\n \\u2203 (U V : set X), is_open U \\u2227 is_open V \\u2227 A \\u2286 U \\u2227 B \\u2286 V \\u2227 closure U \\u2229 closure V = \\u2205 :=\"}"
  },
  {
    "informal_statement": "Prove that in the ring $\\\\mathbb{Z}[x],(2) \\\\cap(x)=(2 x)$.",
    "formal_statement": "theorem exercise_10_2_4 :\\n span ({2} : set $ polynomial \\u2124) \\u2293 (span {X}) =\\n span ({2 * X} : set $ polynomial \\u2124) :=\"}"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $\\\\text{Re}(f)$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_13c {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (a b : \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (hc : \\u2203 (c : \\u211d), \\u2200 z \\u2208 \\u03a9, abs (f z) = c) :\\n f a = f b :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\\\sigma \\\\in G$ such that $\\\\sigma(a) \\\\neq a$ for all $a \\\\in A$.",
    "formal_statement": "theorem exercise_4_3_26 {\\u03b1 : Type*} [fintype \\u03b1] (ha : fintype.card \\u03b1 > 1)\\n (h_tran : \\u2200 a b: \\u03b1, \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u03c3 a = b) : \\n \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u2200 a : \\u03b1, \\u03c3 a \\u2260 a :=\"}"
  },
  {
    "informal_statement": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "formal_statement": "theorem exercise_1_1_16 {G : Type*} [group G] \\n (x : G) (hx : x ^ 2 = 1) :\\n order_of x = 1 \\u2228 order_of x = 2 :=\"}"
  },
  {
    "informal_statement": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "formal_statement": "theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\\n (H : I \\u2192 subgroup G) (hH : \\u2200 i : I, subgroup.normal (H i)) : \\n subgroup.normal (\\u2a05 (i : I), H i):=\"}"
  },
  {
    "informal_statement": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\\\cap J$ in $R / I J$ is nilpotent.",
    "formal_statement": "theorem exercise_10_4_6 {R : Type*} [comm_ring R] \\n [no_zero_divisors R] {I J : ideal R} (x : I \\u2293 J) : \\n is_nilpotent ((ideal.quotient.mk (I*J)) x) :=\"}"
  },
  {
    "informal_statement": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\\\geq 1$. Prove that the ideal $p \\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$ is a nilpotent ideal in the ring $\\\\mathbb{Z} / p^{m} \\\\mathbb{Z}$.",
    "formal_statement": "theorem exercise_8_1_12 {N : \\u2115} (hN : N > 0) {M M': \\u2124} {d : \\u2115}\\n (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \\n (hM' : M' \\u2261 M^d [ZMOD N]) : \\n \\u2203 d' : \\u2115, d' * d \\u2261 1 [ZMOD N.totient] \\u2227 \\n M \\u2261 M'^d' [ZMOD N] :=\"}"
  },
  {
    "informal_statement": "If $a > 1$ is an integer, show that $n \\\\mid \\\\varphi(a^n - 1)$, where $\\\\phi$ is the Euler $\\\\varphi$-function.",
    "formal_statement": "theorem exercise_2_4_36 {a n : \\u2115} (h : a > 1) :\\n n \\u2223 (a ^ n - 1).totient :=\"}"
  },
  {
    "informal_statement": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "formal_statement": "theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \\n [group G] [group H] (hG : card G = 21) (hH : card H = 21) \\n (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\\n G \\u2243* H :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\sum 1/k(\\\\log(k))^p$ diverges when $p \\\\leq 1$.",
    "formal_statement": "theorem exercise_3_63b (p : \\u211d) (f : \\u2115 \\u2192 \\u211d) (hp : p \\u2264 1)\\n (h : f = \\u03bb k, (1 : \\u211d) / (k * (log k) ^ p)) :\\n \\u00ac \\u2203 l, tendsto f at_top (\\ud835\\udcdd l) :=\"}"
  },
  {
    "informal_statement": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\\\in R$. Prove that every Boolean ring is commutative.",
    "formal_statement": "theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \\u2200 a : R, a^2 = a) :\\n comm_ring R :=\"}"
  },
  {
    "informal_statement": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\\\perp}=\\\\{0\\\\}$ if and only if $U=V$",
    "formal_statement": "theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\\n {U : submodule K V} : \\n U.orthogonal = \\u22a5 \\u2194 U = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Let $(p_n)$ be a sequence and $f:\\\\mathbb{N}\\\\to\\\\mathbb{N}$. The sequence $(q_k)_{k\\\\in\\\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.",
    "formal_statement": "theorem exercise_2_12a (f : \\u2115 \\u2192 \\u2115) (p : \\u2115 \\u2192 \\u211d) (a : \\u211d)\\n (hf : injective f) (hp : tendsto p at_top (\\ud835\\udcdd a)) :\\n tendsto (\\u03bb n, p (f n)) at_top (\\ud835\\udcdd a) :=\"}"
  },
  {
    "informal_statement": "Let $p$ be an odd prime and let $1 + \\\\frac{1}{2} + ... + \\\\frac{1}{p - 1} = \\\\frac{a}{b}$, where $a, b$ are integers. Show that $p \\\\mid a$.",
    "formal_statement": "theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \\u211d)) : \\n I = \\u22a5 \\u2228 I = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_5_2_20 {F V \\u03b9: Type*} [infinite F] [field F] \\n [add_comm_group V] [module F V] {u : \\u03b9 \\u2192 submodule F V} \\n (hu : \\u2200 i : \\u03b9, u i \\u2260 \\u22a4) : \\n (\\u22c3 i : \\u03b9, (u i : set V)) \\u2260 \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "formal_statement": "theorem exercise_3_1a\\n (f : \\u2115 \\u2192 \\u211d)\\n (h : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), f n) at_top (\\ud835\\udcdd a))\\n : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), |f n|) at_top (\\ud835\\udcdd a) :=\"}"
  },
  {
    "informal_statement": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\\\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "formal_statement": "theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \\n [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\\n is_cyclic (G \\u00d7 H) \\u2194 (card G).coprime (card H) :=\"}"
  },
  {
    "informal_statement": "Show that if $a$ is negative then $p \\\\equiv q(4 a) together with p\\\\not | a$ imply $(a / p)=(a / q)$.",
    "formal_statement": "theorem exercise_5_37 {p q : \\u2115} [fact(p.prime)] [fact(q.prime)] {a : \\u2124}\\n (ha : a < 0) (h0 : p \\u2261 q [ZMOD 4*a]) (h1 : \\u00ac ((p : \\u2124) \\u2223 a)) :\\n legendre_sym p a = legendre_sym q a :=\"}"
  },
  {
    "informal_statement": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "formal_statement": "theorem exercise_4_8 {p a : \\u2115} (hp : odd p) : \\n is_primitive_root a p \\u2194 (\\u2200 q \\u2223 (p-1), q.prime \\u2192 \\u00ac a^(p-1) \\u2261 1 [MOD p]) :=\"}"
  },
  {
    "informal_statement": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\\\colon X \\\\rightarrow [0, 1]$ such that $f(A) = \\\\{0\\\\}$ and $f(B) = \\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_38_6 {X : Type*}\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0}) :\\n is_connected (univ : set X) \\u2194 is_connected (univ : set (stone_cech X)) :=\"}"
  },
  {
    "informal_statement": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "formal_statement": "theorem exercise_2_12a (f : \\u2115 \\u2192 \\u2115) (p : \\u2115 \\u2192 \\u211d) (a : \\u211d)\\n (hf : injective f) (hp : tendsto p at_top (\\ud835\\udcdd a)) :\\n tendsto (\\u03bb n, p (f n)) at_top (\\ud835\\udcdd a) :=\"}"
  },
  {
    "informal_statement": "Show that $ \\\\int_{-\\\\infty}^{\\\\infty} \\\\frac{\\\\cos x}{x^2 + a^2} dx = \\\\pi \\\\frac{e^{-a}}{a}$ for $a > 0$.",
    "formal_statement": "theorem exercise_3_3 (a : \\u211d) (ha : 0 < a) :\\n tendsto (\\u03bb y, \\u222b x in -y..y, real.cos x / (x ^ 2 + a ^ 2))\\n at_top (\\ud835\\udcdd (real.pi * (real.exp (-a) / a))) :=\"}"
  },
  {
    "informal_statement": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "formal_statement": "theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \\n [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\\n is_cyclic (G \\u00d7 H) \\u2194 (card G).coprime (card H) :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "formal_statement": "theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \\u2115}\\n (hp : nat.prime p) (hG : card G = p^2) :\\n \\u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \\u2227 N.normal :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "formal_statement": "theorem exercise_23_9 {X Y : Type*}\\n [topological_space X] [topological_space Y]\\n (A\\u2081 A\\u2082 : set X)\\n (B\\u2081 B\\u2082 : set Y)\\n (hA : A\\u2081 \\u2282 A\\u2082)\\n (hB : B\\u2081 \\u2282 B\\u2082)\\n (hA : is_connected A\\u2082)\\n (hB : is_connected B\\u2082) :\\n is_connected ({x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2082 \\u2227 b \\u2208 B\\u2082} \\\\\\n {x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2081 \\u2227 b \\u2208 B\\u2081}) :=\"}"
  },
  {
    "informal_statement": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "formal_statement": "theorem exercise_2_4_16b {n : \\u2115} {hn : n \\u2260 0} \\n {R : subgroup (dihedral_group n)} \\n (hR : R = subgroup.closure {dihedral_group.r 1}) : \\n R \\u2260 \\u22a4 \\u2227 \\n \\u2200 K : subgroup (dihedral_group n), R \\u2264 K \\u2192 K = R \\u2228 K = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "formal_statement": "theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\\n (hG : card G = 1365) : \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "Suppose that $f$ is holomorphic in an open set $\\\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "formal_statement": "theorem exercise_1_19b (z : \\u2102) (hz : abs z = 1) (s : \\u2115 \\u2192 \\u2102)\\n (h : s = (\\u03bb n, \\u2211 i in (finset.range n), i * z / i ^ 2)) :\\n \\u2203 y, tendsto s at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Suppose $V$ is a complex inner-product space and $T \\\\in \\\\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "formal_statement": "theorem exercise_7_14 {\\ud835\\udd5c V : Type*} [is_R_or_C \\ud835\\udd5c]\\n [inner_product_space \\ud835\\udd5c V] [finite_dimensional \\ud835\\udd5c V]\\n {T : End \\ud835\\udd5c V} (hT : is_self_adjoint T)\\n {l : \\ud835\\udd5c} {\\u03b5 : \\u211d} (he : \\u03b5 > 0) : \\u2203 v : V, \\u2016v\\u2016= 1 \\u2227 (\\u2016T v - l \\u2022 v\\u2016 < \\u03b5 \\u2192\\n (\\u2203 l' : T.eigenvalues, \\u2016l - l'\\u2016 < \\u03b5)) :=\"}"
  },
  {
    "informal_statement": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "formal_statement": "theorem exercise_4_5_16 {p q r : \\u2115} {G : Type*} [group G] \\n [fintype G] (hpqr : p < q \\u2227 q < r) \\n (hpqr1 : p.prime \\u2227 q.prime \\u2227 r.prime)(hG : card G = p*q*r) : \\n nonempty (sylow p G) \\u2228 nonempty(sylow q G) \\u2228 nonempty(sylow r G) :=\"}"
  },
  {
    "informal_statement": "If $a > 1$ is an integer, show that $n \\\\mid \\\\varphi(a^n - 1)$, where $\\\\phi$ is the Euler $\\\\varphi$-function.",
    "formal_statement": "theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\\n {p m : \\u2115} (hp : nat.prime p) (hp1 : \\u00ac p \\u2223 m) (hG : card G = p*m) \\n {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\\n characteristic H :=\"}"
  },
  {
    "informal_statement": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\\\rightarrow Y$ be continuous. Let $h: X \\\\rightarrow Y$ be the function $h(x)=\\\\min \\\\{f(x), g(x)\\\\}.$ Show that $h$ is continuous.",
    "formal_statement": "theorem exercise_19_6a\\n {n : \\u2115}\\n {f : fin n \\u2192 Type*} {x : \\u2115 \\u2192 \\u03a0a, f a}\\n (y : \\u03a0i, f i)\\n [\\u03a0a, topological_space (f a)] :\\n tendsto x at_top (\\ud835\\udcdd y) \\u2194 \\u2200 i, tendsto (\\u03bb j, (x j) i) at_top (\\ud835\\udcdd (y i)) :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "formal_statement": "theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \\n (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "formal_statement": "theorem exercise_9_3_2 {f g : polynomial \\u211a} (i j : \\u2115)\\n (hfg : \\u2200 n : \\u2115, \\u2203 a : \\u2124, (f*g).coeff = a) :\\n \\u2203 a : \\u2124, f.coeff i * g.coeff j = a :=\"}"
  },
  {
    "informal_statement": "Suppose $f^{\\\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\\\prime}(f(x))=\\\\frac{1}{f^{\\\\prime}(x)} \\\\quad(a<x<b)$.",
    "formal_statement": "theorem exercise_5_2 {a b : \\u211d}\\n {f g : \\u211d \\u2192 \\u211d} (hf : \\u2200 x \\u2208 set.Ioo a b, deriv f x > 0)\\n (hg : g = f\\u207b\\u00b9)\\n (hg_diff : differentiable_on \\u211d g (set.Ioo a b)) :\\n differentiable_on \\u211d g (set.Ioo a b) \\u2227\\n \\u2200 x \\u2208 set.Ioo a b, deriv g x = 1 / deriv f x :=\"}"
  },
  {
    "informal_statement": "Suppose $X$ is a nonempty complete metric space, and $\\\\left\\\\{G_{n}\\\\right\\\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\\\bigcap_{1}^{\\\\infty} G_{n}$ is not empty.",
    "formal_statement": "theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\\n (G : \\u2115 \\u2192 set X) (hG : \\u2200 n, is_open (G n) \\u2227 dense (G n)) :\\n \\u2203 x, \\u2200 n, x \\u2208 G n :=\"}"
  },
  {
    "informal_statement": "Suppose $f^{\\\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\\\prime}(f(x))=\\\\frac{1}{f^{\\\\prime}(x)} \\\\quad(a<x<b)$.",
    "formal_statement": "theorem exercise_5_4 {n : \\u2115}\\n (C : \\u2115 \\u2192 \\u211d)\\n (hC : \\u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\\n \\u2203 x, x \\u2208 (set.Icc (0 : \\u211d) 1) \\u2227 \\u2211 i in finset.range (n + 1), (C i) * (x^i) = 0 :=\"}"
  },
  {
    "informal_statement": "Prove that convergence of $\\\\left\\\\{s_{n}\\\\right\\\\}$ implies convergence of $\\\\left\\\\{\\\\left|s_{n}\\\\right|\\\\right\\\\}$.",
    "formal_statement": "theorem exercise_3_1a\\n (f : \\u2115 \\u2192 \\u211d)\\n (h : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), f n) at_top (\\ud835\\udcdd a))\\n : \\u2203 (a : \\u211d), tendsto (\\u03bb (n : \\u2115), |f n|) at_top (\\ud835\\udcdd a) :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\sqrt{n+1}-\\\\sqrt{n} \\\\rightarrow 0$ as $n \\\\rightarrow \\\\infty$.",
    "formal_statement": "theorem exercise_3_63b (p : \\u211d) (f : \\u2115 \\u2192 \\u211d) (hp : p \\u2264 1)\\n (h : f = \\u03bb k, (1 : \\u211d) / (k * (log k) ^ p)) :\\n \\u00ac \\u2203 l, tendsto f at_top (\\ud835\\udcdd l) :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\\\sigma \\\\in G$ such that $\\\\sigma(a) \\\\neq a$ for all $a \\\\in A$.",
    "formal_statement": "theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \\n (hG : \\u00ac (card G).prime) (hG1 : \\u2200 k \\u2223 card G, \\n \\u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \\n \\u00ac is_simple_group G :=\"}"
  },
  {
    "informal_statement": "Suppose $E\\\\subset\\\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "formal_statement": "theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\\n (A : set X) (hA : is_closed A) :\\n \\u2203 P\\u2081 P\\u2082 : set X, A = P\\u2081 \\u222a P\\u2082 \\u2227\\n is_closed P\\u2081 \\u2227 P\\u2081 = {x | cluster_pt x (\\ud835\\udcdf P\\u2081)} \\u2227\\n set.countable P\\u2082 :=\"}"
  },
  {
    "informal_statement": "If $z$ is a complex number, prove that there exists an $r\\\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "formal_statement": "theorem exercise_1_13 (x y : \\u2102) : \\n |(abs x) - (abs y)| \\u2264 abs (x - y) :=\"}"
  },
  {
    "informal_statement": "Show that if $\\\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\\\mathcal{A}$.",
    "formal_statement": "theorem exercise_13_6 :\\n \\u00ac (\\u2200 U, Rl.is_open U \\u2192 K_topology.is_open U) \\u2227 \\u00ac (\\u2200 U, K_topology.is_open U \\u2192 Rl.is_open U) :=\"}"
  },
  {
    "informal_statement": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "formal_statement": "theorem exercise_5_37 {p q : \\u2115} [fact(p.prime)] [fact(q.prime)] {a : \\u2124}\\n (ha : a < 0) (h0 : p \\u2261 q [ZMOD 4*a]) (h1 : \\u00ac ((p : \\u2124) \\u2223 a)) :\\n legendre_sym p a = legendre_sym q a :=\"}"
  },
  {
    "informal_statement": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "formal_statement": "theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\\n (hx : order_of x = 2) (hx1 : \\u2200 y, order_of y = 2 \\u2192 y = x) :\\n x \\u2208 center G :=\"}"
  },
  {
    "informal_statement": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\\\in A$ there is an open set $U$ containing $x$ such that $U \\\\subset A$. Show that $A$ is open in $X$.",
    "formal_statement": "theorem exercise_13_1 (X : Type*) [topological_space X] (A : set X)\\n (h1 : \\u2200 x \\u2208 A, \\u2203 U : set X, x \\u2208 U \\u2227 is_open U \\u2227 U \\u2286 A) :\\n is_open A :=\"}"
  },
  {
    "informal_statement": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "formal_statement": "theorem exercise_6_1_14 (G : Type*) [group G]\\n (hG : is_cyclic $ G \\u29f8 (center G)) :\\n center G = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "formal_statement": "theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \\u2115} \\n (hm : \\u2203 (g : G), order_of g = m) \\n (hn : \\u2203 (g : G), order_of g = n) \\n (hmn : m.coprime n) :\\n \\u2203 (g : G), order_of g = m * n :=\"}"
  },
  {
    "informal_statement": "If $r$ is rational $(r \\\\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "formal_statement": "theorem exercise_1_2 : \\u00ac \\u2203 (x : \\u211a), ( x ^ 2 = 12 ) :=\"}"
  },
  {
    "informal_statement": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\\\in A$ there is an open set $U$ containing $x$ such that $U \\\\subset A$. Show that $A$ is open in $X$.",
    "formal_statement": "theorem exercise_13_4a1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n is_topology X (\\u22c2 i : I, T i) :=\"}"
  },
  {
    "informal_statement": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "formal_statement": "theorem exercise_10_2_4 :\\n span ({2} : set $ polynomial \\u2124) \\u2293 (span {X}) =\\n span ({2 * X} : set $ polynomial \\u2124) :=\"}"
  },
  {
    "informal_statement": "Show that if $\\\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\\\mathcal{A}$.",
    "formal_statement": "theorem exercise_13_5a {X : Type*}\\n [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\\n generate_from A = generate_from (sInter {T | is_topology X T \\u2227 A \\u2286 T}) :=\"}"
  },

  {
    "informal_statement": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\\\mathbb{Q}[x]$.",
    "formal_statement": "theorem exercise_11_4_8 {p : \\u2115} (hp : prime p) (n : \\u2115) :\\n irreducible (X ^ n - p : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\\\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_5_25 {p : \\u2115} (hp : nat.prime p) :\\n irreducible (\\u2211 i : finset.range p, X ^ p : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "For $j \\\\in\\\\{1,2,3,4\\\\}$, let $z_{j}$ be a complex number with $\\\\left|z_{j}\\\\right|=1$ and $z_{j} \\\\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\\\neq 0 .$",
    "formal_statement": "theorem exercise_2018_b2 (n : \\u2115) (hn : n > 0) (f : \\u2115 \\u2192 \\u2102 \\u2192 \\u2102) \\n (hf : \\u2200 n : \\u2115, f n = \\u03bb z, (\\u2211 (i : fin n), (n-i)* z^(i : \\u2115))) : \\n \\u00ac (\\u2203 z : \\u2102, \\u2016z\\u2016 \\u2264 1 \\u2227 f n z = 0) :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "formal_statement": "theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\\n (hG : card G = 312) :\\n \\u2203 (p : \\u2115) (P : sylow p G), P.normal :=\"}"
  },
  {
    "informal_statement": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\\\equiv 1(p q)$.",
    "formal_statement": "theorem exercise_4_5 {p t : \\u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\\n (a : zmod p) :\\n is_primitive_root a p \\u2194 ((-a) ^ ((p-1)/2) = 1 \\u2227 \\u2200 (k : \\u2115), k < (p-1)/2 \\u2192 (-a)^k \\u2260 1) :=\"}"
  },
  {
    "informal_statement": "If $\\\\Sigma a_{n}$ converges, and if $\\\\left\\\\{b_{n}\\\\right\\\\}$ is monotonic and bounded, prove that $\\\\Sigma a_{n} b_{n}$ converges.",
    "formal_statement": "theorem exercise_3_8\\n (a b : \\u2115 \\u2192 \\u211d)\\n (h1 : \\u2203 y, (tendsto (\\u03bb n, (\\u2211 i in (finset.range n), a i)) at_top (\\ud835\\udcdd y)))\\n (h2 : monotone b)\\n (h3 : metric.bounded (set.range b)) :\\n \\u2203 y, tendsto (\\u03bb n, (\\u2211 i in (finset.range n), (a i) * (b i))) at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathbf{x}_1, \\\\mathbf{x}_2, \\\\ldots$ be a sequence of the points of the product space $\\\\prod X_\\\\alpha$. Show that this sequence converges to the point $\\\\mathbf{x}$ if and only if the sequence $\\\\pi_\\\\alpha(\\\\mathbf{x}_i)$ converges to $\\\\pi_\\\\alpha(\\\\mathbf{x})$ for each $\\\\alpha$.",
    "formal_statement": "theorem exercise_19_6a\\n {n : \\u2115}\\n {f : fin n \\u2192 Type*} {x : \\u2115 \\u2192 \\u03a0a, f a}\\n (y : \\u03a0i, f i)\\n [\\u03a0a, topological_space (f a)] :\\n tendsto x at_top (\\ud835\\udcdd y) \\u2194 \\u2200 i, tendsto (\\u03bb j, (x j) i) at_top (\\ud835\\udcdd (y i)) :=\"}"
  },
  {
    "informal_statement": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\\\unlhd G$ and $A$ abelian.",
    "formal_statement": "theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \\n {H : subgroup G} (hH : H \\u2260 \\u22a5) [H.normal] : \\n \\u2203 A \\u2264 H, A.normal \\u2227 \\u2200 a b : A, a*b = b*a :=\"}"
  },
  {
    "informal_statement": "If $\\\\mathcal{T}_\\\\alpha$ is a family of topologies on $X$, show that $\\\\bigcap \\\\mathcal{T}_\\\\alpha$ is a topology on $X$.",
    "formal_statement": "theorem exercise_13_4a1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n is_topology X (\\u22c2 i : I, T i) :=\"}"
  },
  {
    "informal_statement": "Show that every locally compact Hausdorff space is regular.",
    "formal_statement": "theorem exercise_33_8\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0})\\n (A B : set X) (hA : is_closed A) (hB : is_closed B)\\n (hAB : disjoint A B)\\n (hAc : is_compact A) :\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f '' A = {0} \\u2227 f '' B = {1} :=\"}"
  },
  {
    "informal_statement": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "formal_statement": "theorem exercise_2_11_22 {p : \\u2115} {n : \\u2115} {G : Type*} [fintype G] \\n [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\\n [fintype K] (hK : card K = p ^ (n-1)) : \\n K.normal :=\"}"
  },
  {
    "informal_statement": "If $x, y$ are complex, prove that $||x|-|y|| \\\\leq |x-y|$.",
    "formal_statement": "theorem exercise_1_13 (x y : \\u2102) : \\n |(abs x) - (abs y)| \\u2264 abs (x - y) :=\"}"
  },
  {
    "informal_statement": "Prove that for all $n>1$ that $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is not a group under multiplication of residue classes.",
    "formal_statement": "theorem exercise_1_1_5 (n : \\u2115) (hn : 1 < n) : \\n is_empty (group (zmod n)) :=\"}"
  },
  {
    "informal_statement": "Suppose $u, v \\\\in V$. Prove that $\\\\langle u, v\\\\rangle=0$ if and only if $\\\\|u\\\\| \\\\leq\\\\|u+a v\\\\|$ for all $a \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \\u2102 V]\\n [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = 0 \\u2194 \\u2200 (a : \\u2102), \\u2016u\\u2016 \\u2264 \\u2016u + a \\u2022 v\\u2016 :=\"}"
  },
  {
    "informal_statement": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\\\times Y)-(A \\\\times B)$ is connected.",
    "formal_statement": "theorem exercise_23_9 {X Y : Type*}\\n [topological_space X] [topological_space Y]\\n (A\\u2081 A\\u2082 : set X)\\n (B\\u2081 B\\u2082 : set Y)\\n (hA : A\\u2081 \\u2282 A\\u2082)\\n (hB : B\\u2081 \\u2282 B\\u2082)\\n (hA : is_connected A\\u2082)\\n (hB : is_connected B\\u2082) :\\n is_connected ({x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2082 \\u2227 b \\u2208 B\\u2082} \\\\\\n {x | \\u2203 a b, x = (a, b) \\u2227 a \\u2208 A\\u2081 \\u2227 b \\u2208 B\\u2081}) :=\"}"
  },
  {
    "informal_statement": "Prove that the quotient ring $\\\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "formal_statement": "theorem exercise_9_1_6 : \\u00ac is_principal \\n (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \\u211a))) :=\"}"
  },
  {
    "informal_statement": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "formal_statement": "theorem exercise_4_5_1a {p : \\u2115} {G : Type*} [group G] \\n {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \\n (hH : P \\u2264 H) : is_p_group p H :=\"}"
  },
  {
    "informal_statement": "If $f$ is a real continuous function defined on a closed set $E \\\\subset \\\\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\\\in E$.",
    "formal_statement": "theorem exercise_4_5a\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (h\\u2081 : is_closed E)\\n (h\\u2082 : continuous_on f E)\\n : \\u2203 (g : \\u211d \\u2192 \\u211d), continuous g \\u2227 \\u2200 x \\u2208 E, f x = g x :=\"}"
  },
  {
    "informal_statement": "If $\\\\mathcal{T}_\\\\alpha$ is a family of topologies on $X$, show that $\\\\bigcap \\\\mathcal{T}_\\\\alpha$ is a topology on $X$.",
    "formal_statement": "theorem exercise_13_4b1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n \\u2203! T', is_topology X T' \\u2227 (\\u2200 i, T i \\u2286 T') \\u2227\\n \\u2200 T'', is_topology X T'' \\u2192 (\\u2200 i, T i \\u2286 T'') \\u2192 T'' \\u2286 T' :=\"}"
  },
  {
    "informal_statement": "Give an example of a nonempty subset $U$ of $\\\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\\\in U$ whenever $u \\\\in U$), but $U$ is not a subspace of $\\\\mathbf{R}^2$.",
    "formal_statement": "theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {\\u03b9 : Type*} (u : \\u03b9 \\u2192 submodule F V) :\\n \\u2203 U : submodule F V, (\\u22c2 (i : \\u03b9), (u i).carrier) = \\u2191U :=\"}"
  },
  {
    "informal_statement": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "formal_statement": "theorem exercise_3_14 {p q n : \\u2115} (hp0 : p.prime \\u2227 p > 2) \\n (hq0 : q.prime \\u2227 q > 2) (hpq0 : p \\u2260 q) (hpq1 : p - 1 \\u2223 q - 1)\\n (hn : n.gcd (p*q) = 1) : \\n n^(q-1) \\u2261 1 [MOD p*q] :=\"}"
  },
  {
    "informal_statement": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\\\not \\\\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "formal_statement": "theorem exercise_5_13 {p x: \\u2124} (hp : prime p) \\n (hpx : p \\u2223 (x^4 - x^2 + 1)) : p \\u2261 1 [ZMOD 12] :=\"}"
  },
  {
    "informal_statement": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "formal_statement": "theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \\n subgroup.closure ((H : set G) \\\\ {1}) = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\\\perp}=\\\\{0\\\\}$ if and only if $U=V$",
    "formal_statement": "theorem exercise_7_6 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) :\\n T.range = T.adjoint.range :=\"}"
  },
  {
    "informal_statement": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "formal_statement": "theorem exercise_4_24 {f : \\u211d \\u2192 \\u211d}\\n (hf : continuous f) (a b : \\u211d) (hab : a < b)\\n (h : \\u2200 x y : \\u211d, a < x \\u2192 x < b \\u2192 a < y \\u2192 y < b \\u2192 f ((x + y) / 2) \\u2264 (f x + f y) / 2) :\\n convex_on \\u211d (set.Ioo a b) f :=\"}"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "formal_statement": "theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {S : End F V}\\n (hS : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c) :\\n \\u2203 c : F, S = c \\u2022 id :=\"}"
  },
  {
    "informal_statement": "Suppose that $E$ is an uncountable subset of $\\\\mathbb{R}$. Prove that there exists a point $p \\\\in \\\\mathbb{R}$ at which $E$ condenses.",
    "formal_statement": "theorem exercise_3_4 (n : \\u2115) :\\n tendsto (\\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\\ud835\\udcdd 0) :=\"}"
  },

  {
    "informal_statement": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "formal_statement": "theorem exercise_8_3_4 {R : Type*} {n : \\u2124} {r s : \\u211a} \\n (h : r^2 + s^2 = n) : \\n \\u2203 a b : \\u2124, a^2 + b^2 = n :=\"}"
  },
  {
    "informal_statement": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "formal_statement": "theorem exercise_2_126 {E : set \\u211d}\\n (hE : \\u00ac set.countable E) : \\u2203 (p : \\u211d), cluster_pt p (\\ud835\\udcdf E) :=\"}"
  },
  {
    "informal_statement": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "formal_statement": "theorem exercise_5_13 {p x: \\u2124} (hp : prime p) \\n (hpx : p \\u2223 (x^4 - x^2 + 1)) : p \\u2261 1 [ZMOD 12] :=\"}"
  },
  {
    "informal_statement": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "formal_statement": "theorem exercise_4_1_19 : infinite {x : quaternion \\u211d | x^2 = -1} :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "formal_statement": "theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \\n (hG : card G = 200) : \\n \\u2203 N : sylow 5 G, N.normal :=\"}"
  },
  {
    "informal_statement": "Suppose $p \\\\in \\\\mathcal{P}(\\\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\\\prime}$ have no roots in common.",
    "formal_statement": "theorem exercise_4_4 (p : polynomial \\u2102) :\\n p.degree = @card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102) \\u2194\\n disjoint\\n (@card (root_set p.derivative \\u2102) (polynomial.root_set_fintype p.derivative \\u2102))\\n (@card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102)) :=\"}"
  },
  {
    "informal_statement": "Suppose $f$ is continuous in a region $\\\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "formal_statement": "theorem exercise_1_26\\n (f F\\u2081 F\\u2082 : \\u2102 \\u2192 \\u2102) (\\u03a9 : set \\u2102) (h1 : is_open \\u03a9) (h2 : is_connected \\u03a9)\\n (hF\\u2081 : differentiable_on \\u2102 F\\u2081 \\u03a9) (hF\\u2082 : differentiable_on \\u2102 F\\u2082 \\u03a9)\\n (hdF\\u2081 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2081 x = f x) (hdF\\u2082 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2082 x = f x)\\n : \\u2203 c : \\u2102, \\u2200 x, F\\u2081 x = F\\u2082 x + c :=\"}"
  },
  {
    "informal_statement": "Prove that subgroups of a solvable group are solvable.",
    "formal_statement": "theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \\n {H : subgroup G} (hH : H \\u2260 \\u22a5) [H.normal] : \\n \\u2203 A \\u2264 H, A.normal \\u2227 \\u2200 a b : A, a*b = b*a :=\"}"
  },
  {
    "informal_statement": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\\\in R$. Prove that every Boolean ring is commutative.",
    "formal_statement": "theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \\n \\u2211 g : G, monoid_algebra.of R G g \\u2208 center (monoid_algebra R G) :=\"}"
  },
  {
    "informal_statement": "Let $f: S^{1} \\\\rightarrow \\\\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "formal_statement": "theorem exercise_24_2 {f : (metric.sphere 0 1 : set \\u211d) \\u2192 \\u211d}\\n (hf : continuous f) : \\u2203 x, f x = f (-x) :=\"}"
  },
  {
    "informal_statement": "Prove that if $G$ is an abelian simple group then $G \\\\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "formal_statement": "theorem exercise_3_4_5a {G : Type*} [group G] \\n (H : subgroup G) [is_solvable G] : is_solvable H :=\"}"
  },
  {
    "informal_statement": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "formal_statement": "theorem exercise_26_11\\n {X : Type*} [topological_space X] [compact_space X] [t2_space X]\\n (A : set (set X)) (hA : \\u2200 (a b : set X), a \\u2208 A \\u2192 b \\u2208 A \\u2192 a \\u2286 b \\u2228 b \\u2286 a)\\n (hA' : \\u2200 a \\u2208 A, is_closed a) (hA'' : \\u2200 a \\u2208 A, is_connected a) :\\n is_connected (\\u22c2\\u2080 A) :=\"}"
  },
  {
    "informal_statement": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "formal_statement": "theorem exercise_2_57 {X : Type*} [topological_space X]\\n : \\u2203 (S : set X), is_connected S \\u2227 \\u00ac is_connected (interior S) :=\"}"
  },
  {
    "informal_statement": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "formal_statement": "theorem exercise_2010_a4 (n : \\u2115) : \\n \\u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1) :=\"}"
  },
  {
    "informal_statement": "Show that a group of order 5 must be abelian.",
    "formal_statement": "theorem exercise_2_1_27 {G : Type*} [group G] \\n [fintype G] : \\u2203 (m : \\u2115), \\u2200 (a : G), a ^ m = 1 :=\"}"
  },
  {
    "informal_statement": "Show that if $a$ is negative then $p \\\\equiv q(4 a) together with p\\\\not | a$ imply $(a / p)=(a / q)$.",
    "formal_statement": "theorem exercise_18_4 {n : \\u2115} (hn : \\u2203 x y z w : \\u2124, \\n x^3 + y^3 = n \\u2227 z^3 + w^3 = n \\u2227 x \\u2260 z \\u2227 x \\u2260 w \\u2227 y \\u2260 z \\u2227 y \\u2260 w) : \\n n \\u2265 1729 :=\"}"
  },
  {
    "informal_statement": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "formal_statement": "theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \\n [group G] [group H] (hG : card G = 21) (hH : card H = 21) \\n (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\\n G \\u2243* H :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}$ be the collection of open subsets of a metric space $\\\\mathrm{M}$, and $\\\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\\\mathcal{T}$ onto $\\\\mathcal{K}$.",
    "formal_statement": "theorem exercise_2_29 (M : Type*) [metric_space M]\\n (O C : set (set M))\\n (hO : O = {s | is_open s})\\n (hC : C = {s | is_closed s}) :\\n \\u2203 f : O \\u2192 C, bijective f :=\"}"
  },
  {
    "informal_statement": "Show that if $\\\\prod X_\\\\alpha$ is regular, then so is $X_\\\\alpha$. Assume that each $X_\\\\alpha$ is nonempty.",
    "formal_statement": "theorem exercise_32_2b\\n {\\u03b9 : Type*} {X : \\u03b9 \\u2192 Type*} [\\u2200 i, topological_space (X i)]\\n (h : \\u2200 i, nonempty (X i)) (h2 : regular_space (\\u03a0 i, X i)) :\\n \\u2200 i, regular_space (X i) :=\"}"
  },
  {
    "informal_statement": "If $G$ is a group and $a, x \\\\in G$, prove that $C\\\\left(x^{-1} a x\\\\right)=x^{-1} C(a) x$",
    "formal_statement": "theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) : \\n set.centralizer {x\\u207b\\u00b9*a*x} = \\n (\\u03bb g : G, x\\u207b\\u00b9*g*x) '' (set.centralizer {a}) :=\"}"
  },
  {
    "informal_statement": "Prove that convergence of $\\\\left\\\\{s_{n}\\\\right\\\\}$ implies convergence of $\\\\left\\\\{\\\\left|s_{n}\\\\right|\\\\right\\\\}$.",
    "formal_statement": "theorem exercise_3_3\\n : \\u2203 (x : \\u211d), tendsto f at_top (\\ud835\\udcdd x) \\u2227 \\u2200 n, f n < 2 :=\"}"
  },
  {
    "informal_statement": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_6_3 :\\n infinite {a : \\u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \\u211a)} :=\"}"
  },
  {
    "informal_statement": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "formal_statement": "theorem exercise_4_8b\\n (E : set \\u211d) :\\n \\u2203 f : \\u211d \\u2192 \\u211d, uniform_continuous_on f E \\u2227 \\u00ac metric.bounded (set.image f E) :=\"}"
  },
  {
    "informal_statement": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\\\left(\\\\frac{x+y}{2}\\\\right) \\\\leq \\\\frac{f(x)+f(y)}{2}$ for all $x, y \\\\in(a, b)$. Prove that $f$ is convex.",
    "formal_statement": "theorem exercise_5_2 {a b : \\u211d}\\n {f g : \\u211d \\u2192 \\u211d} (hf : \\u2200 x \\u2208 set.Ioo a b, deriv f x > 0)\\n (hg : g = f\\u207b\\u00b9)\\n (hg_diff : differentiable_on \\u211d g (set.Ioo a b)) :\\n differentiable_on \\u211d g (set.Ioo a b) \\u2227\\n \\u2200 x \\u2208 set.Ioo a b, deriv g x = 1 / deriv f x :=\"}"
  },
  {
    "informal_statement": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2d {p : \\u2115} (hp : p.prime \\u2227 p > 2) \\n {f : polynomial \\u2124} (hf : f = (X + 2)^p): \\n irreducible (\\u2211 n in (f.support \\\\ {0}), (f.coeff n) * X ^ (n-1) : \\n polynomial \\u2124) :=\"}"
  },
  {
    "informal_statement": "Prove that if $T \\\\in \\\\mathcal{L}(V)$ is normal, then $\\\\operatorname{range} T=\\\\operatorname{range} T^{*}.$",
    "formal_statement": "theorem exercise_7_10 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\\n is_self_adjoint T \\u2227 T^2 = T :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\\\in G$. Show that $G$ is abelian.",
    "formal_statement": "theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) : \\n set.centralizer {x\\u207b\\u00b9*a*x} = \\n (\\u03bb g : G, x\\u207b\\u00b9*g*x) '' (set.centralizer {a}) :=\"}"
  },

  {
    "informal_statement": "Prove that $(x, y)$ is not a principal ideal in $\\\\mathbb{Q}[x, y]$.",
    "formal_statement": "theorem exercise_9_1_6 : \\u00ac is_principal \\n (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \\u211a))) :=\"}"
  },
  {
    "informal_statement": "If $G$ is a nonabelian group of order 6, prove that $G \\\\simeq S_3$.",
    "formal_statement": "theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \\u2115}\\n (hp : nat.prime p) (hG : card G = p^2) :\\n \\u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \\u2227 N.normal :=\"}"
  },
  {
    "informal_statement": "Prove that $x^2+y^2-1$ is irreducible in $\\\\mathbb{Q}[x,y]$.",
    "formal_statement": "theorem exercise_9_4_11 : \\n irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \\u211a) :=\"}"
  },
  {
    "informal_statement": "Prove that if $|G|=132$ then $G$ is not simple.",
    "formal_statement": "theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \\n (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "formal_statement": "theorem exercise_1_1_3 (n : \\u2124) : \\n \\u2200 (a b c : \\u2124), (a+b)+c \\u2261 a+(b+c) [ZMOD n] :=\"}"
  },
  {
    "informal_statement": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\\\partial D$ such that $f(z) = 1/z$ for $z \\\\in \\\\partial D$.",
    "formal_statement": "theorem exercise_2020_b5 (z : fin 4 \\u2192 \\u2102) (hz0 : \\u2200 n, \\u2016z n\\u2016 < 1) \\n (hz1 : \\u2200 n : fin 4, z n \\u2260 1) : \\n 3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \\u2260 0 :=\"}"
  },
  {
    "informal_statement": "Let $R$ be a ring in which $x^3 = x$ for every $x \\\\in R$. Prove that $R$ is commutative.",
    "formal_statement": "theorem exercise_4_2_9 {p : \\u2115} (hp : nat.prime p) (hp1 : odd p) :\\n \\u2203 (a b : \\u2124), (a / b : \\u211a) = \\u2211 i in finset.range p, 1 / (i + 1) \\u2192 \\u2191p \\u2223 a :=\"}"
  },
  {
    "informal_statement": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_2b : irreducible \\n (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \\u2124) :=\"}"
  },
  {
    "informal_statement": "Prove that if $T \\\\in \\\\mathcal{L}(V)$ is normal, then $\\\\operatorname{range} T=\\\\operatorname{range} T^{*}.$",
    "formal_statement": "theorem exercise_7_6 {V : Type*} [inner_product_space \\u2102 V]\\n [finite_dimensional \\u2102 V] (T : End \\u2102 V)\\n (hT : T * T.adjoint = T.adjoint * T) :\\n T.range = T.adjoint.range :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}_\\\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\\\mathcal{T}_\\\\alpha$.",
    "formal_statement": "theorem exercise_13_4b1 (X I : Type*) (T : I \\u2192 set (set X)) (h : \\u2200 i, is_topology X (T i)) :\\n \\u2203! T', is_topology X T' \\u2227 (\\u2200 i, T i \\u2286 T') \\u2227\\n \\u2200 T'', is_topology X T'' \\u2192 (\\u2200 i, T i \\u2286 T'') \\u2192 T'' \\u2286 T' :=\"}"
  },
  {
    "informal_statement": "Suppose $a \\\\in R^{1}, f$ is a twice-differentiable real function on $(a, \\\\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\\\left|f^{\\\\prime}(x)\\\\right|,\\\\left|f^{\\\\prime \\\\prime}(x)\\\\right|$, respectively, on $(a, \\\\infty)$. Prove that $M_{1}^{2} \\\\leq 4 M_{0} M_{2} .$",
    "formal_statement": "theorem exercise_5_15 {f : \\u211d \\u2192 \\u211d} (a M0 M1 M2 : \\u211d)\\n (hf' : differentiable_on \\u211d f (set.Ici a))\\n (hf'' : differentiable_on \\u211d (deriv f) (set.Ici a))\\n (hM0 : M0 = Sup {(| f x | )| x \\u2208 (set.Ici a)})\\n (hM1 : M1 = Sup {(| deriv f x | )| x \\u2208 (set.Ici a)})\\n (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\u2208 (set.Ici a)}) :\\n (M1 ^ 2) \\u2264 4 * M0 * M2 :=\"}"
  },
  {
    "informal_statement": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\\\in A$. Prove that $\\\\inf A=-\\\\sup (-A)$.",
    "formal_statement": "theorem exercise_1_11a (z : \\u2102) : \\n \\u2203 (r : \\u211d) (w : \\u2102), abs w = 1 \\u2227 z = r * w :=\"}"
  },
  {
    "informal_statement": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "formal_statement": "theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \\u2115}\\n (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\\n is_simple_group G \\u2192 false :=\"}"
  },
  {
    "informal_statement": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "formal_statement": "theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\\n [linear_order Y] [order_topology Y] {f g : X \\u2192 Y}\\n (hf : continuous f) (hg : continuous g) :\\n continuous (\\u03bb x, min (f x) (g x)) :=\"}"
  },
  {
    "informal_statement": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\\\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.",
    "formal_statement": "theorem exercise_2_11_22 {p : \\u2115} {n : \\u2115} {G : Type*} [fintype G] \\n [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\\n [fintype K] (hK : card K = p ^ (n-1)) : \\n K.normal :=\"}"
  },
  {
    "informal_statement": "Suppose that $f(x)=\\\\sum_{i=0}^{\\\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "formal_statement": "theorem exercise_2017_b3 (f : \\u211d \\u2192 \\u211d) (c : \\u2115 \\u2192 \\u211d)\\n (hf : f = \\u03bb x, (\\u2211' (i : \\u2115), (c i) * x^i)) \\n (hc : \\u2200 n, c n = 0 \\u2228 c n = 1)\\n (hf1 : f (2/3) = 3/2) : \\n irrational (f (1/2)) :=\"}"
  },
  {
    "informal_statement": "Show that a connected metric space having more than one point is uncountable.",
    "formal_statement": "theorem exercise_28_5\\n (X : Type*) [topological_space X] :\\n countably_compact X \\u2194 \\u2200 (C : \\u2115 \\u2192 set X), (\\u2200 n, is_closed (C n)) \\u2227\\n (\\u2200 n, C n \\u2260 \\u2205) \\u2227 (\\u2200 n, C n \\u2286 C (n + 1)) \\u2192 \\u2203 x, \\u2200 n, x \\u2208 C n :=\"}"
  },
  {
    "informal_statement": "If $k \\\\geq 2$ and $\\\\mathbf{x} \\\\in R^{k}$, prove that there exists $\\\\mathbf{y} \\\\in R^{k}$ such that $\\\\mathbf{y} \\\\neq 0$ but $\\\\mathbf{x} \\\\cdot \\\\mathbf{y}=0$",
    "formal_statement": "theorem exercise_1_19\\n (n : \\u2115)\\n (a b c x : euclidean_space \\u211d (fin n))\\n (r : \\u211d)\\n (h\\u2081 : r > 0)\\n (h\\u2082 : 3 \\u2022 c = 4 \\u2022 b - a)\\n (h\\u2083 : 3 * r = 2 * \\u2016x - b\\u2016)\\n : \\u2016x - a\\u2016 = 2 * \\u2016x - b\\u2016 \\u2194 \\u2016x - c\\u2016 = r :=\"}"
  },
  {
    "informal_statement": "Prove that $-(-v) = v$ for every $v \\\\in V$.",
    "formal_statement": "theorem exercise_1_6 : \\u2203 U : set (\\u211d \\u00d7 \\u211d),\\n (U \\u2260 \\u2205) \\u2227\\n (\\u2200 (u v : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2227 v \\u2208 U \\u2192 u + v \\u2208 U) \\u2227\\n (\\u2200 (u : \\u211d \\u00d7 \\u211d), u \\u2208 U \\u2192 -u \\u2208 U) \\u2227\\n (\\u2200 U' : submodule \\u211d (\\u211d \\u00d7 \\u211d), U \\u2260 \\u2191U') :=\"}"
  },
  {
    "informal_statement": "Show that X is countably compact if and only if every nested sequence $C_1 \\\\supset C_2 \\\\supset \\\\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "formal_statement": "theorem exercise_29_1 : \\u00ac locally_compact_space \\u211a :=\"}"
  },
  {
    "informal_statement": "Show that $\\\\int_0^1 \\\\log(\\\\sin \\\\pi x) dx = - \\\\log 2$.",
    "formal_statement": "theorem exercise_3_22 (D : set \\u2102) (hD : D = ball 0 1) (f : \\u2102 \\u2192 \\u2102)\\n (hf : differentiable_on \\u2102 f D) (hfc : continuous_on f (closure D)) :\\n \\u00ac \\u2200 z \\u2208 (sphere (0 : \\u2102) 1), f z = 1 / z :=\"}"
  },
  {
    "informal_statement": "If $A \\\\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\\\rightarrow A$ such that $r(a)=a$ for each $a \\\\in A$. Show that a retraction is a quotient map.",
    "formal_statement": "theorem exercise_22_2b {X : Type*} [topological_space X]\\n {A : set X} (r : X \\u2192 A) (hr : continuous r) (h : \\u2200 x : A, r x = x) :\\n quotient_map r :=\"}"
  },
  {
    "informal_statement": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\\\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "formal_statement": "theorem exercise_4_6\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (G : set (\\u211d \\u00d7 \\u211d))\\n (h\\u2081 : is_compact E)\\n (h\\u2082 : G = {(x, f x) | x \\u2208 E})\\n : continuous_on f E \\u2194 is_compact G :=\"}"
  },
  {
    "informal_statement": "Suppose that $S, T \\\\in \\\\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\\\operatorname{null} (T-\\\\lambda I)$ is invariant under $S$ for every $\\\\lambda \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] {S : End F V}\\n (hS : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c) :\\n \\u2203 c : F, S = c \\u2022 id :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\\\bar{V}$ is compact and $\\\\bar{V} \\\\subset U$.",
    "formal_statement": "theorem exercise_30_13 {X : Type*} [topological_space X]\\n (h : \\u2203 (s : set X), countable s \\u2227 dense s) (U : set (set X))\\n (hU : \\u2200 (x y : set X), x \\u2208 U \\u2192 y \\u2208 U \\u2192 x \\u2260 y \\u2192 x \\u2229 y = \\u2205) :\\n countable U :=\"}"
  },
  {
    "informal_statement": "If $\\\\Sigma a_{n}$ converges, and if $\\\\left\\\\{b_{n}\\\\right\\\\}$ is monotonic and bounded, prove that $\\\\Sigma a_{n} b_{n}$ converges.",
    "formal_statement": "theorem exercise_3_20 {X : Type*} [metric_space X]\\n (p : \\u2115 \\u2192 X) (l : \\u2115) (r : X)\\n (hp : cauchy_seq p)\\n (hpl : tendsto (\\u03bb n, p (l * n)) at_top (\\ud835\\udcdd r)) :\\n tendsto p at_top (\\ud835\\udcdd r) :=\"}"
  },
  {
    "informal_statement": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\\\in R$ then $x=\\\\pm 1$.",
    "formal_statement": "theorem exercise_7_1_11 {R : Type*} [ring R] [is_domain R] \\n {x : R} (hx : x^2 = 1) : x = 1 \\u2228 x = -1 :=\"}"
  },

  {
    "informal_statement": "Prove that $\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i<n} a_i = \\\\infty$, where $a_i = \\\\sqrt{i + 1} -\\\\sqrt{i}$.",
    "formal_statement": "theorem exercise_3_8\\n (a b : \\u2115 \\u2192 \\u211d)\\n (h1 : \\u2203 y, (tendsto (\\u03bb n, (\\u2211 i in (finset.range n), a i)) at_top (\\ud835\\udcdd y)))\\n (h2 : monotone b)\\n (h3 : metric.bounded (set.range b)) :\\n \\u2203 y, tendsto (\\u03bb n, (\\u2211 i in (finset.range n), (a i) * (b i))) at_top (\\ud835\\udcdd y) :=\"}"
  },
  {
    "informal_statement": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "formal_statement": "theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\\n (hG : even (card G)) : \\u2203 x : G, order_of x = 2 :=\"}"
  },
  {
    "informal_statement": "If $s_{1}=\\\\sqrt{2}$, and $s_{n+1}=\\\\sqrt{2+\\\\sqrt{s_{n}}} \\\\quad(n=1,2,3, \\\\ldots),$ prove that $\\\\left\\\\{s_{n}\\\\right\\\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\\\ldots$.",
    "formal_statement": "theorem exercise_3_3\\n : \\u2203 (x : \\u211d), tendsto f at_top (\\ud835\\udcdd x) \\u2227 \\u2200 n, f n < 2 :=\"}"
  },
  {
    "informal_statement": "Let $\\\\Omega$ be a bounded open subset of $\\\\mathbb{C}$, and $\\\\varphi: \\\\Omega \\\\rightarrow \\\\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\\\in \\\\Omega$ such that $\\\\varphi\\\\left(z_{0}\\\\right)=z_{0} \\\\quad \\\\text { and } \\\\quad \\\\varphi^{\\\\prime}\\\\left(z_{0}\\\\right)=1$ then $\\\\varphi$ is linear.",
    "formal_statement": "theorem exercise_2_9\\n {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (b : metric.bounded \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (z \\u2208 \\u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\\n \\u2203 (f_lin : \\u2102 \\u2192L[\\u2102] \\u2102), \\u2200 x \\u2208 \\u03a9, f x = f_lin x :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "formal_statement": "theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\\n (s : set X) : set.infinite s \\u2192 is_connected s :=\"}"
  },
  {
    "informal_statement": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\\\rightarrow Y$ be continuous. Let $h: X \\\\rightarrow Y$ be the function $h(x)=\\\\min \\\\{f(x), g(x)\\\\}.$ Show that $h$ is continuous.",
    "formal_statement": "theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\\n [linear_order Y] [order_topology Y] {f g : X \\u2192 Y}\\n (hf : continuous f) (hg : continuous g) :\\n continuous (\\u03bb x, min (f x) (g x)) :=\"}"
  },
  {
    "informal_statement": "Prove that if $P \\\\in \\\\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\\\in \\\\operatorname{Syl}_{p}(H)$.",
    "formal_statement": "theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\\n (hG : card G = 312) :\\n \\u2203 (p : \\u2115) (P : sylow p G), P.normal :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}$ be the collection of open subsets of a metric space $\\\\mathrm{M}$, and $\\\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\\\mathcal{T}$ onto $\\\\mathcal{K}$.",
    "formal_statement": "theorem exercise_2_41 (m : \\u2115) {X : Type*} [normed_space \\u211d ((fin m) \\u2192 \\u211d)] :\\n is_compact (metric.closed_ball 0 1) :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\mathbb{Q}$ has no proper subgroups of finite index.",
    "formal_statement": "theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\\n is_cyclic G \\u2227 \\u2203 G_fin : fintype G, nat.prime (@card G G_fin) :=\"}"
  },
  {
    "informal_statement": "Prove that subgroups of a solvable group are solvable.",
    "formal_statement": "theorem exercise_3_4_5a {G : Type*} [group G] \\n (H : subgroup G) [is_solvable G] : is_solvable H :=\"}"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "formal_statement": "theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] [finite_dimensional F V] {S T : End F V}\\n (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\\n (h2 : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c \\u2194 \\u2203 c : F, v \\u2208 eigenspace T c) :\\n S * T = T * S :=\"}"
  },
  {
    "informal_statement": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\\\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "formal_statement": "theorem exercise_4_8b\\n (E : set \\u211d) :\\n \\u2203 f : \\u211d \\u2192 \\u211d, uniform_continuous_on f E \\u2227 \\u00ac metric.bounded (set.image f E) :=\"}"
  },
  {
    "informal_statement": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "formal_statement": "theorem exercise_1998_a3 (f : \\u211d \\u2192 \\u211d) (hf : cont_diff \\u211d 3 f) : \\n \\u2203 a : \\u211d, (f a) * (deriv f a) * (iterated_deriv 2 f a) * (iterated_deriv 3 f a) \\u2265 0 :=\"}"
  },
  {
    "informal_statement": "Prove that the power series $\\\\sum zn/n^2$ converges at every point of the unit circle.",
    "formal_statement": "theorem exercise_1_26\\n (f F\\u2081 F\\u2082 : \\u2102 \\u2192 \\u2102) (\\u03a9 : set \\u2102) (h1 : is_open \\u03a9) (h2 : is_connected \\u03a9)\\n (hF\\u2081 : differentiable_on \\u2102 F\\u2081 \\u03a9) (hF\\u2082 : differentiable_on \\u2102 F\\u2082 \\u03a9)\\n (hdF\\u2081 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2081 x = f x) (hdF\\u2082 : \\u2200 x \\u2208 \\u03a9, deriv F\\u2082 x = f x)\\n : \\u2203 c : \\u2102, \\u2200 x, F\\u2081 x = F\\u2082 x + c :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\\\mathbb{Z}[x]$.",
    "formal_statement": "theorem exercise_9_4_11 : \\n irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \\u211a) :=\"}"
  },
  {
    "informal_statement": "Prove that there is no rational number whose square is $12$.",
    "formal_statement": "theorem exercise_1_2 : \\u00ac \\u2203 (x : \\u211a), ( x ^ 2 = 12 ) :=\"}"
  },
  {
    "informal_statement": "Suppose $f$ is continuous in a region $\\\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "formal_statement": "theorem exercise_2_9\\n {f : \\u2102 \\u2192 \\u2102} (\\u03a9 : set \\u2102) (b : metric.bounded \\u03a9) (h : is_open \\u03a9)\\n (hf : differentiable_on \\u2102 f \\u03a9) (z \\u2208 \\u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\\n \\u2203 (f_lin : \\u2102 \\u2192L[\\u2102] \\u2102), \\u2200 x \\u2208 \\u03a9, f x = f_lin x :=\"}"
  },
  {
    "informal_statement": "Prove that $x^3 - 3x - 1$ is irreducible over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_2_4_16b {n : \\u2115} {hn : n \\u2260 0} \\n {R : subgroup (dihedral_group n)} \\n (hR : R = subgroup.closure {dihedral_group.r 1}) : \\n R \\u2260 \\u22a4 \\u2227 \\n \\u2200 K : subgroup (dihedral_group n), R \\u2264 K \\u2192 K = R \\u2228 K = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Prove that if $x^{2}=1$ for all $x \\\\in G$ then $G$ is abelian.",
    "formal_statement": "theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \\n (hx_inf : order_of x = 0) (n m : \\u2124) :\\n x ^ n \\u2260 x ^ m :=\"}"
  },
  {
    "informal_statement": "Prove that $x^3 - 3x - 1$ is irreducible over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\\n (h : a * b = b * a) :\\n \\u2200 x y : closure {x | x = a \\u2228 x = b}, x*y = y*x :=\"}"
  },
  {
    "informal_statement": "Show that the collection $\\\\{(a,b) \\\\mid a < b, a \\\\text{ and } b \\\\text{ rational}\\\\}$ is a basis that generates a topology different from the lower limit topology on $\\\\mathbb{R}$.",
    "formal_statement": "theorem exercise_13_8b :\\n (topological_space.generate_from {S : set \\u211d | \\u2203 a b : \\u211a, a < b \\u2227 S = Ico a b}).is_open \\u2260\\n (lower_limit_topology \\u211d).is_open :=\"}"
  },
  {
    "informal_statement": "Prove that the quotient ring $\\\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "formal_statement": "theorem exercise_8_3_6a {R : Type*} [ring R]\\n (hR : R = (gaussian_int \\u29f8 ideal.span ({\\u27e80, 1\\u27e9} : set gaussian_int))) :\\n is_field R \\u2227 \\u2203 finR : fintype R, @card R finR = 2 :=\"}"
  },
  {
    "informal_statement": "Let $H \\\\leq K \\\\leq G$. Prove that $|G: H|=|G: K| \\\\cdot|K: H|$ (do not assume $G$ is finite).",
    "formal_statement": "theorem exercise_3_2_21a (H : add_subgroup \\u211a) (hH : H \\u2260 \\u22a4) : H.index = 0 :=\"}"
  },
  {
    "informal_statement": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "formal_statement": "theorem exercise_4_12\\n {\\u03b1 \\u03b2 \\u03b3 : Type*} [uniform_space \\u03b1] [uniform_space \\u03b2] [uniform_space \\u03b3]\\n {f : \\u03b1 \\u2192 \\u03b2} {g : \\u03b2 \\u2192 \\u03b3}\\n (hf : uniform_continuous f) (hg : uniform_continuous g) :\\n uniform_continuous (g \\u2218 f) :=\"}"
  },
  {
    "informal_statement": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\\\varphi(N)$, where $\\\\varphi$ denotes Euler's $\\\\varphi$-function. Prove that if $M_{1} \\\\equiv M^{d} \\\\pmod N$ then $M \\\\equiv M_{1}^{d^{\\\\prime}} \\\\pmod N$ where $d^{\\\\prime}$ is the inverse of $d \\\\bmod \\\\varphi(N)$: $d d^{\\\\prime} \\\\equiv 1 \\\\pmod {\\\\varphi(N)}$.",
    "formal_statement": "theorem exercise_8_1_12 {N : \\u2115} (hN : N > 0) {M M': \\u2124} {d : \\u2115}\\n (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \\n (hM' : M' \\u2261 M^d [ZMOD N]) : \\n \\u2203 d' : \\u2115, d' * d \\u2261 1 [ZMOD N.totient] \\u2227 \\n M \\u2261 M'^d' [ZMOD N] :=\"}"
  },
  {
    "informal_statement": "If $k \\\\geq 2$ and $\\\\mathbf{x} \\\\in R^{k}$, prove that there exists $\\\\mathbf{y} \\\\in R^{k}$ such that $\\\\mathbf{y} \\\\neq 0$ but $\\\\mathbf{x} \\\\cdot \\\\mathbf{y}=0$",
    "formal_statement": "theorem exercise_1_18a\\n (n : \\u2115)\\n (h : n > 1)\\n (x : euclidean_space \\u211d (fin n)) -- R^n\\n : \\u2203 (y : euclidean_space \\u211d (fin n)), y \\u2260 0 \\u2227 (inner x y) = (0 : \\u211d) :=\"}"
  },

  {
    "informal_statement": "Let $\\\\|\\\\cdot\\\\|$ be any norm on $\\\\mathbb{R}^{m}$ and let $B=\\\\left\\\\{x \\\\in \\\\mathbb{R}^{m}:\\\\|x\\\\| \\\\leq 1\\\\right\\\\}$. Prove that $B$ is compact.",
    "formal_statement": "theorem exercise_2_57 {X : Type*} [topological_space X]\\n : \\u2203 (S : set X), is_connected S \\u2227 \\u00ac is_connected (interior S) :=\"}"
  },
  {
    "informal_statement": "Let $G=\\\\left\\\\{g_{1}, \\\\ldots, g_{n}\\\\right\\\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "formal_statement": "theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \\n \\u2211 g : G, monoid_algebra.of R G g \\u2208 center (monoid_algebra R G) :=\"}"
  },
  {
    "informal_statement": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\\\left|g^{-1} x g\\\\right|$.",
    "formal_statement": "theorem exercise_1_1_22a {G : Type*} [group G] (x g : G) :\\n order_of x = order_of (g\\u207b\\u00b9 * x * g) :=\"}"
  },
  {
    "informal_statement": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "formal_statement": "theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\\n (hH : \\u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \\u2192 H = K) : \\n H.characteristic :=\"}"
  },
  {
    "informal_statement": "Let $R$ be a ring in which $x^3 = x$ for every $x \\\\in R$. Prove that $R$ is commutative.",
    "formal_statement": "theorem exercise_4_2_5 {R : Type*} [ring R] \\n (h : \\u2200 x : R, x ^ 3 = x) : comm_ring R :=\"}"
  },
  {
    "informal_statement": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "formal_statement": "theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\\n \\u2200 a b : A \\u29f8 B, a*b = b*a :=\"}"
  },
  {
    "informal_statement": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "formal_statement": "theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\\n (H : I \\u2192 subgroup G) (hH : \\u2200 i : I, subgroup.normal (H i)) : \\n subgroup.normal (\\u2a05 (i : I), H i):=\"}"
  },
  {
    "informal_statement": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\\\varphi(N)$, where $\\\\varphi$ denotes Euler's $\\\\varphi$-function. Prove that if $M_{1} \\\\equiv M^{d} \\\\pmod N$ then $M \\\\equiv M_{1}^{d^{\\\\prime}} \\\\pmod N$ where $d^{\\\\prime}$ is the inverse of $d \\\\bmod \\\\varphi(N)$: $d d^{\\\\prime} \\\\equiv 1 \\\\pmod {\\\\varphi(N)}$.",
    "formal_statement": "theorem exercise_8_3_4 {R : Type*} {n : \\u2124} {r s : \\u211a} \\n (h : r^2 + s^2 = n) : \\n \\u2203 a b : \\u2124, a^2 + b^2 = n :=\"}"
  },
  {
    "informal_statement": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\\\unlhd G$ and $A$ abelian.",
    "formal_statement": "theorem exercise_4_3_26 {\\u03b1 : Type*} [fintype \\u03b1] (ha : fintype.card \\u03b1 > 1)\\n (h_tran : \\u2200 a b: \\u03b1, \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u03c3 a = b) : \\n \\u2203 \\u03c3 : equiv.perm \\u03b1, \\u2200 a : \\u03b1, \\u03c3 a \\u2260 a :=\"}"
  },
  {
    "informal_statement": "Prove that if $x^{2}=1$ for all $x \\\\in G$ then $G$ is abelian.",
    "formal_statement": "theorem exercise_1_1_25 {G : Type*} [group G] \\n (h : \\u2200 x : G, x ^ 2 = 1) : \\u2200 a b : G, a*b = b*a :=\"}"
  },
  {
    "informal_statement": "Suppose $\\\\left\\\\{p_{n}\\\\right\\\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\\\left\\\\{p_{n l}\\\\right\\\\}$ converges to a point $p \\\\in X$. Prove that the full sequence $\\\\left\\\\{p_{n}\\\\right\\\\}$ converges to $p$.",
    "formal_statement": "theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\\n (G : \\u2115 \\u2192 set X) (hG : \\u2200 n, is_open (G n) \\u2227 dense (G n)) :\\n \\u2203 x, \\u2200 n, x \\u2208 G n :=\"}"
  },
  {
    "informal_statement": "Prove that a group of even order contains an element of order $2 .$",
    "formal_statement": "theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\\n (hG : even (card G)) : \\u2203 x : G, order_of x = 2 :=\"}"
  },
  {
    "informal_statement": "Show that X is countably compact if and only if every nested sequence $C_1 \\\\supset C_2 \\\\supset \\\\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "formal_statement": "theorem exercise_28_5\\n (X : Type*) [topological_space X] :\\n countably_compact X \\u2194 \\u2200 (C : \\u2115 \\u2192 set X), (\\u2200 n, is_closed (C n)) \\u2227\\n (\\u2200 n, C n \\u2260 \\u2205) \\u2227 (\\u2200 n, C n \\u2286 C (n + 1)) \\u2192 \\u2203 x, \\u2200 n, x \\u2208 C n :=\"}"
  },
  {
    "informal_statement": "If $x, y$ are complex, prove that $||x|-|y|| \\\\leq |x-y|$.",
    "formal_statement": "theorem exercise_1_16a\\n (n : \\u2115)\\n (d r : \\u211d)\\n (x y z : euclidean_space \\u211d (fin n)) -- R^n\\n (h\\u2081 : n \\u2265 3)\\n (h\\u2082 : \\u2016x - y\\u2016 = d)\\n (h\\u2083 : d > 0)\\n (h\\u2084 : r > 0)\\n (h\\u2085 : 2 * r > d)\\n : set.infinite {z : euclidean_space \\u211d (fin n) | \\u2016z - x\\u2016 = r \\u2227 \\u2016z - y\\u2016 = r} :=\"}"
  },
  {
    "informal_statement": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\\\in G$.",
    "formal_statement": "theorem exercise_2_1_27 {G : Type*} [group G] \\n [fintype G] : \\u2203 (m : \\u2115), \\u2200 (a : G), a ^ m = 1 :=\"}"
  },
  {
    "informal_statement": "Suppose (a) $f$ is continuous for $x \\\\geq 0$, (b) $f^{\\\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\\\prime}$ is monotonically increasing. Put $g(x)=\\\\frac{f(x)}{x} \\\\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "formal_statement": "theorem exercise_5_15 {f : \\u211d \\u2192 \\u211d} (a M0 M1 M2 : \\u211d)\\n (hf' : differentiable_on \\u211d f (set.Ici a))\\n (hf'' : differentiable_on \\u211d (deriv f) (set.Ici a))\\n (hM0 : M0 = Sup {(| f x | )| x \\u2208 (set.Ici a)})\\n (hM1 : M1 = Sup {(| deriv f x | )| x \\u2208 (set.Ici a)})\\n (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\u2208 (set.Ici a)}) :\\n (M1 ^ 2) \\u2264 4 * M0 * M2 :=\"}"
  },
  {
    "informal_statement": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\\\in G$.",
    "formal_statement": "theorem exercise_2_2_5 {G : Type*} [group G] \\n (h : \\u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \\u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\\\not \\\\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "formal_statement": "theorem exercise_4_8 {p a : \\u2115} (hp : odd p) : \\n is_primitive_root a p \\u2194 (\\u2200 q \\u2223 (p-1), q.prime \\u2192 \\u00ac a^(p-1) \\u2261 1 [MOD p]) :=\"}"
  },
  {
    "informal_statement": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\\\colon X \\\\rightarrow [0, 1]$ such that $f(A) = \\\\{0\\\\}$ and $f(B) = \\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_33_8\\n (X : Type*) [topological_space X] [regular_space X]\\n (h : \\u2200 x A, is_closed A \\u2227 \\u00ac x \\u2208 A \\u2192\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f x = (1 : I) \\u2227 f '' A = {0})\\n (A B : set X) (hA : is_closed A) (hB : is_closed B)\\n (hAB : disjoint A B)\\n (hAc : is_compact A) :\\n \\u2203 (f : X \\u2192 I), continuous f \\u2227 f '' A = {0} \\u2227 f '' B = {1} :=\"}"
  },
  {
    "informal_statement": "Prove that $x^3 + 6x + 12$ is irreducible in $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\\n irreducible (12 + 6 * X + X ^ 3 : polynomial F) :=\"}"
  },
  {
    "informal_statement": "Suppose that $f(x)=\\\\sum_{i=0}^{\\\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "formal_statement": "theorem exercise_2010_a4 (n : \\u2115) : \\n \\u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1) :=\"}"
  },
  {
    "informal_statement": "Let $F = \\\\mathbb{Z}_p$ be the field of integers $\\\\mod p$, where $p$ is a prime, and let $q(x) \\\\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "formal_statement": "theorem exercise_4_5_16 {p n: \\u2115} (hp : nat.prime p) \\n {q : polynomial (zmod p)} (hq : irreducible q) (hn : q.degree = n) :\\n \\u2203 is_fin : fintype $ polynomial (zmod p) \\u29f8 ideal.span ({q} : set (polynomial $ zmod p)), \\n @card (polynomial (zmod p) \\u29f8 ideal.span {q}) is_fin = p ^ n \\u2227 \\n is_field (polynomial $ zmod p):=\"}"
  },
  {
    "informal_statement": "Prove that $x^3 + 6x + 12$ is irreducible in $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\\n irreducible (X ^ 3 - 9 : polynomial F) :=\"}"
  },
  {
    "informal_statement": "Suppose that $E$ is an uncountable subset of $\\\\mathbb{R}$. Prove that there exists a point $p \\\\in \\\\mathbb{R}$ at which $E$ condenses.",
    "formal_statement": "theorem exercise_2_126 {E : set \\u211d}\\n (hE : \\u00ac set.countable E) : \\u2203 (p : \\u211d), cluster_pt p (\\ud835\\udcdf E) :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\sum 1/k(\\\\log(k))^p$ diverges when $p \\\\leq 1$.",
    "formal_statement": "theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\\n (hG : card G = 5) :\\n comm_group G :=\"}"
  },
  {
    "informal_statement": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "formal_statement": "theorem exercise_4_5a\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (h\\u2081 : is_closed E)\\n (h\\u2082 : continuous_on f E)\\n : \\u2203 (g : \\u211d \\u2192 \\u211d), continuous g \\u2227 \\u2200 x \\u2208 E, f x = g x :=\"}"
  },
  {
    "informal_statement": "Prove that $x^2+y^2-1$ is irreducible in $\\\\mathbb{Q}[x,y]$.",
    "formal_statement": "theorem exercise_1_1a\\n (x : \\u211d) (y : \\u211a) :\\n ( irrational x ) -> irrational ( x + y ) :=\"}"
  },

  {
    "informal_statement": "Prove that $x^2+1$ is irreducible in $\\\\mathbb{F}_7$",
    "formal_statement": "theorem exercise_11_4_8 {p : \\u2115} (hp : prime p) (n : \\u2115) :\\n irreducible (X ^ n - p : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "formal_statement": "theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \\n H.normal \\u2194 \\u2045(\\u22a4 : subgroup G), H\\u2046 \\u2264 H :=\"}"
  },
  {
    "informal_statement": "Let $\\\\left\\\\{A_{n}\\\\right\\\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\\\cap A_{n+1} \\\\neq \\\\varnothing$ for all $n$. Show that $\\\\bigcup A_{n}$ is connected.",
    "formal_statement": "theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\\n (s : set X) : set.infinite s \\u2192 is_connected s :=\"}"
  },
  {
    "informal_statement": "Suppose that $S, T \\\\in \\\\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\\\operatorname{null} (T-\\\\lambda I)$ is invariant under $S$ for every $\\\\lambda \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] (S T : V \\u2192\\u2097[F] V) (hST : S \\u2218 T = T \\u2218 S) (c : F):\\n map S (T - c \\u2022 id).ker = (T - c \\u2022 id).ker :=\"}"
  },
  {
    "informal_statement": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "formal_statement": "theorem exercise_3_1 {F V : Type*} \\n [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\\n (T : V \\u2192\\u2097[F] V) (hT : finrank F V = 1) :\\n \\u2203 c : F, \\u2200 v : V, T v = c \\u2022 v:=\"}"
  },
  {
    "informal_statement": "Prove that the addition of residue classes $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is associative.",
    "formal_statement": "theorem exercise_1_1_5 (n : \\u2115) (hn : 1 < n) : \\n is_empty (group (zmod n)) :=\"}"
  },
  {
    "informal_statement": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\\\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "formal_statement": "theorem exercise_4_6_3 :\\n infinite {a : \\u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \\u211a)} :=\"}"
  },
  {
    "informal_statement": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\\\partial D$ such that $f(z) = 1/z$ for $z \\\\in \\\\partial D$.",
    "formal_statement": "theorem exercise_3_22 (D : set \\u2102) (hD : D = ball 0 1) (f : \\u2102 \\u2192 \\u2102)\\n (hf : differentiable_on \\u2102 f D) (hfc : continuous_on f (closure D)) :\\n \\u00ac \\u2200 z \\u2208 (sphere (0 : \\u2102) 1), f z = 1 / z :=\"}"
  },
  {
    "informal_statement": "Suppose that $T \\\\in \\\\mathcal{L}(V)$ has $\\\\operatorname{dim} V$ distinct eigenvalues and that $S \\\\in \\\\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "formal_statement": "theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] [finite_dimensional F V] {S T : End F V}\\n (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\\n (h2 : \\u2200 v : V, \\u2203 c : F, v \\u2208 eigenspace S c \\u2194 \\u2203 c : F, v \\u2208 eigenspace T c) :\\n S * T = T * S :=\"}"
  },
  {
    "informal_statement": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "formal_statement": "theorem exercise_4_2_5 {R : Type*} [ring R] \\n (h : \\u2200 x : R, x ^ 3 = x) : comm_ring R :=\"}"
  },
  {
    "informal_statement": "Suppose $\\\\left\\\\{p_{n}\\\\right\\\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\\\left\\\\{p_{n l}\\\\right\\\\}$ converges to a point $p \\\\in X$. Prove that the full sequence $\\\\left\\\\{p_{n}\\\\right\\\\}$ converges to $p$.",
    "formal_statement": "theorem exercise_3_20 {X : Type*} [metric_space X]\\n (p : \\u2115 \\u2192 X) (l : \\u2115) (r : X)\\n (hp : cauchy_seq p)\\n (hpl : tendsto (\\u03bb n, p (l * n)) at_top (\\ud835\\udcdd r)) :\\n tendsto p at_top (\\ud835\\udcdd r) :=\"}"
  },
  {
    "informal_statement": "If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\\\in \\\\mathbb{Z}$ are all distinct.",
    "formal_statement": "theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \\n (hx_inf : order_of x = 0) (n m : \\u2124) :\\n x ^ n \\u2260 x ^ m :=\"}"
  },
  {
    "informal_statement": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "formal_statement": "theorem exercise_4_19\\n {f : \\u211d \\u2192 \\u211d} (hf : \\u2200 a b c, a < b \\u2192 f a < c \\u2192 c < f b \\u2192 \\u2203 x, a < x \\u2227 x < b \\u2227 f x = c)\\n (hg : \\u2200 r : \\u211a, is_closed {x | f x = r}) : continuous f :=\"}"
  },
  {
    "informal_statement": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "formal_statement": "theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\\n [subgroup.characteristic H] : subgroup.normal H :=\"}"
  },
  {
    "informal_statement": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\\\leq H$.",
    "formal_statement": "theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \\n H.normal \\u2194 \\u2045(\\u22a4 : subgroup G), H\\u2046 \\u2264 H :=\"}"
  },
  {
    "informal_statement": "If $A \\\\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\\\rightarrow A$ such that $r(a)=a$ for each $a \\\\in A$. Show that a retraction is a quotient map.",
    "formal_statement": "theorem exercise_23_2 {X : Type*}\\n [topological_space X] {A : \\u2115 \\u2192 set X} (hA : \\u2200 n, is_connected (A n))\\n (hAn : \\u2200 n, A n \\u2229 A (n + 1) \\u2260 \\u2205) :\\n is_connected (\\u22c3 n, A n) :=\"}"
  },
  {
    "informal_statement": "Prove that $x^2+1$ is irreducible in $\\\\mathbb{F}_7$",
    "formal_statement": "theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\\n irreducible (X ^ 3 - 9 : polynomial F) :=\"}"
  },
  {
    "informal_statement": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\\\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "formal_statement": "theorem exercise_2_11_6 {G : Type*} [group G] {p : \\u2115} (hp : nat.prime p) \\n {P : sylow p G} (hP : P.normal) :\\n \\u2200 (Q : sylow p G), P = Q :=\"}"
  },
  {
    "informal_statement": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "formal_statement": "theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\\n (hx : order_of x = 2) (hx1 : \\u2200 y, order_of y = 2 \\u2192 y = x) :\\n x \\u2208 center G :=\"}"
  },
  {
    "informal_statement": "Prove that if $P \\\\in \\\\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\\\in \\\\operatorname{Syl}_{p}(H)$.",
    "formal_statement": "theorem exercise_4_5_1a {p : \\u2115} {G : Type*} [group G] \\n {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \\n (hH : P \\u2264 H) : is_p_group p H :=\"}"
  },
  {
    "informal_statement": "Suppose $k \\\\geq 3, x, y \\\\in \\\\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\\\in \\\\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "formal_statement": "theorem exercise_1_16a\\n (n : \\u2115)\\n (d r : \\u211d)\\n (x y z : euclidean_space \\u211d (fin n)) -- R^n\\n (h\\u2081 : n \\u2265 3)\\n (h\\u2082 : \\u2016x - y\\u2016 = d)\\n (h\\u2083 : d > 0)\\n (h\\u2084 : r > 0)\\n (h\\u2085 : 2 * r > d)\\n : set.infinite {z : euclidean_space \\u211d (fin n) | \\u2016z - x\\u2016 = r \\u2227 \\u2016z - y\\u2016 = r} :=\"}"
  },
  {
    "informal_statement": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "formal_statement": "theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\\n irreducible (12 + 6 * X + X ^ 3 : polynomial F) :=\"}"
  },
  {
    "informal_statement": "Suppose that $T \\\\in \\\\mathcal{L}(V)$ has $\\\\operatorname{dim} V$ distinct eigenvalues and that $S \\\\in \\\\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "formal_statement": "theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \\u2102 V]\\n [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = 0 \\u2194 \\u2200 (a : \\u2102), \\u2016u\\u2016 \\u2264 \\u2016u + a \\u2022 v\\u2016 :=\"}"
  },
  {
    "informal_statement": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "formal_statement": "theorem exercise_3_5 : \\u00ac \\u2203 x y : \\u2124, 7*x^3 + 2 = y^3 :=\"}"
  },
  {
    "informal_statement": "Suppose (a) $f$ is continuous for $x \\\\geq 0$, (b) $f^{\\\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\\\prime}$ is monotonically increasing. Put $g(x)=\\\\frac{f(x)}{x} \\\\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "formal_statement": "theorem exercise_5_6\\n {f : \\u211d \\u2192 \\u211d}\\n (hf1 : continuous f)\\n (hf2 : \\u2200 x, differentiable_at \\u211d f x)\\n (hf3 : f 0 = 0)\\n (hf4 : monotone (deriv f)) :\\n monotone_on (\\u03bb x, f x / x) (set.Ioi 0) :=\"}"
  },
  {
    "informal_statement": "Prove that the addition of residue classes $\\\\mathbb{Z}/n\\\\mathbb{Z}$ is associative.",
    "formal_statement": "theorem exercise_1_1_3 (n : \\u2124) : \\n \\u2200 (a b c : \\u2124), (a+b)+c \\u2261 a+(b+c) [ZMOD n] :=\"}"
  },
  {
    "informal_statement": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\\\{1\\\\}$.",
    "formal_statement": "theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \\n subgroup.closure ((H : set G) \\\\ {1}) = \\u22a4 :=\"}"
  },

  {
    "informal_statement": "Prove that if $V$ is a complex inner-product space, then $\\\\langle u, v\\\\rangle=\\\\frac{\\\\|u+v\\\\|^{2}-\\\\|u-v\\\\|^{2}+\\\\|u+i v\\\\|^{2} i-\\\\|u-i v\\\\|^{2} i}{4}$ for all $u, v \\\\in V$.",
    "formal_statement": "theorem exercise_6_7 {V : Type*} [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = (\\u2016u + v\\u2016^2 - \\u2016u - v\\u2016^2 + I*\\u2016u + I\\u2022v\\u2016^2 - I*\\u2016u-I\\u2022v\\u2016^2) / 4 :=\"}"
  },
  {
    "informal_statement": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\\\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "formal_statement": "theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \\n (hG : card G > 2) (H : subgroup G) [fintype H] : \\n card H \\u2260 card G - 1 :=\"}"
  },
  {
    "informal_statement": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "formal_statement": "theorem exercise_4_12\\n {\\u03b1 \\u03b2 \\u03b3 : Type*} [uniform_space \\u03b1] [uniform_space \\u03b2] [uniform_space \\u03b3]\\n {f : \\u03b1 \\u2192 \\u03b2} {g : \\u03b2 \\u2192 \\u03b3}\\n (hf : uniform_continuous f) (hg : uniform_continuous g) :\\n uniform_continuous (g \\u2218 f) :=\"}"
  },
  {
    "informal_statement": "Prove that if $V$ is a complex inner-product space, then $\\\\langle u, v\\\\rangle=\\\\frac{\\\\|u+v\\\\|^{2}-\\\\|u-v\\\\|^{2}+\\\\|u+i v\\\\|^{2} i-\\\\|u-i v\\\\|^{2} i}{4}$ for all $u, v \\\\in V$.",
    "formal_statement": "theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\\n {U : submodule K V} : \\n U.orthogonal = \\u22a5 \\u2194 U = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\\\{z \\\\in \\\\mathbb{C}:|z| \\\\leq 1\\\\}$.",
    "formal_statement": "theorem exercise_2017_b3 (f : \\u211d \\u2192 \\u211d) (c : \\u2115 \\u2192 \\u211d)\\n (hf : f = \\u03bb x, (\\u2211' (i : \\u2115), (c i) * x^i)) \\n (hc : \\u2200 n, c n = 0 \\u2228 c n = 1)\\n (hf1 : f (2/3) = 3/2) : \\n irrational (f (1/2)) :=\"}"
  },
  {
    "informal_statement": "Prove that there is no rational number whose square is $12$.",
    "formal_statement": "theorem exercise_1_5 (A minus_A : set \\u211d) (hA : A.nonempty) \\n (hA_bdd_below : bdd_below A) (hminus_A : minus_A = {x | -x \\u2208 A}) :\\n Inf A = Sup minus_A :=\"}"
  },
  {
    "informal_statement": "Suppose $p \\\\in \\\\mathcal{P}(\\\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\\\prime}$ have no roots in common.",
    "formal_statement": "theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\\n [module F V] (S T : V \\u2192\\u2097[F] V) (hST : S \\u2218 T = T \\u2218 S) (c : F):\\n map S (T - c \\u2022 id).ker = (T - c \\u2022 id).ker :=\"}"
  },
  {
    "informal_statement": "Prove that the multiplicative groups $\\\\mathbb{R}-\\\\{0\\\\}$ and $\\\\mathbb{C}-\\\\{0\\\\}$ are not isomorphic.",
    "formal_statement": "theorem exercise_1_6_17 {G : Type*} [group G] (f : G \\u2192 G) \\n (hf : f = \\u03bb g, g\\u207b\\u00b9) :\\n \\u2200 x y : G, f x * f y = f (x*y) \\u2194 \\u2200 x y : G, x*y = y*x :=\"}"
  },
  {
    "informal_statement": "Suppose $T \\\\in \\\\mathcal{L}(V)$ is self-adjoint, $\\\\lambda \\\\in \\\\mathbf{F}$, and $\\\\epsilon>0$. Prove that if there exists $v \\\\in V$ such that $\\\\|v\\\\|=1$ and $\\\\|T v-\\\\lambda v\\\\|<\\\\epsilon,$ then $T$ has an eigenvalue $\\\\lambda^{\\\\prime}$ such that $\\\\left|\\\\lambda-\\\\lambda^{\\\\prime}\\\\right|<\\\\epsilon$.",
    "formal_statement": "theorem exercise_7_14 {\\ud835\\udd5c V : Type*} [is_R_or_C \\ud835\\udd5c]\\n [inner_product_space \\ud835\\udd5c V] [finite_dimensional \\ud835\\udd5c V]\\n {T : End \\ud835\\udd5c V} (hT : is_self_adjoint T)\\n {l : \\ud835\\udd5c} {\\u03b5 : \\u211d} (he : \\u03b5 > 0) : \\u2203 v : V, \\u2016v\\u2016= 1 \\u2227 (\\u2016T v - l \\u2022 v\\u2016 < \\u03b5 \\u2192\\n (\\u2203 l' : T.eigenvalues, \\u2016l - l'\\u2016 < \\u03b5)) :=\"}"
  },
  {
    "informal_statement": "Show that the rationals $\\\\mathbb{Q}$ are not locally compact.",
    "formal_statement": "theorem exercise_29_1 : \\u00ac locally_compact_space \\u211a :=\"}"
  },
  {
    "informal_statement": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "formal_statement": "theorem exercise_6_8_1 {G : Type*} [group G]\\n (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3} :=\"}"
  },
  {
    "informal_statement": "A map $f: X \\\\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\\\pi_{1}: X \\\\times Y \\\\rightarrow X$ and $\\\\pi_{2}: X \\\\times Y \\\\rightarrow Y$ are open maps.",
    "formal_statement": "theorem exercise_17_4 {X : Type*} [topological_space X]\\n (U A : set X) (hU : is_open U) (hA : is_closed A) :\\n is_open (U \\\\ A) \\u2227 is_closed (A \\\\ U) :=\"}"
  },
  {
    "informal_statement": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\\\operatorname{dim} V=1$ and $T \\\\in \\\\mathcal{L}(V, V)$, then there exists $a \\\\in \\\\mathbf{F}$ such that $T v=a v$ for all $v \\\\in V$.",
    "formal_statement": "theorem exercise_4_4 (p : polynomial \\u2102) :\\n p.degree = @card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102) \\u2194\\n disjoint\\n (@card (root_set p.derivative \\u2102) (polynomial.root_set_fintype p.derivative \\u2102))\\n (@card (root_set p \\u2102) (polynomial.root_set_fintype p \\u2102)) :=\"}"
  },
  {
    "informal_statement": "Prove that characteristic subgroups are normal.",
    "formal_statement": "theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\\n (hH : \\u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \\u2192 H = K) : \\n H.characteristic :=\"}"
  },
  {
    "informal_statement": "Show that the lower limit topology $\\\\mathbb{R}_l$ and $K$-topology $\\\\mathbb{R}_K$ are not comparable.",
    "formal_statement": "theorem exercise_13_8b :\\n (topological_space.generate_from {S : set \\u211d | \\u2203 a b : \\u211a, a < b \\u2227 S = Ico a b}).is_open \\u2260\\n (lower_limit_topology \\u211d).is_open :=\"}"
  },
  {
    "informal_statement": "is: If $a \\\\neq 0$, then the interior of the hyperplane $\\\\{x \\\\in \\\\mathbb{R}^n \\\\mid a \\\\cdot x = b\\\\}$ is empty.\"} {\"text\": \"constants (p q : Prop) (H : p \\u2227 q)\\ntheorem t_proof_left : p := and.elim_left H\\ntheorem t_proof_right : q := and.elim_right H\\ncheck t_proof_left -- t_proof_left : p\\ncheck t_proof_right -- t_proof_right : q\\n\"} {\"text\": \"\\ntheorem Ex003_1 (a b: Prop) : \\u00aca \\u2192 a \\u2192 b :=\\nassume A:\\u00aca,\\n assume B:a,\\n have C:false, from A B,\\n show b, from false.elim C\\n\\n\\ntheorem Ex003_2 (a b : Prop) : \\u00aca \\u2192 a \\u2192 b := \\nbegin\\n intro,\\n intro,\\n contradiction\\nend \\n\\n\\n\\n\\n\"} {\"text\": \"in",
    "formal_statement": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\\\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.formal statement theorem exercise_2_11_6 {G : Type*} [group G] {p : \\u2115} (hp : nat.prime p) \\n {P : sylow p G} (hP : P.normal) :\\n \\u2200 (Q : sylow p G), P = Q :=\"}"
  },
  {
    "informal_statement": "Let $\\\\mathcal{T}_\\\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\\\mathcal{T}_\\\\alpha$.",
    "formal_statement": "theorem exercise_13_5a {X : Type*}\\n [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\\n generate_from A = generate_from (sInter {T | is_topology X T \\u2227 A \\u2286 T}) :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\cos 1^{\\\\circ}$ is algebraic over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\\\cap J$ in $R / I J$ is nilpotent.",
    "formal_statement": "theorem exercise_10_7_10 {R : Type*} [ring R]\\n (M : ideal R) (hM : \\u2200 (x : R), x \\u2209 M \\u2192 is_unit x) :\\n is_maximal M \\u2227 \\u2200 (N : ideal R), is_maximal N \\u2192 N = M :=\"}"
  },
  {
    "informal_statement": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\\\in R$ then $x=\\\\pm 1$.",
    "formal_statement": "theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \\u2200 a : R, a^2 = a) :\\n comm_ring R :=\"}"
  },
  {
    "informal_statement": "A map $f: X \\\\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\\\pi_{1}: X \\\\times Y \\\\rightarrow X$ and $\\\\pi_{2}: X \\\\times Y \\\\rightarrow Y$ are open maps.",
    "formal_statement": "theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\\n (\\u03c0\\u2081 : X \\u00d7 Y \\u2192 X)\\n (\\u03c0\\u2082 : X \\u00d7 Y \\u2192 Y)\\n (h\\u2081 : \\u03c0\\u2081 = prod.fst)\\n (h\\u2082 : \\u03c0\\u2082 = prod.snd) :\\n is_open_map \\u03c0\\u2081 \\u2227 is_open_map \\u03c0\\u2082 :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i<n} a_i = \\\\infty$, where $a_i = \\\\sqrt{i + 1} -\\\\sqrt{i}$.",
    "formal_statement": "theorem exercise_3_6a\\n: tendsto (\\u03bb (n : \\u2115), (\\u2211 i in finset.range n, g i)) at_top at_top :=\"}"
  },
  {
    "informal_statement": "Suppose $X$ is a nonempty complete metric space, and $\\\\left\\\\{G_{n}\\\\right\\\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\\\bigcap_{1}^{\\\\infty} G_{n}$ is not empty.",
    "formal_statement": "theorem exercise_4_2a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (h\\u2081 : continuous f)\\n : \\u2200 (x : set \\u03b1), f '' (closure x) \\u2286 closure (f '' x) :=\"}"
  },
  {
    "informal_statement": "Suppose $u, v \\\\in V$. Prove that $\\\\langle u, v\\\\rangle=0$ if and only if $\\\\|u\\\\| \\\\leq\\\\|u+a v\\\\|$ for all $a \\\\in \\\\mathbf{F}$.",
    "formal_statement": "theorem exercise_6_7 {V : Type*} [inner_product_space \\u2102 V] (u v : V) :\\n \\u27eau, v\\u27eb_\\u2102 = (\\u2016u + v\\u2016^2 - \\u2016u - v\\u2016^2 + I*\\u2016u + I\\u2022v\\u2016^2 - I*\\u2016u-I\\u2022v\\u2016^2) / 4 :=\"}"
  },
  {
    "informal_statement": "Show that the collection $\\\\{(a,b) \\\\mid a < b, a \\\\text{ and } b \\\\text{ rational}\\\\}$ is a basis that generates a topology different from the lower limit topology on $\\\\mathbb{R}$.",
    "formal_statement": "theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\\n (\\u03c0\\u2081 : X \\u00d7 Y \\u2192 X)\\n (\\u03c0\\u2082 : X \\u00d7 Y \\u2192 Y)\\n (h\\u2081 : \\u03c0\\u2081 = prod.fst)\\n (h\\u2082 : \\u03c0\\u2082 = prod.snd) :\\n is_open_map \\u03c0\\u2081 \\u2227 is_open_map \\u03c0\\u2082 :=\"}"
  },
  {
    "informal_statement": "If $f$ is a real continuous function defined on a closed set $E \\\\subset \\\\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\\\in E$.",
    "formal_statement": "theorem exercise_4_6\\n (f : \\u211d \\u2192 \\u211d)\\n (E : set \\u211d)\\n (G : set (\\u211d \\u00d7 \\u211d))\\n (h\\u2081 : is_compact E)\\n (h\\u2082 : G = {(x, f x) | x \\u2208 E})\\n : continuous_on f E \\u2194 is_compact G :=\"}"
  },
  {
    "informal_statement": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "formal_statement": "theorem exercise_9_4_2b : irreducible \\n (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \\u2124) :=\"}"
  },

  {
    "informal_statement": "Let $X$ be a compact Hausdorff space. Let $\\\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\\\bigcap_{A \\\\in \\\\mathcal{A}} A$ is connected.",
    "formal_statement": "theorem exercise_26_11\\n {X : Type*} [topological_space X] [compact_space X] [t2_space X]\\n (A : set (set X)) (hA : \\u2200 (a b : set X), a \\u2208 A \\u2192 b \\u2208 A \\u2192 a \\u2286 b \\u2228 b \\u2286 a)\\n (hA' : \\u2200 a \\u2208 A, is_closed a) (hA'' : \\u2200 a \\u2208 A, is_connected a) :\\n is_connected (\\u22c2\\u2080 A) :=\"}"
  },
  {
    "informal_statement": "Suppose $a, b \\\\in R^k$. Find $c \\\\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "formal_statement": "theorem exercise_2_24 {X : Type*} [metric_space X]\\n (hX : \\u2200 (A : set X), infinite A \\u2192 \\u2203 (x : X), x \\u2208 closure A) :\\n separable_space X :=\"}"
  },
  {
    "informal_statement": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "formal_statement": "theorem exercise_4_5_16 {p q r : \\u2115} {G : Type*} [group G] \\n [fintype G] (hpqr : p < q \\u2227 q < r) \\n (hpqr1 : p.prime \\u2227 q.prime \\u2227 r.prime)(hG : card G = p*q*r) : \\n nonempty (sylow p G) \\u2228 nonempty(sylow q G) \\u2228 nonempty(sylow r G) :=\"}"
  },
  {
    "informal_statement": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "formal_statement": "theorem exercise_1_1_18 {G : Type*} [group G]\\n (x y : G) : x * y = y * x \\u2194 y\\u207b\\u00b9 * x * y = x \\u2194 x\\u207b\\u00b9 * y\\u207b\\u00b9 * x * y = 1 :=\"}"
  },
  {
    "informal_statement": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "formal_statement": "theorem exercise_6_8_1 {G : Type*} [group G]\\n (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3} :=\"}"
  },
  {
    "informal_statement": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "formal_statement": "theorem exercise_3_5 : \\u00ac \\u2203 x y : \\u2124, 7*x^3 + 2 = y^3 :=\"}"
  },
  {
    "informal_statement": "Show that 2 is divisible by $(1+i)^{2}$ in $\\\\mathbb{Z}[i]$.",
    "formal_statement": "theorem exercise_2_21 {l : \\u2115 \\u2192 \\u211d} \\n (hl : \\u2200 p n : \\u2115, p.prime \\u2192 l (p^n) = log p )\\n (hl1 : \\u2200 m : \\u2115, \\u00ac is_prime_pow m \\u2192 l m = 0) :\\n l = \\u03bb n, \\u2211 d : divisors n, moebius (n/d) * log d :=\"}"
  },
  {
    "informal_statement": "Define $\\\\wedge(n)=\\\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\\\sum_{A \\\\mid n} \\\\mu(n / d) \\\\log d$ $=\\\\wedge(n)$.",
    "formal_statement": "theorem exercise_2_21 {l : \\u2115 \\u2192 \\u211d} \\n (hl : \\u2200 p n : \\u2115, p.prime \\u2192 l (p^n) = log p )\\n (hl1 : \\u2200 m : \\u2115, \\u00ac is_prime_pow m \\u2192 l m = 0) :\\n l = \\u03bb n, \\u2211 d : divisors n, moebius (n/d) * log d :=\"}"
  },
  {
    "informal_statement": "For all odd $n$ show that $8 \\\\mid n^{2}-1$.",
    "formal_statement": "theorem exercise_1_31 : (\\u27e81, 1\\u27e9 : gaussian_int) ^ 2 \\u2223 2 :=\"}"
  },
  {
    "informal_statement": "Define $f_{n}:[0,1] \\\\rightarrow \\\\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\\\left(f_{n}(x)\\\\right)$ converges for each $x \\\\in[0,1]$.",
    "formal_statement": "theorem exercise_21_8\\n {X : Type*} [topological_space X] {Y : Type*} [metric_space Y]\\n {f : \\u2115 \\u2192 X \\u2192 Y} {x : \\u2115 \\u2192 X}\\n (hf : \\u2200 n, continuous (f n))\\n (x\\u2080 : X)\\n (hx : tendsto x at_top (\\ud835\\udcdd x\\u2080))\\n (f\\u2080 : X \\u2192 Y)\\n (hh : tendsto_uniformly f f\\u2080 at_top) :\\n tendsto (\\u03bb n, f n (x n)) at_top (\\ud835\\udcdd (f\\u2080 x\\u2080)) :=\"}"
  },
  {
    "informal_statement": "If $G$ is a group and $a, x \\\\in G$, prove that $C\\\\left(x^{-1} a x\\\\right)=x^{-1} C(a) x$",
    "formal_statement": "theorem exercise_2_4_36 {a n : \\u2115} (h : a > 1) :\\n n \\u2223 (a ^ n - 1).totient :=\"}"
  },
  {
    "informal_statement": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\\\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\\\left(f_{n}\\\\right)$ converges uniformly to $f$, then $\\\\left(f_{n}\\\\left(x_{n}\\\\right)\\\\right)$ converges to $f(x)$.",
    "formal_statement": "theorem exercise_22_2b {X : Type*} [topological_space X]\\n {A : set X} (r : X \\u2192 A) (hr : continuous r) (h : \\u2200 x : A, r x = x) :\\n quotient_map r :=\"}"
  },
  {
    "informal_statement": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "formal_statement": "theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\\n \\u2200 a b : A \\u29f8 B, a*b = b*a :=\"}"
  },
  {
    "informal_statement": "Prove that characteristic subgroups are normal.",
    "formal_statement": "theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\\n [subgroup.characteristic H] : subgroup.normal H :=\"}"
  },
  {
    "informal_statement": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "formal_statement": "theorem exercise_8_3_6a {R : Type*} [ring R]\\n (hR : R = (gaussian_int \\u29f8 ideal.span ({\\u27e80, 1\\u27e9} : set gaussian_int))) :\\n is_field R \\u2227 \\u2203 finR : fintype R, @card R finR = 2 :=\"}"
  },
  {
    "informal_statement": "Let $H \\\\leq K \\\\leq G$. Prove that $|G: H|=|G: K| \\\\cdot|K: H|$ (do not assume $G$ is finite).",
    "formal_statement": "theorem exercise_3_2_11 {G : Type*} [group G] {H K : subgroup G}\\n (hHK : H \\u2264 K) : \\n H.index = K.index * H.relindex K :=\"}"
  },
  {
    "informal_statement": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "formal_statement": "theorem exercise_3_1 : infinite {p : primes // p \\u2261 -1 [ZMOD 6]} :=\"}"
  },
  {
    "informal_statement": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "formal_statement": "theorem exercise_32_1 {X : Type*} [topological_space X]\\n (hX : normal_space X) (A : set X) (hA : is_closed A) :\\n normal_space {x // x \\u2208 A} :=\"}"
  },
  {
    "informal_statement": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "formal_statement": "theorem exercise_4_1_19 : infinite {x : quaternion \\u211d | x^2 = -1} :=\"}"
  },
  {
    "informal_statement": "Define $\\\\wedge(n)=\\\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\\\sum_{A \\\\mid n} \\\\mu(n / d) \\\\log d$ $=\\\\wedge(n)$.",
    "formal_statement": "theorem exercise_3_1 : infinite {p : primes // p \\u2261 -1 [ZMOD 6]} :=\"}"
  },
  {
    "informal_statement": "If $C_{0}+\\\\frac{C_{1}}{2}+\\\\cdots+\\\\frac{C_{n-1}}{n}+\\\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\\\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "formal_statement": "theorem exercise_5_6\\n {f : \\u211d \\u2192 \\u211d}\\n (hf1 : continuous f)\\n (hf2 : \\u2200 x, differentiable_at \\u211d f x)\\n (hf3 : f 0 = 0)\\n (hf4 : monotone (deriv f)) :\\n monotone_on (\\u03bb x, f x / x) (set.Ioi 0) :=\"}"
  },
  {
    "informal_statement": "Show that $\\\\int_0^1 \\\\log(\\\\sin \\\\pi x) dx = - \\\\log 2$.",
    "formal_statement": "theorem exercise_3_9 : \\u222b x in 0..1, real.log (real.sin (real.pi * x)) = - real.log 2 :=\"}"
  },
  {
    "informal_statement": "Prove that $\\\\cos 1^{\\\\circ}$ is algebraic over $\\\\mathbb{Q}$.",
    "formal_statement": "theorem exercise_5_3_10 : is_algebraic \\u211a (cos (real.pi / 180)) :=\"}"
  },
  {
    "informal_statement": "Let $F = \\\\mathbb{Z}_p$ be the field of integers $\\\\mod p$, where $p$ is a prime, and let $q(x) \\\\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "formal_statement": "theorem exercise_4_5_25 {p : \\u2115} (hp : nat.prime p) :\\n irreducible (\\u2211 i : finset.range p, X ^ p : polynomial \\u211a) :=\"}"
  },
  {
    "informal_statement": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "formal_statement": "theorem exercise_6_1_14 (G : Type*) [group G]\\n (hG : is_cyclic $ G \\u29f8 (center G)) :\\n center G = \\u22a4 :=\"}"
  },
  {
    "informal_statement": "If $s_{1}=\\\\sqrt{2}$, and $s_{n+1}=\\\\sqrt{2+\\\\sqrt{s_{n}}} \\\\quad(n=1,2,3, \\\\ldots),$ prove that $\\\\left\\\\{s_{n}\\\\right\\\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\\\ldots$.",
    "formal_statement": "theorem exercise_3_6a\\n: tendsto (\\u03bb (n : \\u2115), (\\u2211 i in finset.range n, g i)) at_top at_top :=\"}"
  },
  {
    "informal_statement": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "formal_statement": "theorem exercise_4_4a\\n {\\u03b1 : Type} [metric_space \\u03b1]\\n {\\u03b2 : Type} [metric_space \\u03b2]\\n (f : \\u03b1 \\u2192 \\u03b2)\\n (s : set \\u03b1)\\n (h\\u2081 : continuous f)\\n (h\\u2082 : dense s)\\n : f '' set.univ \\u2286 closure (f '' s) :=\"}"
  }
]